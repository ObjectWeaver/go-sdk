{"assessingTool":"Complexity","filePath":"client/client.go","grade":"B+","username":"HLamb","timestamp":"2025-10-21T17:59:27.979Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"nestingDepth","violatingCode":"The SendRequest method in the Client type exhibits excessive nesting, making the code harder to read and maintain.\n\n```go\n\tresp, err := c.RequestSender.SendRequestBody(c.BaseURL, c.Password, requestBody)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n```","codeResolution":"The solution for nestingDepth refactors the SendRequest method to delegate responsibilities to helper abstractions, reducing the nesting level and improving readability.\n\n```go\n// Go\nfunc (c *Client) SendRequest(prompt string, definition *jsonSchema.Definition) (*Response, error) {\n\trequestBody := NewRequestBody(prompt, definition)\n\tresp, err := c.RequestSender.SendRequestBody(c.BaseURL, c.Password, requestBody)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.ResponseProcessor.ProcessResponse(resp)\n}\n```","severity":"Critical","rationale":"The nesting depth in the provided code is minimal, which is beneficial for maintainability and readability. Functions like `SendRequest` avoid deep nesting by delegating responsibilities to other components (`RequestSender` and `ResponseProcessor`). This flat structure makes the code easier to test and less prone to errors, as each function has a clear, single responsibility. If nesting were deeper (e.g., multiple levels of conditionals or loops within `SendRequest`), it would increase cognitive load, make debugging harder, and complicate future changes. Keeping nesting depth low, as shown here, supports clean architecture and reduces the risk of introducing subtle bugs.","lineStart":38,"lineEnd":41,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode only defines three functions, causing the SendRequest method to handle both request construction and response processing, which violates functionMethodCounts principles by combining multiple responsibilities.\n\n```go\nfunc (c *Client) SendRequest(prompt string, definition *jsonSchema.Definition) (*Response, error) {\n\trequestBody := &RequestBody{\n\t\tPrompt:     prompt,\n\t\tDefinition: definition,\n\t}\n\t// Use the RequestSender to send the request\n\tresp, err := c.RequestSender.SendRequestBody(c.BaseURL, c.Password, requestBody)\n```","codeResolution":"The solution for functionMethodCounts involves refactoring the monolithic SendRequest method to delegate responsibilities to specialized abstractions, improving maintainability and testability.\n\n```go\n// SendRequest delegates request sending and response processing to abstractions.\nfunc (c *Client) SendRequest(prompt string, definition *jsonSchema.Definition) (*Response, error) {\n\trequestBody := &RequestBody{Prompt: prompt, Definition: definition}\n\tresp, err := c.RequestSender.SendRequestBody(c.BaseURL, c.Password, requestBody)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.ResponseProcessor.ProcessResponse(resp)\n}\n```","severity":"Critical","rationale":"This code defines only three methods on the Client type and two constructors, resulting in a low function/method count. Most logic is concentrated in SendRequest (lines 34–51), which handles request creation, sending, and response processing. This violates functionMethodCounts principles by combining multiple responsibilities into a single method, making the code harder to maintain and test. If future changes are needed (e.g., custom error handling or logging), the monolithic structure will complicate updates and increase the risk of bugs. Splitting responsibilities into smaller, focused methods would improve maintainability and correctness.","lineStart":13,"lineEnd":41,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode repeats similar initialization logic in both NewDefaultClient and NewGZipClient, unnecessarily increasing lines of code and reducing maintainability.\n\n```go\nreturn &Client{\n\tPassword:          password,\n\tBaseURL:           url,\n\tHttpClient:        client,\n\tRequestSender:     NewDefaultRequestSender(client),\n\tResponseProcessor: NewResponseProcessor(),\n}\n```","codeResolution":"The solution for linesOfCode streamlines the SendRequest method by delegating request sending and response processing to well-defined abstractions, reducing complexity and improving maintainability.\n\n```go\nfunc (c *Client) SendRequest(prompt string, definition *jsonSchema.Definition) (*Response, error) {\n\trequestBody := &RequestBody{Prompt: prompt, Definition: definition}\n\tresp, err := c.RequestSender.SendRequestBody(c.BaseURL, c.Password, requestBody)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.ResponseProcessor.ProcessResponse(resp)\n}\n```","severity":"Critical","rationale":"The code snippet demonstrates moderate adherence to linesOfCode principles, but there is room for improvement. Several functions, such as `NewDefaultClient` and `NewGZipClient`, contain repeated logic for initializing the `Client` struct (lines 22–38). This duplication increases the total LoC unnecessarily and can hinder maintainability, as future changes must be replicated in multiple places. Consolidating shared initialization logic into a single helper function would reduce LoC, making the codebase easier to update and less error-prone. Excess lines also make the code harder to review and test, increasing the risk of subtle bugs.","lineStart":31,"lineEnd":34,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code does not violate dependenciesModules principles, as it only imports two necessary packages and maintains a minimal, appropriate dependency footprint.\n\n```go\nimport (\n\t\"net/http\"\n\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n)\n```","codeResolution":"The solution for dependenciesModules demonstrates a clean separation of concerns by leveraging interfaces for HTTP operations, request sending, and response processing, ensuring extensibility without increasing external dependencies.\n\n```go\n// Replace direct calls with abstraction usage\nresp, err := c.RequestSender.SendRequestBody(c.BaseURL, c.Password, requestBody)\nif err != nil {\n    return nil, err\n}\nreturn c.ResponseProcessor.ProcessResponse(resp)\n```","severity":"Critical","rationale":"The code imports only two packages: the standard library's `net/http` and a third-party package `github.com/objectweaver/go-sdk/jsonSchema`. This is appropriate for the functionality shown, as it avoids unnecessary dependencies, which helps maintainability and reduces the risk of version conflicts. However, if future features require additional modules, care should be taken to keep imports minimal and relevant. Excessive dependencies can increase build times, complicate updates, and introduce security vulnerabilities. Keeping the dependency list concise, as in this snippet, supports better long-term maintainability and performance.","lineStart":3,"lineEnd":13,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The SendRequest method introduces unnecessary complexity by combining request construction, sending, and response processing in a single function.\n\n```go\nfunc (c *Client) SendRequest(prompt string, definition *jsonSchema.Definition) (*Response, error) {\n\trequestBody := &RequestBody{\n\t\tPrompt:     prompt,\n\t\tDefinition: definition,\n\t}\n\t// Use the RequestSender to send the request\n\tresp, err := c.RequestSender.SendRequestBody(c.BaseURL, c.Password, requestBody)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Process the response\n\treturn c.ResponseProcessor.ProcessResponse(resp)\n}\n```","codeResolution":"The solution for cyclomatic complexity in the Client's SendRequest method involves delegating request sending and response processing to dedicated abstractions, reducing branching and improving maintainability.\n\n```go\n// SendRequest delegates to RequestSender and ResponseProcessor for clarity and simplicity.\nfunc (c *Client) SendRequest(prompt string, definition *jsonSchema.Definition) (*Response, error) {\n\trequestBody := &RequestBody{Prompt: prompt, Definition: definition}\n\tresp, err := c.RequestSender.SendRequestBody(c.BaseURL, c.Password, requestBody)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.ResponseProcessor.ProcessResponse(resp)\n}\n```","severity":"Critical","rationale":"Cyclomatic complexity is important because it directly impacts code maintainability and testability. In the provided code, the `SendRequest` method (lines 32–48) has low cyclomatic complexity, with a straightforward linear flow and minimal branching. This makes the code easier to understand, modify, and test. If complexity were higher—such as with deeply nested conditionals or multiple decision points—it would increase the risk of bugs, make future changes harder, and complicate unit testing. Keeping cyclomatic complexity low, as shown here, ensures the code remains robust and maintainable.","lineStart":38,"lineEnd":41,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A+","readability":"A+","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":2,"functionMethodCounts":3,"linesOfCode":66,"nestingDepth":2}},"hash":"366888da651aa5981aa0f058837b1d315e2458513b56eb6921204b0def688300","id":"eJzdVclu2zAQ/ZWpDoFsqNLdQC5JgOZQFEaWS+ELTY0kJvJQIUdx0yD/XnDRFqdAe+ilusia5fHNvBn6NRHWorWK6jut22STXOpD1+IPxS9Jlkhd4qUmRuJkk3RCPooaQbYKiXe0I3XotGFId7TjXULIRcPc7RLnc5ZacdPvc6kPhd4/oOQjimc0Ra0/2/KxeLCabmWDB+FSVi6rKODSw4NB22myat8iVNpAo9tSUQ17YRGkpkrVvRGsNIGgEkrskEokqdDuiF86HIAsm14yvDpKW2HtUZsSxseyUVQ734WweH/zFT7yXTN3ES4+k8X5b/CpR8u3joLx/oUlhPh6cGu0RGu1gRPLjt5iD2bnKWI0lZAIrEHsLRshGa7v7ragOwwdGCr+MM0XfqVTg0+wdvrkkdsK0uE7EMkAjdFmNfFY1jVhDjwsmBABFinIg414Vq4Wz+h3AJ6Us8aAC12+pL1pM2D9iBRbnw3wzg3rWewfcP+GxyusRN/y2BLFSrTqJ1oQQHiE0WFZkEQ4Km6gDEmg3CIckHhocdWTPEFNuzhSGfSmHXmHHYn9DpErWMfzfPEGuTcEZ8HmTdN8bqYhHPFDRJzSWYA7Nzon/Ud/IBL9CzVCyFTPwpmGvNWY+G5UNy7xxJqG+LeFCF++q+7vFHAZIPWhM+5q0uT3P07CTIcJ+D8QwRXzTxSYLZlfUgvcIHRGHzqON2flddGU+e/QkxgmjMVyuIsx9j6VQxdXc/g0gg7tn4BhPV31+dVodkv8fn8HXaa135zD2WzzB5H8WaF94dzYqAl+My8tdsW9igLuLfr6ltcTa98h74kMAhnbeXqOiswXOfn7O0zmcTgykPl2HMtZQe5/jlXlAT+dA6kWYk1xGkm1/rgl5ShxJDfoMSbJ/GQW8vhrcKQuLVyQSZZUqsWt4CbZJGHSivDKa528/QJsTe9D"}
{"assessingTool":"Complexity","filePath":"client/req.go","grade":"B+","username":"HLamb","timestamp":"2025-10-21T17:59:26.268Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode suffers from excessive lines of code due to deeply nested logic and repeated procedural steps that could be modularized for clarity and maintainability.\n\n```go\n\tfor key, value := range currentGen {\n\t\td.Req.Body[key] = value\n\t}\n```","codeResolution":"The solution for linesOfCode focuses on reducing verbosity and improving maintainability by abstracting request execution logic into a reusable operation. Replace the original block with the following streamlined code:\n\n```go\n// Go\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\top := getOperation(def, currentGen)\n\tresult, err := op.Execute()\n\tif err != nil {\n\t\tlog.Println(\"failed to execute operation\", err)\n\t\treturn nil\n\t}\n\treturn result\n}\n```","severity":"Critical","rationale":"## Rationale\n\nThe code snippet demonstrates excessive lines of code due to repeated logic and lack of modularization, especially in `ExecuteRequest`. For example, merging `currentGen` into `d.Req.Body` and setting headers are handled inline rather than abstracted into helper functions. This increases the code’s length and complexity, making it harder to maintain and test. High LoC can obscure bugs and hinder readability, as future changes require navigating through dense, monolithic blocks. Refactoring into smaller, purpose-driven functions would reduce LoC, improve maintainability, and make unit testing more straightforward.","lineStart":23,"lineEnd":44,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code unnecessarily imports five packages, including both standard and external libraries, when only a subset is required for the core functionality.\n\n```go\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n)\n```","codeResolution":"The solution for codeResolution introduces a clear separation of concerns by delegating the request execution to an abstracted operation handler, improving maintainability and testability.\n\n```go\n// Go\n\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\top := getOperation(def, currentGen)\n\tresult, err := op.Execute()\n\tif err != nil {\n\t\tlog.Println(\"failed to execute operation\", err)\n\t\treturn nil\n\t}\n\treturn result\n}\n```","severity":"Critical","rationale":"## Rationale\n\nThe code imports five packages, including a third-party module (`github.com/objectweaver/go-sdk/jsonSchema`). While all dependencies appear necessary for functionality, excessive or poorly managed imports can hinder maintainability by increasing coupling and making upgrades or replacements more difficult. For example, reliance on a specific SDK (`jsonSchema`) ties the code to its API and update cycle. Unused imports (none present here) would also bloat the codebase and impact performance. Streamlining dependencies and isolating external modules improves testability and reduces the risk of breaking changes from upstream updates.","lineStart":7,"lineEnd":23,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The ExecuteRequest function exhibits excessive nesting, making the core logic difficult to follow and maintain.\n\n```go\nif d.Req.Body == nil {\n\td.Req.Body = make(map[string]interface{})\n}\nfor key, value := range currentGen {\n\td.Req.Body[key] = value\n}\n```","codeResolution":"The solution for nestingDepth refactors the SendRequest function to use guard clauses, reducing unnecessary nesting and improving readability.\n\n```go\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\trequest, err := ExecuteRequest(currentGen, def)\n\tif err != nil {\n\t\tlog.Println(\"failed to execute request\", err)\n\t\treturn nil\n\t}\n\tvalue, err := extractValue(request)\n\tif err != nil {\n\t\tlog.Println(\"failed to extract value\", err)\n\t\treturn nil\n\t}\n\treturn value\n}\n```","severity":"Critical","rationale":"The code demonstrates moderate nesting depth, particularly in the `SendRequest` function, where error handling is performed within nested `if` statements. While not excessive, this pattern can hinder maintainability by making the control flow harder to follow and increasing the risk of missing edge cases. For example, lines handling errors after calling `ExecuteRequest` and `extractValue` could be refactored using guard clauses to flatten the structure. Reducing nesting depth improves readability, simplifies future modifications, and makes unit testing more straightforward.","lineStart":23,"lineEnd":44,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The ExecuteRequest function contains multiple nested control structures and sequential error checks, resulting in elevated cyclomatic complexity and reduced maintainability.\n\n```go\nfor key, value := range currentGen {\n\td.Req.Body[key] = value\n}\n```","codeResolution":"The solution for cyclomatic complexity refactors the monolithic request execution logic into smaller, focused abstractions, reducing branching and improving maintainability. Replace the original request construction and execution block with the following:\n\n```go\n// Go\nop := getOperation(d.Req.Method)\nreq, err := op.BuildRequest(d, currentGen)\nif err != nil {\n\treturn nil, fmt.Errorf(\"failed to build request: %w\", err)\n}\nresp, err := op.Execute(req)\nif err != nil {\n\treturn nil, fmt.Errorf(\"failed to execute request: %w\", err)\n}\n```","severity":"Critical","rationale":"Cyclomatic complexity is a concern here because both `ExecuteRequest` and `SendRequest` contain multiple branching paths (e.g., error handling, map merging, header setting) within single functions. This increases the number of independent code paths, making the logic harder to follow, test, and maintain. For example, lines handling body merging, error checks after marshaling, request creation, and response handling are all nested, which can obscure bugs and complicate future changes. Refactoring these into smaller, focused functions would reduce complexity, improve readability, and make unit testing more straightforward.","lineStart":22,"lineEnd":41,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The code violates functionMethodCounts principles by combining multiple responsibilities—request preparation, execution, and error handling—into a single, monolithic function.\n\n```go\nfunc ExecuteRequest(currentGen map[string]any, d *jsonSchema.Definition) (*http.Response, error) {\n\t// Merge currentGen into the existing body\n\t// Marshal the body to JSON\n\t// Create the HTTP request\n\t// Set headers and authorization\n\t// Execute the request\n}\n```","codeResolution":"The code currently centralizes multiple responsibilities within `ExecuteRequest`, which can be improved by delegating distinct tasks to dedicated helper functions for better maintainability and clarity.\n\n```go\n// Go\nfunc ExecuteRequest(currentGen map[string]any, d *jsonSchema.Definition) (*http.Response, error) {\n\tmergeBody(currentGen, d)\n\tbody, err := marshalBody(d)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq, err := buildRequest(d, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn sendRequest(req)\n}\n```","severity":"Critical","rationale":"This code violates functionMethodCounts principles by concentrating multiple responsibilities within just two functions: `ExecuteRequest` and `SendRequest`. For example, lines 10–38 in `ExecuteRequest` handle body merging, JSON marshaling, request creation, header setting, and HTTP execution all in one place. This monolithic approach makes the code difficult to maintain and test, as changes to one aspect (e.g., header logic) risk unintended side effects elsewhere. Splitting these responsibilities into smaller, focused functions would improve readability, facilitate unit testing, and reduce the likelihood of bugs.","lineStart":21,"lineEnd":44,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A-","qualityDesign":"A","readability":"A-","testability":"A-"},"issues":{"cyclomaticComplexity":6,"dependenciesModules":6,"functionMethodCounts":2,"linesOfCode":70,"nestingDepth":2}},"hash":"1975f576e61dd694777b9838e1453396db8d8b354d10bd8250b3176e0e943d6f","id":"eJylVFFv0zAQ/iuHJVAyheS90h5gDCYEY2oHL4QHN7kkpsm5sy90Zep/R3acNgV1k9hLVZ/P33133+V7ENJatFZRfat1K2biQnfrFu8Vb0UiCl3ihSZGYjETa1msZI1QtAqJc8pJdWttGKKccs7FcstoczEckApdKqqzn1bTGKw6Hv+2uh7/EnLWMK/92UdqxU2/TAvdZXr5EwveoPyFJqv1a1uuPOSiaLCT7knsXmUZXN5j0TPO8a5Hy4DD0YIkuLq9vQETLpbSYgmagBuEkP1em05yTlVPxV9AUdEbg8QfkKCT6++WjaL6h6RtAiWcHbik77BSpFhpiiE6cx2lc7RrTRYTQGO0ieHBNZhl8BmNm+QBWhFrzwjvlWVFNSx1uXXZqoIyneNd+laXWzg/B1LtgJPz9AI6ucJoQlERo6lkgQ87NyPeuZ9KG1jhNoFfsu0RZudgJB1T+Qf7+wq3P+B8eDIihT6ksY1sPXNHGFjDx8WXa3ftzr5xV8XNKQ3Z0QE6Dh26rBdHrRnk3pCLJFB1nF66AVZRLiqpWixdoS4Ud4Vm8HKTC18uPqZ4YVAyeobTPXC3Bu/2BL1e17gZZR+GGKh+Rm50GSdBia/zTwn4dXcv3vZVhSZyLOJn9VMMTAPB0x0tkKFBWaKxj0k6cL0aEg80xlC6QI4O7w4rEirInhtt1G/pNjpMa/o0F2+OMsQ4naNwvGcdPisvxESDwU0c61deggt/ftgNFe16L9CQmL7TkcG7Z805WMMTgw5AAwdSbU674DR+2bHVG9BF0RsLG8WNGgzFf3QkW9hos1JUW4gUuNtVHOxlgVSOS1ZidcJCEjjpOzGczdGOVjIZJ3AjGZQF6yaqewZCLK1r2SKVPiJHXAcKuvKkayQ0kp0tertNxwl42L0CJ40xgRKr05K0uk5vjCJu6TEdphpMdZxo4jd1zwfv2ciCv7lgFED+h4VHCe72NIcQDGa4y0kkolIt3khuxEwMa5q5j6XWYvcHIRipsA=="}
{"assessingTool":"Complexity","filePath":"converison/hashmap.go","grade":"B+","username":"HLamb","timestamp":"2025-10-21T17:59:23.173Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"nestingDepth","violatingCode":"The ConvertProtoToHashMap and ConvertModelToProtoHashMap functions adhere well to nestingDepth principles, maintaining a flat structure with only a single conditional check.\n\n```go\nif protoHashMap == nil {\n\treturn nil\n}\n```","codeResolution":"The solution for nestingDepth focuses on flattening control structures and delegating responsibilities to helper functions, resulting in clearer and more maintainable code.\n\n```go\n// Replacement for the block in ConvertProtoToHashMap\nif protoHashMap == nil {\n\treturn nil\n}\nreturn convertHashMapFields(protoHashMap)\n\n// Replacement for the block in ConvertModelToProtoHashMap\nif modelHashMap == nil {\n\treturn nil\n}\nreturn convertProtoFields(modelHashMap)\n```","severity":"Critical","rationale":"Deep nesting is not present in this code, which is positive for maintainability and readability. Both conversion functions use a single guard clause to check for nil input, followed by a flat return statement. This approach minimizes cognitive load and makes the logic easy to follow. If future logic is added, care should be taken to avoid introducing additional nesting, as deeper nesting would make the conversion process harder to test and maintain. Keeping nesting depth low ensures that the code remains straightforward and less error-prone.","lineStart":13,"lineEnd":18,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The ConvertProtoToHashMap and ConvertModelToProtoHashMap functions do not introduce any branching logic beyond simple nil checks, resulting in minimal cyclomatic complexity.\n\n```go\nif protoHashMap == nil {\n\treturn nil\n}\n```","codeResolution":"The solution for cyclomatic complexity involves refactoring deeply nested logic into smaller, focused abstractions, making the code easier to read and maintain. Here is the replacement code for the block identified in `violatingCode`:\n\n```go\n// Go\nreturn &jsonSchema.HashMap{\n\tKeyInstruction:  protoHashMap.KeyInstruction,\n\tFieldDefinition: getOperation(protoHashMap.FieldDefinition).Convert(),\n}\n```","severity":"Critical","rationale":"The cyclomatic complexity in this code is low, with each function containing only a single conditional branch. This simplicity is beneficial for maintainability and correctness, as it makes the code easy to read, test, and debug. Low complexity reduces the risk of hidden bugs and makes future modifications straightforward. However, if additional logic is introduced without careful structuring, complexity could increase rapidly. Maintaining this low complexity ensures the code remains robust and scalable.","lineStart":9,"lineEnd":22,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode uses repetitive boilerplate in both conversion functions, unnecessarily increasing lines of code and reducing maintainability.\n\n```go\nif protoHashMap == nil {\n\treturn nil\n}\n```","codeResolution":"The codeResolution streamlines the conversion logic by delegating the conversion process to a reusable abstraction, reducing repetition and improving maintainability.\n\n```go\n// Replace the conversion logic with calls to the generic conversion abstraction\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\treturn convertHashMap(protoHashMap)\n}\n\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n\treturn convertHashMap(modelHashMap)\n}\n```","severity":"Critical","rationale":"The rationale for linesOfCode in this snippet centers on maintainability and clarity. While the code is concise, each function directly handles conversion logic without unnecessary nesting or verbose constructs. This minimalism reduces cognitive load and makes future modifications straightforward. However, if the conversion logic grows, a single-responsibility approach (splitting logic into smaller helper functions) would help keep LoC manageable and maintainable. Excessive lines can obscure bugs and complicate testing, while too few lines may hide complexity in dense statements. The current balance is good, but vigilance is needed as features expand.","lineStart":7,"lineEnd":22,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode only defines two functions, causing each to handle multiple responsibilities and limiting maintainability.\n\n```go\n// ConvertProtoToHashMap converts a protobuf HashMap to the Go model HashMap\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\tif protoHashMap == nil {\n\t\treturn nil\n\t}\n\n\treturn &jsonSchema.HashMap{\n\t\tKeyInstruction:  protoHashMap.KeyInstruction,\n\t\tFieldDefinition: ConvertProtoToModel(protoHashMap.FieldDefinition),\n\t}\n}\n```","codeResolution":"The conversion logic should be refactored to delegate field conversion to a dedicated abstraction, improving separation of concerns and maintainability.\n\n```go\n// Go\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\tif protoHashMap == nil {\n\t\treturn nil\n\t}\n\treturn &jsonSchema.HashMap{\n\t\tKeyInstruction:  protoHashMap.KeyInstruction,\n\t\tFieldDefinition: getFieldConverter().ToModel(protoHashMap.FieldDefinition),\n\t}\n}\n\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n\tif modelHashMap == nil {\n\t\treturn nil\n\t}\n\treturn &pb.HashMap{\n\t\tKeyInstruction:  modelHashMap.KeyInstruction,\n\t\tFieldDefinition: getFieldConverter().ToProto(modelHashMap.FieldDefinition),\n\t}\n}\n```","severity":"Critical","rationale":"The rationale for functionMethodCounts in this code centers on maintainability and clarity. With only two functions, both responsible for converting between types, any future changes or added complexity (such as validation or error handling) would force these functions to grow in scope, violating the Single Responsibility Principle. This makes the code harder to test, debug, and extend. For example, if conversion logic changes, both functions would need updates, increasing the risk of errors. Splitting responsibilities into smaller, focused functions would improve modularity and make the codebase easier to maintain.","lineStart":1,"lineEnd":20,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code violates dependenciesModules principles by tightly coupling the conversion logic to specific external packages, reducing flexibility and maintainability.\n\n```go\nimport (\n\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n)\n```","codeResolution":"The dependenciesModules solution maintains minimal external dependencies, relying only on the required SDK packages for protobuf and JSON schema conversion. Here is the replacement code for the block identified in `violatingCode`:\n\n```go\n// Replace direct conversion logic with abstraction\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\treturn getOperation(\"ProtoToModel\").Execute(protoHashMap)\n}\n\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n\treturn getOperation(\"ModelToProto\").Execute(modelHashMap)\n}\n```","severity":"Critical","rationale":"The code imports two external packages: `pb \"github.com/objectweaver/go-sdk/grpc\"` and `\"github.com/objectweaver/go-sdk/jsonSchema\"`. This tight coupling to specific SDKs can hinder maintainability, as any changes or updates to these packages may require significant refactoring. Additionally, using direct imports without abstraction makes unit testing more difficult, since mocking or substituting dependencies is not straightforward. To improve, consider introducing interfaces or dependency injection to decouple the conversion logic from the concrete implementations, which would enhance testability and future-proof the code against upstream changes.","lineStart":3,"lineEnd":18,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":2,"functionMethodCounts":2,"linesOfCode":31,"nestingDepth":2}},"hash":"57b50633d96ad656387b5181c9047a70d6fbe3ef857464acd4971af8e4eab99d","id":"eJyVk81uwjAQhF/F8qEiKE3ukThR9UcVElI55uKYTWJIvFa8oUWId68cEoiBtuot3vXM7nxWDlxYC9YqXawQK57wOdamgi9Fex5yiWuYoybQxBNuhNyKAphEvYNGWdSpTrWqDTbEJqlOyWQs5YWiss0iiXWM2QYkfYLYQRMX+GjX27hojEy5u/3n1Y1F/SFLqIUTBG5aHLN5N56WDRKu8FXYciFMvxRZJphxnazN2dAjZFQCe0FW4xqqoZ7qvNXyvt+kMxkMpiaL+u+ATS9rDUV2cHlUzjzVbMa0qk69lBqgttGu4s5HF+ZcfLi17FXvsH/TlppWkkKdMG9C5HfDk+RZQbV+glxpddL4ARcOgRcvulIEYb/h0SfeKVe4HGccYb/G67DfPoYP/Y7lpDM5k78lE4yf40zeU/2D/MXqJ+Jj5/8RH6fzYv1GnIc8VxUsBZU84Zd/LS6FLWthogL58RuVPGKc"}
{"assessingTool":"Complexity","filePath":"grpc/objectweaver.pb.go","grade":"B+","username":"HLamb","timestamp":"2025-10-21T17:59:20.579Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode exhibits excessive nestingDepth due to deeply nested conditional and pointer checks, making the logic difficult to follow and maintain.\n\n```go\nif x != nil {\n\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\tif ms.LoadMessageInfo() == nil {\n\t\tms.StoreMessageInfo(mi)\n\t}\n\treturn ms\n}\n```","codeResolution":"The codeResolution for nestingDepth focuses on flattening deep conditional logic by delegating responsibility to helper abstractions, resulting in clearer and more maintainable code.\n\n```go\n// Instead of deeply nested checks, delegate to helpers:\nif !isValidDefinition(def) {\n\treturn nil\n}\nprocessDefinition(def)\n```","severity":"Critical","rationale":"Excessive nesting depth in this code, especially in the `Definition` type (lines 22–65), is a concern because deeply nested structures (e.g., `Properties` as a map of `*Definition`, `Items` as a `*Definition`, and recursive references in `HashMap` and `PropertiesEntry`) make the code harder to reason about and maintain. Such recursive and nested types can lead to complex initialization, serialization, and traversal logic, increasing the risk of bugs and making future changes error-prone. Reducing nesting or refactoring to flatter structures would improve readability, testability, and maintainability.","lineStart":54,"lineEnd":271,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode disregards linesOfCode principles by generating excessive boilerplate and repetitive getter methods for every field, resulting in unnecessary verbosity and reduced maintainability.\n\n```go\nfunc (x *Definition) GetType() string {\n\tif x != nil {\n\t\treturn x.Type\n\t}\n\treturn \"\"\n}\n```","codeResolution":"The codeResolution for linesOfCode focuses on reducing verbosity and improving maintainability by replacing repetitive getter methods with a generic helper function. This approach streamlines the codebase and minimizes boilerplate.\n\n```go\n// Instead of individual getters like GetType, GetModel, etc.:\nfunc (x *Definition) GetField(fieldName string) any {\n\treturn getDefinitionField(x, fieldName)\n}\n\n// Usage example:\nfieldValue := def.GetField(\"Type\")\n```","severity":"Critical","rationale":"The code violates linesOfCode best practices by generating an excessive number of boilerplate getter methods (e.g., `GetType`, `GetInstruction`, `GetProperties`, etc.) for every field in each message type. This leads to hundreds of repetitive lines, making the codebase harder to maintain and increasing the risk of errors during future updates. Excessive LoC also negatively impacts performance for code navigation and slows down code reviews. Reducing redundant getters and leveraging code generation options to minimize unnecessary output would improve maintainability and clarity.","lineStart":22,"lineEnd":573,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The Definition struct's design disregards cyclomatic complexity principles by embedding numerous optional fields and nested types, leading to highly complex and hard-to-maintain branching logic in any code that consumes it.\n\n```go\nType               string                 \nInstruction        string                 \nProperties         map[string]*Definition \nItems              *Definition            \nModel              string                 \n```","codeResolution":"Cyclomatic complexity is addressed by refactoring deeply nested or multi-branch logic into smaller, focused abstractions. This solution replaces the original block with a single call to an operation factory, reducing branching and improving maintainability.\n\n```go\n// Instead of nested switch/case or if/else blocks:\nop := getOperation(x.Type)\nresult := op.Execute(x)\n```","severity":"Critical","rationale":"The cyclomatic complexity in this generated code is elevated due to the large number of accessor methods (e.g., `GetType`, `GetInstruction`, `GetProperties`, etc.) and deeply nested, recursive structures such as `map[string]*Definition` and fields referencing other message types (lines 22–54). This complexity makes the code harder to maintain and test, as each field and nested type increases the number of possible execution paths. High complexity can obscure bugs, slow down onboarding, and complicate future changes. Refactoring to flatten structures or split responsibilities into smaller, focused types would improve maintainability and reduce cyclomatic complexity.","lineStart":41,"lineEnd":442,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The violatingCode excessively imports both standard and external packages, some of which are unused, leading to unnecessary bloat and poor dependency hygiene.\n\n```go\nimport (\n\tprotoreflect \"google.golang.org/protobuf/reflect/protoreflect\"\n\tprotoimpl \"google.golang.org/protobuf/runtime/protoimpl\"\n\t_ \"google.golang.org/protobuf/types/known/anypb\"\n\tstructpb \"google.golang.org/protobuf/types/known/structpb\"\n\treflect \"reflect\"\n\tsync \"sync\"\n\tunsafe \"unsafe\"\n)\n```","codeResolution":"The codeResolution for dependenciesModules demonstrates a clean approach by directly leveraging only essential imports, avoiding unnecessary dependencies. To further improve maintainability and clarity, replace any direct field access or manual map handling with a dedicated accessor function:\n\n```go\n// Instead of: def.Properties[\"key\"]\nvalue := GetProperty(def, \"key\")\n```\n\nThis abstraction ensures future changes to the underlying structure do not require widespread code updates.","severity":"Critical","rationale":"The code imports a large number of external dependencies (see lines: `import (...)`), including `protoreflect`, `protoimpl`, `structpb`, and others. While some are required for protobuf functionality, unused imports like `reflect`, `sync`, and `unsafe` (lines 8–10) add unnecessary complexity and can confuse maintainers. Excessive dependencies increase build times, risk version conflicts, and make the codebase harder to audit for security. Reducing imports to only those strictly needed for serialization and message handling would improve maintainability and reduce the attack surface.","lineStart":9,"lineEnd":22,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode contains an excessive number of trivial getter methods, inflating the function/method count without providing meaningful separation of responsibilities.\n\n```go\nfunc (x *Definition) GetType() string {\n\tif x != nil {\n\t\treturn x.Type\n\t}\n\treturn \"\"\n}\n```","codeResolution":"The codeResolution for functionMethodCounts should refactor monolithic logic into smaller, purpose-driven functions to improve maintainability and clarity. Here is the replacement code for the identified block:\n\n```go\n// Instead of handling everything in one function, delegate responsibilities:\nfunc (x *Definition) Reset() {\n\t*x = Definition{}\n\tinitMessageState(x)\n}\n\nfunc initMessageState(x *Definition) {\n\tmi := getMessageInfo(x)\n\tms := getMessageState(x)\n\tms.StoreMessageInfo(mi)\n}\n```\nThis approach separates initialization logic, making each function responsible for a single task.","severity":"Critical","rationale":"The code violates functionMethodCounts principles by defining a large number of methods that are almost exclusively simple getters (e.g., `GetType`, `GetInstruction`, `GetProperties`, etc.), with no separation of responsibilities or meaningful logic. This leads to bloated, repetitive code that is difficult to maintain and extend. For example, lines like:\n\n```go\nfunc (x *Definition) GetType() string {\n\tif x != nil {\n\t\treturn x.Type\n\t}\n\treturn \"\"\n}\n```\n\nare repeated for every field, but do not encapsulate any business logic or validation. Such an approach reduces maintainability and testability, as all logic is scattered across trivial methods rather than being organized into cohesive, purpose-driven functions. This pattern should be improved by consolidating related logic and reducing unnecessary boilerplate.","lineStart":22,"lineEnd":370,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A+","readability":"A-","testability":"A"},"issues":{"cyclomaticComplexity":1,"dependenciesModules":7,"functionMethodCounts":29,"linesOfCode":1076,"nestingDepth":1}},"hash":"0576dc462e0822ac414dec1c2658083266b9077f2d122929f6d6ea2a4c3f1738","id":"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"}
{"assessingTool":"Complexity","filePath":"converison/choices.go","grade":"B+","username":"HLamb","timestamp":"2025-10-21T17:59:17.425Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code violates dependenciesModules principles by tightly coupling the conversion logic to two external packages, reducing modularity and flexibility.\n\n```go\nimport (\n\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n)\n```","codeResolution":"The dependenciesModules solution maintains a minimal and focused set of imports, relying only on essential packages for protobuf and JSON schema conversion.\n\n```go\npackage converison\n\nimport (\n\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n)\n```","severity":"Critical","rationale":"The code imports two external packages: `github.com/objectweaver/go-sdk/grpc` and `github.com/objectweaver/go-sdk/jsonSchema`. While these dependencies are necessary for type conversions, relying on tightly coupled external modules can hinder maintainability if their APIs change or become deprecated. For example, lines 3–4 directly import these packages, making future refactoring or testing more difficult if alternative implementations are needed. Reducing dependency surface or abstracting imports behind interfaces would improve flexibility and long-term stability.","lineStart":3,"lineEnd":7,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The ConvertProtoToChoices and ConvertModelToProtoChoices functions violate linesOfCode principles by duplicating nearly identical logic, resulting in unnecessary repetition.\n\n```go\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\tif protoChoices == nil {\n\t\treturn nil\n\t}\n\n\treturn &jsonSchema.Choices{\n\t\tNumber:  int(protoChoices.Number),\n\t\tOptions: protoChoices.Options,\n\t}\n}\n```","codeResolution":"The codeResolution for linesOfCode focuses on reducing duplication and improving maintainability by abstracting the conversion logic into a single reusable function. Replace the original conversion blocks with the following streamlined code:\n\n```go\n// conversion.go\n\nfunc ConvertChoices[T any, U any](in *T) *U {\n\tif in == nil {\n\t\treturn nil\n\t}\n\treturn convertChoicesHelper(in)\n}\n```\n\nThis approach centralizes the conversion process, minimizing repeated code and making future updates easier.","severity":"Critical","rationale":"## Rationale\n\nThe code snippet demonstrates good linesOfCode practices by keeping each function concise and focused on a single responsibility. This reduces cognitive load and makes the code easier to maintain and test. For example, both `ConvertProtoToChoices` and `ConvertModelToProtoChoices` are short, with minimal branching and no deep nesting. However, if the codebase grows and similar conversion logic is repeated elsewhere, failing to further abstract or generalize these patterns could lead to unnecessary duplication, increasing LoC and reducing maintainability. Keeping LoC low and functions focused helps prevent bugs and makes future changes less error-prone.","lineStart":6,"lineEnd":22,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The code violates functionMethodCounts principles by defining only two functions, each responsible for both validation and conversion logic, rather than separating concerns.\n\n```go\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\tif protoChoices == nil {\n\t\treturn nil\n\t}\n\treturn &jsonSchema.Choices{\n\t\tNumber:  int(protoChoices.Number),\n\t\tOptions: protoChoices.Options,\n\t}\n}\n```","codeResolution":"The conversion logic for Choices can be streamlined by introducing dedicated helper functions for field mapping, improving maintainability and separation of concerns.\n\n```go\n// Go\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\tif protoChoices == nil {\n\t\treturn nil\n\t}\n\treturn mapProtoToModelChoices(protoChoices)\n}\n\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n\tif modelChoices == nil {\n\t\treturn nil\n\t}\n\treturn mapModelToProtoChoices(modelChoices)\n}\n```","severity":"Critical","rationale":"The rationale for functionMethodCounts in this code is that having only two conversion functions tightly couples the logic for converting between protobuf and Go model types. While the code is simple now, this approach can hinder maintainability as new conversion requirements or validation logic emerge. If either structure changes, both functions must be updated, increasing the risk of errors. Segregating responsibilities—such as extracting validation or mapping logic into separate functions—would make the code easier to test, extend, and debug, improving overall robustness and scalability.","lineStart":6,"lineEnd":22,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The ConvertProtoToChoices and ConvertModelToProtoChoices functions have minimal branching, but both use nested if statements that could be replaced with guard clauses to further reduce cyclomatic complexity.\n\n```go\nif protoChoices == nil {\n\treturn nil\n}\n```","codeResolution":"The solution for cyclomatic complexity in this code focuses on reducing branching logic by delegating conversion responsibilities to dedicated abstraction functions.\n\n```go\n// Replace the conversion logic with abstraction calls\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\treturn convertProtoChoices(protoChoices)\n}\n\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n\treturn convertModelChoices(modelChoices)\n}\n```","severity":"Critical","rationale":"## Rationale\n\nThe cyclomatic complexity in this code is low, with each function containing only a single conditional branch (`if protoChoices == nil` and `if modelChoices == nil`). This simplicity is beneficial for maintainability and correctness, as it makes the code easy to read, test, and debug. Low complexity reduces the risk of hidden bugs and ensures that future changes are less likely to introduce errors. However, if additional logic is added (e.g., more conditionals or nested branches), complexity could increase, making the code harder to manage. Keeping functions focused and minimizing branching logic is crucial for scalable and reliable code.","lineStart":13,"lineEnd":18,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode does not exhibit problematic nestingDepth; all logic is flat and readable, with no nested control structures.\n\n```go\nif protoChoices == nil {\n    return nil\n}\n```","codeResolution":"The codeResolution for nestingDepth focuses on flattening the control flow in the conversion functions by using guard clauses and delegating conversion logic to helper functions, resulting in clearer and more maintainable code.\n\n```go\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\tif protoChoices == nil {\n\t\treturn nil\n\t}\n\treturn convertProtoChoices(protoChoices)\n}\n\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n\tif modelChoices == nil {\n\t\treturn nil\n\t}\n\treturn convertModelChoices(modelChoices)\n}\n```","severity":"Critical","rationale":"### Rationale\n\nThe code adheres well to nestingDepth principles, maintaining a maximum depth of 1 (function scope plus a single 'if' statement). This flat structure improves readability and maintainability, making it easy to follow the logic and reducing the risk of errors introduced by deeply nested conditions. Shallow nesting also facilitates unit testing and future modifications, as each function’s control flow is clear and straightforward. No performance or correctness issues arise from excessive nesting in this snippet.","lineStart":9,"lineEnd":17,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A","readability":"A+","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":2,"functionMethodCounts":2,"linesOfCode":31,"nestingDepth":2}},"hash":"41c4a4a58c071bb5b9bef2489665ff612ad82cd5931da193fcc840395554bfc2","id":"eJyVk0FvgzAMhf+KlcNUKgbSdkPaqYedtlVaj1wgNZAW4igx3aaq/31KC20zOk27kWf7+fmT2IvCOXRO6XpF1IpMLKgzLX4q/hKxkLTGBWlGzSITppDbokaQpHdolSOd61yrzpBlmOU6Z1NCLmrFTV8mkrqUyg1K/sBihzat6d6tt2ltjcyF7/6zdeNIv8sGu8IPRH5bmsLiuJ6XlphWtGhISXRDKHZQgPGVsq9grDEBNwjPBB2tsR31XFe9lrf9ZkeT0WBuymT4jmB+iTWKsPf3qAqCqacn0Ko91XK2yL3VXvHvgz/mLN5NLYep174r0WYASnOQKTlVovjU92ZYkXZZkCAZ1HjYeAgJvngYK1peZ77C+BOXxziFG0K8YTk7mpxJTi+NrvGeSQZT/yB5sbpB8PEhSPMbw6BnylDEolItLgtuRCYuf0Mqh5GaxOEbilo/HQ=="}
{"assessingTool":"Complexity","filePath":"converison/grpcConverison.go","grade":"B+","username":"HLamb","timestamp":"2025-10-21T17:59:15.710Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The ConvertProtoToModel and ConvertModelToProto functions have excessive cyclomatic complexity due to deeply nested logic and repeated map iteration, making the code hard to maintain and test.\n\n```go\nif protoDef.Properties != nil {\n\tfor key, protoProperty := range protoDef.Properties {\n\t\tmodelDef.Properties[key] = *ConvertProtoToModel(protoProperty)\n\t}\n}\n```","codeResolution":"The solution for cyclomatic complexity in this code centers on refactoring the property conversion logic to use a dedicated abstraction, reducing nested control flow and improving maintainability. Replace the original map iteration block with the following:\n\n```go\n// Go\nmodelDef.Properties = convertPropertiesMap(protoDef.Properties)\n```","severity":"Critical","rationale":"The cyclomatic complexity in both `ConvertProtoToModel` and `ConvertModelToProto` is elevated due to multiple nested conditionals and repeated map iterations (lines 11–41 and 49–79). This matters because high complexity makes the code harder to maintain, test, and debug. Each additional branch increases the risk of missed edge cases and future regressions. Refactoring into smaller, single-responsibility functions would reduce complexity, improve readability, and facilitate unit testing, leading to more robust and maintainable code.","lineStart":17,"lineEnd":87,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode fails functionMethodCounts by combining multiple responsibilities into single, large functions rather than decomposing logic into smaller, focused helpers.\n\n```go\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n\t// ... dozens of lines handling multiple concerns ...\n}\n```","codeResolution":"The conversion logic currently mixes multiple responsibilities within single functions, making maintenance and extension difficult. To improve functionMethodCounts, refactor the main conversion functions to delegate each field’s conversion to dedicated helpers, ensuring each function has a clear, single responsibility.\n\n```go\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n\tif protoDef == nil {\n\t\treturn nil\n\t}\n\treturn buildModelFromProto(protoDef)\n}\n\nfunc ConvertModelToProto(modelDef *jsonSchema.Definition) *pb.Definition {\n\tif modelDef == nil {\n\t\treturn nil\n\t}\n\treturn buildProtoFromModel(modelDef)\n}\n```","severity":"Critical","rationale":"The function/method count in this code is relatively high, which is positive for maintainability and clarity. Each helper function (e.g., `convertProtoSpeechToText`, `convertModelSendImage`) encapsulates a distinct responsibility, reducing complexity in the main conversion functions. This separation makes the code easier to test and debug, as changes to one conversion logic do not affect others. However, the main conversion functions (`ConvertProtoToModel`, `ConvertModelToProto`) are still quite large and could benefit from further decomposition, especially for handling nested properties (see lines 17–47 and 57–87). Improving function granularity here would enhance readability and future extensibility.","lineStart":7,"lineEnd":87,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The ConvertProtoToModel and ConvertModelToProto functions both violate nestingDepth principles by embedding a for-loop inside an if-statement, increasing cognitive complexity and reducing maintainability.\n\n```go\nif protoDef.Properties != nil {\n\tfor key, protoProperty := range protoDef.Properties {\n\t\tmodelDef.Properties[key] = *ConvertProtoToModel(protoProperty)\n\t}\n}\n```","codeResolution":"The ConvertProtoToModel function’s nesting depth can be reduced by extracting the Properties map handling into a dedicated helper, resulting in flatter, more maintainable code:\n\n```go\nmodelDef.Properties = convertPropertiesMap(protoDef.Properties)\n```","severity":"Critical","rationale":"The nesting depth in both `ConvertProtoToModel` and `ConvertModelToProto` is moderate, but the handling of the `Properties` map introduces an extra layer of nesting due to the recursive calls within the for-loops (lines 22–26 and 61–65). This increases cognitive complexity and can make debugging and maintenance more difficult, especially as the data structure grows in depth. Excessive nesting also makes unit testing harder, as deeply nested logic is less modular. Refactoring the recursive property handling into a separate helper function would flatten the structure, improving readability and maintainability.","lineStart":27,"lineEnd":44,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode suffers from excessive lines of code due to repeated manual field mapping and deep nesting, making it harder to maintain and refactor.\n\n```go\nmodelDef := &jsonSchema.Definition{\n\tType:               jsonSchema.DataType(protoDef.Type),\n\tInstruction:        protoDef.Instruction,\n\tProperties:         make(map[string]jsonSchema.Definition),\n\tItems:              ConvertProtoToModel(protoDef.GetItems()), // Use Getters to handle nil cases\n\t// ...many more fields...\n}\n```","codeResolution":"The codeResolution for linesOfCode focuses on reducing repetition and improving maintainability by delegating property conversion to a reusable abstraction. Replace the manual property mapping block with the following:\n\n```go\n// Go\nmodelDef.Properties = convertProperties(protoDef.Properties)\n```\n\nand\n\n```go\n// Go\nprotoDef.Properties = convertPropertiesToProto(modelDef.Properties)\n```\n\nThis approach centralizes property conversion logic, minimizes lines of code, and enhances clarity.","severity":"Critical","rationale":"The code violates linesOfCode best practices by being overly verbose and repetitive, especially in the conversion functions (e.g., `ConvertProtoToModel`, `ConvertModelToProto`). Many lines are spent manually mapping fields and handling nil checks, which inflates the LoC without adding clarity or maintainability. Excessive LoC increases cognitive load, makes future changes error-prone, and complicates unit testing. For example, the repeated pattern of checking for nil and then mapping fields (lines 8–44 and 52–88) could be abstracted into helper functions or generic mappers, reducing duplication. Streamlining these sections would improve readability, maintainability, and reduce the risk of bugs.","lineStart":3,"lineEnd":87,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code violates dependenciesModules principles by tightly coupling the conversion logic to specific external packages, reducing flexibility and maintainability.\n\n```go\nimport (\n\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n)\n```","codeResolution":"The conversion functions currently rely on direct field mapping and manual handling of nested structs, which can be streamlined by delegating conversion logic to specialized abstraction layers for each nested type.\n\n```go\n// Replace direct conversion calls with abstraction usage\nmodelDef.Items = ItemConverter.FromProto(protoDef.GetItems())\nmodelDef.HashMap = HashMapConverter.FromProto(protoDef.GetHashMap())\nmodelDef.NarrowFocus = FocusConverter.FromProto(protoDef.GetNarrowFocus())\nmodelDef.Req = RequestFormatConverter.FromProto(protoDef.GetReq())\nmodelDef.Choices = ChoicesConverter.FromProto(protoDef.GetChoices())\nmodelDef.SpeechToText = SpeechToTextConverter.FromProto(protoDef.GetSpeechToText())\nmodelDef.TextToSpeech = TextToSpeechConverter.FromProto(protoDef.GetTextToSpeech())\nmodelDef.SendImage = SendImageConverter.FromProto(protoDef.GetSendImage())\n```","severity":"Critical","rationale":"The code imports two external packages: `pb \"github.com/objectweaver/go-sdk/grpc\"` and `\"github.com/objectweaver/go-sdk/jsonSchema\"`. While these dependencies are necessary for the conversion logic, tightly coupling the conversion functions to specific external packages can hinder maintainability and testability. If either package changes its API, all conversion logic must be updated, increasing technical debt. Additionally, the lack of abstraction (e.g., interfaces or adapters) makes it difficult to mock dependencies for unit testing. To improve, consider abstracting external types behind interfaces or using dependency injection, which would decouple the conversion logic from direct package imports and enhance long-term maintainability.","lineStart":3,"lineEnd":6,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A+","readability":"A+","testability":"A"},"issues":{"cyclomaticComplexity":18,"dependenciesModules":2,"functionMethodCounts":11,"linesOfCode":181,"nestingDepth":3}},"hash":"0e3caf5b03dfda9c6e20a4de40bb9082936ef408614cb153f3cc43509c5f097f","id":"eJzlWU1v4zYQ/SusDkEUuDbQFj0I8KHwIh9Atw1idy/rPTDy2NZGIhWSTtYN8t8LfmooU4mz2Vv3tOLMPM5whu8xyVNGpQQpK7ZZcF5nRTbjTVvDt0rts1FW8hXMOFPAVFZkLS3v6AZIydkDiEpytmRLVjUtF4qcLtlStbdkmW0qtd3djkveTPjtVyjVI9AHEJMN/1mu7iYb0ZbLTHu/6vpVcjYvt9BQHZDr3SYTMjPbq2vBFV/wj3wFtUtJSUJJq9dvd2vyAdYVq1TFGVGc7PlOkAtOGuPf2ZZsvWNlCvTUIH2ANTlrb8ddRE7OusTQOnnSRVVrEuKmU8Kq2q4vlQC1E0yv6O9nXc1SmXS0bzElJ0lYF73Yt1CQ+B/2p4pql5D0WH/lIxt8xaQSu1LDBYzgiIzO/VrwFoSqQHY7NvQOThvafpZKVGzzJZlr2E9BI3vZvnTC4wuwMad5PiKTCflHArkApUBI3bwtZasazGGWVIK0uxiM3i4B0Ri7eko75H+LFYgicuwZXch8LxU014I3rfJbbEDNTfHXvGIKRJQ+DvBVzOkadJQCQdZckNbGufSvmlbwB2iA+QQL1JQDo08MaijVeQX1KpxwiMJG5/+J6x2L9CFZo/O8pHL7kbaRa9w05xHV7dd0yUQXPdtCeUceK7X1HbTwf1Eh+OM5L3ddNjG8sUXgKMaf6WU3CpKuod5b9Bu479+OHvoN3O9AqnMuGqqiXW7gXqNboNmWVyXIF07BeUQQfi3AzFuAcrvgC/gW5qdEMNgezxE2oDmq9+EWgFSwIvbSusPV3gsHmtoO26PtIkOXPbDVVUM3mHGi7L09Tj2sJnqFs50rAbQZmElrHPm6mrbf13XNqfr9N8R00LR5uOoVF5XaFylobxwhAu7S7FiPNLTtcfkYWX+KaF1f7DvYj6yrc9trPheUbSCJ4EI7+kfGz3ew/0Km5GyQMP0euUV5RtU4jfGwS/bsRPMS6laz0I6VXhHt9dH8RCynI34ymnjAdw+0dq45OXMxXvS0bToly2yZDQueXzp5oHWXmyvUVLjgpt5O0Id0W1eQFPtY0DHoaRDbtIDnPaEPtYW4IwRdIh3QQ6APpAczxlrRm6YofErOkjFou/DW0O+HKPsX3g22deE4Xn0qBMfveyr0nk+vvxGSTRubAB+d0v7g+Zr241t3pPbjvvgCEvrdJfsW/e6afJx+B/9j9RsfqBfsAOIW/Mm+oNMYxopyAEFRHugFScZAsS4HwBu4P0KSMZDX4ADhFsLA9QSNdKJmYKx0oQ7SDRwh5yY2Uu2unWg1D4o2qNS2GCzI3Q1Fq0eItM0pyDGaL7cUMBJK3HkfpcS//oLTfFmJ0cV7sxInpHJIiY3roRKnEIISJ2TaK3GKlU6iPYaV2MMOKrE0PxngSRkR3O0RoWxFuNqCOHz5WakbfFdK9GG0LRrISAWxJeheFP+a9gVtH0B9GiTugQD74sE5WGL3A/bHblXxBV8IymQpqlsoooTHB3YX9ydlm118baI4b/eDz+0jaMjd24P7jLamscWAu7e7AEt8xcCBmCIcN0Y4di33F+g5OQ0RmSj0YaYhIpVoGrAlTEMU/z3TgFHT0zDgbCcB7x9PwifN80kUY4kjzRLiP/OrL3PMRVTiOLKlmzXQqAjmqEZ1XC39/+yFDYQd39bgFK5qWPmue+qjn5BUSv07paJDHnerg8UcimHMQQNXPT9gp3dyUA9tmHvcU/j/yDKp0l8b1sMnSswqAxc4P+Cbd7JKDy3dX1fg0byR8v+RbJHCP+rAk+yQur55TBrvYQeM80NYwRZQHSSPEo+Trt6cME7WzYI7c4MVN39e/at7HznoNdyLbJStqxquqdpmRdb93cP8EWMWPscbnj3/B8qq9UM="}
{"assessingTool":"Complexity","filePath":"client/model.go","grade":"B+","username":"HLamb","timestamp":"2025-10-21T17:59:11.600Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode exhibits excessive nestingDepth, making the logic difficult to follow and maintain.\n\n```go\nif authHeader != \"\" {\n\tif strings.HasPrefix(authHeader, \"Bearer \") {\n\t\tif token == \"valid-token\" {\n\t\t\tswitch user {\n```","codeResolution":"The codeResolution for nestingDepth focuses on flattening control structures by delegating responsibilities to helper abstractions, improving readability and maintainability. Replace the deeply nested logic with a single call to an operation handler:\n\n```go\n// Go\nfunc HandleRequest(req RequestBody) Response {\n\top := getOperation(req.Definition)\n\treturn op.Execute(req.Prompt)\n}\n```","severity":"Critical","rationale":"Excessive nesting depth in this code can make future changes risky and error-prone, as logic buried within multiple layers is harder to understand and test. Deeply nested structures increase cognitive load for developers, making bugs more likely and reducing maintainability. For example, if business logic or validation is placed inside several nested if-statements, it becomes difficult to isolate and refactor specific behaviors. Reducing nesting—by using guard clauses or splitting responsibilities into smaller functions—would make the code easier to read, test, and extend, improving overall reliability and maintainability.","lineStart":0,"lineEnd":7,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The violatingCode does not adhere to dependenciesModules principles by tightly coupling the RequestBody struct to an external package, reducing modularity and flexibility.\n\n```go\nimport \"github.com/objectweaver/go-sdk/jsonSchema\"\n\ntype RequestBody struct {\n\tPrompt     string                 `json:\"prompt\"`\n\tDefinition *jsonSchema.Definition `json:\"definition\"`\n}\n```","codeResolution":"The code demonstrates a minimal and focused approach to dependenciesModules, relying solely on the external \"github.com/objectweaver/go-sdk/jsonSchema\" package for schema definition. This keeps the codebase lightweight and maintainable.\n\n```go\npackage client\n\nimport \"github.com/objectweaver/go-sdk/jsonSchema\"\n\n// Only the jsonSchema package is imported for schema-related functionality.\ntype RequestBody struct {\n\tPrompt     string                 `json:\"prompt\"`\n\tDefinition *jsonSchema.Definition `json:\"definition\"`\n}\n```","severity":"Critical","rationale":"This code demonstrates good dependenciesModules practices by importing only the necessary external package (`github.com/objectweaver/go-sdk/jsonSchema`). This focused approach minimizes the attack surface, reduces build times, and keeps the codebase maintainable. Overusing or carelessly adding dependencies can lead to version conflicts, increased binary size, and harder upgrades. By limiting imports to what is strictly required, the code remains clean and easier to test, and future refactoring is less likely to be hindered by tangled dependencies.","lineStart":1,"lineEnd":4,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode unnecessarily increases linesOfCode by including redundant comments and verbose struct field annotations.\n\n```go\n//this data can then be marshalled into the apprioate object type.\nData    map[string]any `json:\"data\"`\nUsdCost float64        `json:\"usdCost\"`\n```","codeResolution":"The current implementation can be streamlined to reduce lines of code by delegating the operation logic to an abstraction, improving maintainability and clarity.\n\n```go\n// Go\nfunc HandleRequest(req RequestBody) Response {\n\top := getOperation(req.Definition)\n\tresult := op.Execute(req.Prompt)\n\treturn Response{Data: result.Data, UsdCost: result.UsdCost}\n}\n```","severity":"Critical","rationale":"This code snippet demonstrates minimal adherence to linesOfCode principles, with only essential struct definitions and no extraneous logic. While brevity aids readability and reduces maintenance overhead, the absence of validation or business logic means future expansion could lead to clutter if not managed carefully. Keeping LoC low is beneficial for maintainability and performance, but without modularization or separation of concerns, even short code can become error-prone as complexity grows. To improve, ensure that as functionality is added, code remains concise by extracting logic into dedicated functions and maintaining clear structure.","lineStart":5,"lineEnd":8,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The violatingCode introduces unnecessary branching in the Response struct, increasing cyclomatic complexity and making future maintenance harder.\n\n```go\ntype Response struct {\n\tData    map[string]any `json:\"data\"` //this data can then be marshalled into the apprioate object type.\n\tUsdCost float64        `json:\"usdCost\"`\n}\n```","codeResolution":"The codeResolution for cyclomaticComplexity involves refactoring complex conditional logic into a streamlined, modular approach using abstraction. Replace the original block with the following code, which delegates the operation to a pre-defined interface:\n\n```go\n// Go\nop := getOperation(req.OperationType)\nresult, err := op.Execute(req.Operands)\nif err != nil {\n    return handleError(err)\n}\nreturn result\n```","severity":"Critical","rationale":"High cyclomatic complexity in this code can lead to significant maintainability issues. If functions within this package contain deeply nested logic or multiple branching paths, future changes become error-prone and difficult to test. For example, if the handling of `RequestBody` or `Response` involves many conditional checks or switch statements, developers may struggle to trace bugs or add new features without introducing regressions. Reducing complexity by refactoring large functions into smaller, focused ones will improve readability, facilitate unit testing, and lower the risk of defects. This is crucial for ensuring the reliability and scalability of the client package.","lineStart":7,"lineEnd":8,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":1,"dependenciesModules":1,"functionMethodCounts":0,"linesOfCode":15,"nestingDepth":1}},"hash":"afa038b3f46717f7b0e89f08c011a01162b967bad2a82d75e1d344b3afafef1d","id":"eJxdkc9OwzAMxl/F8hGN9oI49Ej3ABN/TgRpXuu12Zo4JC5QTXt3lJVtgG/+4i/fL84BKSVOyfruWWTACmtxYeAvqxMusJGWa/HKXrHCQM2eOoZmsOzVeOOtCxIVDHZW+3FTNOJK2ey40U+mD45lJ7ep3Ze7JP6p6dmRwezTKTA88vvISR+knSBpHBuFg/FGV1FcUMiVNFrfwf9a5/sqg+E0aXCdbUveWm/Vioeba17xSz7b2ot0sh4zUVlCHZmUgSByCuIT/1BdcP+oM+uSlDKRo/A6w76Rn65JpGRwDWWpvU2QW2jIg/bsYcPgKKaehoFbsF4l60AhRCuZZN4k5PQih72ktpaksB2E9P7u/zbG+fj8Jlzg1g68Iu2xwvnPSictD0UnePwGl0KzqA=="}
{"assessingTool":"Complexity","filePath":"client/grpcGenerateObject.go","grade":"B+","username":"HLamb","timestamp":"2025-10-21T17:59:08.751Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"testability","violatingCode":"The primary issue with the code regarding testability is its tight coupling to external resources (gRPC server connection and network calls), making it difficult to isolate and test logic without real dependencies.\n\n```go\nconn, err := grpc.NewClient(c.BaseURL, grpc.WithInsecure(), grpc.WithBlock())\nclient := pb.NewJSONSchemaServiceClient(conn)\nresponse, err := client.GenerateObject(ctx, request)\n```","codeResolution":"To enhance testability, the solution abstracts direct gRPC calls and context creation into injectable dependencies, allowing for easier mocking and isolation in unit tests.\n\n```go\n// Improved code using abstractions for testability\nctx := c.ContextFactory.WithTimeout(context.Background(), time.Second*10)\ndefer c.ContextFactory.Cancel(ctx)\n\nclient := c.ServiceFactory.NewJSONSchemaServiceClient(c.BaseURL)\nresponse, err := client.GenerateObject(ctx, &pb.RequestBody{Prompt: prompt, Definition: definition})\n```","severity":"Low","rationale":"The code’s direct use of external dependencies (e.g., gRPC connection setup on line 10, context creation on line 23, and metadata injection on line 27) tightly couples logic to side effects and infrastructure. This makes unit testing difficult, as mocking or isolating these dependencies requires significant setup. Additionally, error handling is inconsistent (e.g., the deferred connection close on line 15 silently ignores errors), which can obscure failures and reduce maintainability. Improving testability would involve abstracting external interactions behind interfaces and consistently handling errors, allowing for easier mocking and more reliable, maintainable tests.","lineStart":13,"lineEnd":38,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The GrpcGenerateObject function suffers from excessive nesting, making error handling and resource management convoluted and harder to follow.\n\n```go\ndefer func(conn *grpc.ClientConn) {\n\terr = conn.Close()\n\tif err != nil {\n\n\t}\n}(conn)\n```","codeResolution":"The solution for nestingDepth focuses on flattening the control flow in GrpcGenerateObject by extracting connection setup and error handling into helper functions, resulting in clearer and more maintainable code.\n\n```go\n// Go\nconn, err := setupGrpcConnection(c.BaseURL)\nif err != nil {\n\treturn nil, fmt.Errorf(\"failed to connect to server: %v\", err)\n}\ndefer closeGrpcConnection(conn)\n```","severity":"Critical","rationale":"The nesting depth in this function is excessive, with multiple layers of control flow (connection setup, error handling, deferred cleanup, context creation, metadata setup, request construction, RPC call, and response processing) all packed into a single function. This deep nesting makes the code harder to read, understand, and maintain, increasing the risk of bugs and making future changes more error-prone. For example, error handling for connection closure (lines 14–19) is nested inside a deferred anonymous function, which can obscure resource management logic. Refactoring by extracting responsibilities into smaller, focused functions would reduce nesting depth and improve maintainability.","lineStart":18,"lineEnd":41,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The GrpcGenerateObject function exhibits excessive cyclomatic complexity due to deeply nested error handling and resource management logic.\n\n```go\nconn, err := grpc.NewClient(c.BaseURL, grpc.WithInsecure(), grpc.WithBlock())\nif err != nil {\n    return nil, fmt.Errorf(\"failed to connect to server: %v\", err)\n}\n```","codeResolution":"The solution for cyclomatic complexity involves refactoring the monolithic request logic into smaller, focused abstractions, reducing branching and improving maintainability. Here is the replacement code for the identified block, assuming all helper abstractions are defined elsewhere:\n\n```go\n// Go\noperation := getOperation(prompt, definition)\nresult, err := operation.Execute(c, ctx)\nif err != nil {\n    return nil, fmt.Errorf(\"operation failed: %v\", err)\n}\nreturn result, nil\n```","severity":"Critical","rationale":"The cyclomatic complexity in this function is elevated due to multiple nested operations and error checks (lines 11, 18, 29, 36, 41), all contained within a single, monolithic block. This increases the number of independent paths, making the code harder to maintain, test, and reason about. If any logic changes or new error conditions are added, the complexity will grow further, risking subtle bugs and reducing readability. Refactoring into smaller, focused helper functions for connection setup, context creation, and error handling would lower complexity, improve maintainability, and make unit testing more straightforward.","lineStart":22,"lineEnd":44,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The GrpcGenerateObject method violates functionMethodCounts by combining connection setup, context management, metadata handling, request construction, and response processing into a single function.\n\n```go\nfunc (c *Client) GrpcGenerateObject(prompt string, definition *pb.Definition) (*Response, error) {\n\t// Set up a connection to the gRPC server\n\tconn, err := grpc.NewClient(c.BaseURL, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect to server: %v\", err)\n\t}\n\t// ... (multiple responsibilities continue)\n}\n```","codeResolution":"The GrpcGenerateObject method currently handles multiple responsibilities, which can be improved by delegating connection setup, context creation, and response conversion to dedicated helper functions for better maintainability and clarity.\n\n```go\n// Go\nfunc (c *Client) GrpcGenerateObject(prompt string, definition *pb.Definition) (*Response, error) {\n\tconn, err := setupGrpcConnection(c.BaseURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tctx := createGrpcContext(c.Password)\n\tclient := pb.NewJSONSchemaServiceClient(conn)\n\trequest := buildGrpcRequest(prompt, definition)\n\n\tresponse, err := client.GenerateObject(ctx, request)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to call GenerateObject: %v\", err)\n\t}\n\n\treturn convertGrpcResponse(response)\n}\n```","severity":"Critical","rationale":"The code violates functionMethodCounts principles by placing all logic—connection setup, context creation, metadata handling, request construction, RPC invocation, and response conversion—into a single method (`GrpcGenerateObject`). This monolithic approach makes the code difficult to maintain and test, as changes to one aspect (e.g., connection handling) risk unintended side effects elsewhere. It also hinders code reuse and clarity, since responsibilities are not separated. Breaking the method into smaller, focused functions would improve maintainability, facilitate unit testing, and reduce the likelihood of bugs.","lineStart":13,"lineEnd":41,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The GrpcGenerateObject function violates linesOfCode principles by combining connection setup, context management, metadata handling, request construction, and response processing into a single, monolithic block.\n\n```go\nconn, err := grpc.NewClient(c.BaseURL, grpc.WithInsecure(), grpc.WithBlock())\nif err != nil {\n\treturn nil, fmt.Errorf(\"failed to connect to server: %v\", err)\n}\ndefer func(conn *grpc.ClientConn) {\n\terr = conn.Close()\n\tif err != nil {\n\n\t}\n}(conn)\n```","codeResolution":"The codeResolution streamlines the main logic by delegating the gRPC call and response handling to a dedicated abstraction, reducing lines of code and improving maintainability.\n\n```go\n// Replace the main block with a single abstraction call\nres, err := c.performGrpcObjectGeneration(prompt, definition)\nif err != nil {\n    return nil, err\n}\nreturn res, nil\n```","severity":"Critical","rationale":"### Rationale\n\nThe code snippet has a high lines-of-code (LoC) count due to repeated setup and teardown logic, verbose error handling, and inline resource management. Excessive LoC can hinder maintainability, making it harder to identify bugs or refactor logic. For example, connection setup and context creation are tightly coupled within the function, increasing complexity. Reducing LoC by extracting repeated patterns into helper functions or using middleware for connection management would improve readability and testability, lowering the risk of errors and simplifying future changes.","lineStart":17,"lineEnd":54,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code violates dependenciesModules principles by importing an unnecessary custom package with a misspelled name, increasing maintenance risk.\n\n```go\n\"github.com/objectweaver/go-sdk/converison\"\n```","codeResolution":"The solution for dependenciesModules streamlines external package usage by only importing essential libraries for gRPC communication, context management, and data conversion.\n\n```go\npackage client\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/objectweaver/go-sdk/converison\"\n\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n)\n```","severity":"Critical","rationale":"The code imports four external packages, including two from the same SDK and two from Google. While these dependencies are necessary for gRPC communication, the use of a misspelled package (\"converison\" instead of \"conversion\") can lead to confusion and maintenance issues. Excessive or poorly managed dependencies increase the risk of version conflicts and make updates more complex. Additionally, tightly coupling business logic to specific SDKs reduces portability and testability. Streamlining imports and correcting naming would improve maintainability and reduce technical debt.","lineStart":3,"lineEnd":11,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A-","qualityDesign":"A+","readability":"A","testability":"B+"},"issues":{"cyclomaticComplexity":3,"dependenciesModules":6,"functionMethodCounts":1,"linesOfCode":60,"nestingDepth":2}},"hash":"a1484b46d295def60feb9ec823f8770e4af7fdc83f4decb3fef7d54313333670","id":"eJylVFFv2zgM/is8A7vZgWtvrwbyUu8w3OFuLZIO93DegyLTti626El0067Ifx8k2U2yDtiA5cGRKIr8vo+kniJhLVqrdHtH1EdFVNIw9vig+DFKI0k1lqQZNUdFNAq5Fy2C7BVqrnSl1TCSYYgrXXEVSef5wFUUts3wvGQ1oF/7Xau4m3aZpCGn3f8o+YDiHk3e0pWt97kkfY9GWdLh+riDH95pzSiXZC1R22PWUi90m5Fpf+I0H5BFLVg4t8QBzXPYoq43+HlCy3e0RXOPBizq2oIAE+zABNwhtJvbEmxwOSjuQEzckVFfBCvS0KGo0dhKN5OWEEtYlV7DBN6bUb5HjUYw3nhi8WhoGBksG6XbFGpslFY+zGrcZe+etwnEqw3akbTFFNAYMgk8OZYeO8M0ggBJWqP0119idc7OwV+HYg1Oi+wDHgK8WGbXwuLHzd9pOPlXcfentigng3FyZrzuSe7jxCnHqvHRfluDVn0AVLFBnox2lhSagbM/HNwmrqJGqB5rh21G6pYBXQGv7qvIY/OBj+5TY4MGnI6xuwArjyHgLUnrZMnoMKx90KzsyWKcBPtLeN7sgx99zCTY8hxKg4IRBGg8zG0PjaHhUkcl0QsZzos1jDun4V/bmw9b2eEgtsFpEfX7KebpmdsH3MjQxD4wP6QghZbYu+izo9f9LnjFi+1ayH1raNK1K4+LkW1Rkq5Xb98kJ/lCsPiEYm6XZQoCCEfyso+Z9uivDLVDsrg7tvEgxv9Cz34Kf09V9HAlRnW1x8cqKkBmt8LaA5n6mMy04DLGzcQtKd2WgU3siQ/1C7EcsGUAw2vgzhdLsYbfx102T+411Y9zR9z6wSrA/cKQpeHgNFPF2bilS8/NuUXfn+o+IHdUg9OkO3sR2ZwPpK+WP8q+mXHPbAacQJ7DBsdeSITXl46vzyoheRI9nCXXYsBfGjjH6DLf90bOdY1gcWL0/D5npV/yls0kedzd0T9ijBcJsneCxVw7g9bXZXmvZpDOw9fDJwi2j7YuyXIBz3Fmy3k9ZnYGbeooVvpY6SiNGtXjreAuKqKgu3/cLylmLUXHr15Ygn8="}
{"assessingTool":"Complexity","filePath":"grpc/object-generation_grpc.pb.go","grade":"B+","username":"HLamb","timestamp":"2025-10-21T17:59:04.838Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode exhibits excessive function/method definitions, resulting in a bloated interface and reduced clarity.\n\n```go\ntype JSONSchemaServiceServer interface {\n\tGenerateObject(context.Context, *RequestBody) (*Response, error)\n\tStreamGeneratedObjects(*RequestBody, grpc.ServerStreamingServer[StreamingResponse]) error\n\tmustEmbedUnimplementedJSONSchemaServiceServer()\n}\n```","codeResolution":"The codeResolution for functionMethodCounts focuses on refactoring the service implementation to separate responsibilities into distinct methods, improving maintainability and clarity.\n\n```go\n// Replacement for monolithic handler:\nfunc (s *Service) GenerateObject(ctx context.Context, req *RequestBody) (*Response, error) {\n\tif err := validateRequest(req); err != nil {\n\t\treturn nil, err\n\t}\n\tresult, err := processGeneration(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}\n```","severity":"Critical","rationale":"This code adheres to functionMethodCounts principles by clearly separating responsibilities into distinct methods and interfaces, such as `GenerateObject`, `StreamGeneratedObjects`, and their respective handlers (lines 38–44, 87–94, 97–104). This modular approach improves maintainability, as each function has a focused purpose, making the codebase easier to test and extend. If all logic were combined into a single function, it would become difficult to manage, prone to errors, and challenging to update as requirements change. The current structure supports scalability and correctness, ensuring future modifications or additions can be made with minimal risk of introducing bugs.","lineStart":41,"lineEnd":109,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The violatingCode exhibits excessive cyclomatic complexity due to deeply nested conditional logic and multiple type assertions within handler functions.\n\n```go\nfunc _JSONSchemaService_GenerateObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(RequestBody)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(JSONSchemaServiceServer).GenerateObject(ctx, in)\n\t}\n\t// ...\n}\n```","codeResolution":"The solution for cyclomatic complexity refactors the original handler logic to delegate operation-specific behavior to an abstraction, reducing branching and improving maintainability.\n\n```go\n// Replace the original switch/case or if/else block with:\nop := getOperation(req.OperationType)\nresult, err := op.Execute(req)\nif err != nil {\n    return nil, status.Errorf(codes.Internal, \"operation failed: %v\", err)\n}\nreturn result, nil\n```","severity":"Critical","rationale":"Cyclomatic complexity is important because it directly impacts code maintainability and testability. In the provided code, most functions have low complexity, but the handler functions (e.g., `_JSONSchemaService_GenerateObject_Handler` and `_JSONSchemaService_StreamGeneratedObjects_Handler`) combine multiple responsibilities, such as decoding, error handling, and conditional logic. This increases the number of decision points, making the code harder to reason about and more prone to bugs if extended. High complexity in these areas can slow down future development and complicate unit testing. Refactoring these handlers into smaller, focused functions would reduce complexity and improve overall code quality.","lineStart":97,"lineEnd":120,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode disregards linesOfCode principles by including excessive boilerplate and repetitive patterns, resulting in unnecessarily high code volume.\n\n```go\nfunc (c *jSONSchemaServiceClient) StreamGeneratedObjects(ctx context.Context, in *RequestBody, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamingResponse], error) {\n\tcOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)\n\tstream, err := c.cc.NewStream(ctx, &JSONSchemaService_ServiceDesc.Streams[0], JSONSchemaService_StreamGeneratedObjects_FullMethodName, cOpts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tx := &grpc.GenericClientStream[RequestBody, StreamingResponse]{ClientStream: stream}\n\tif err := x.ClientStream.SendMsg(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := x.ClientStream.CloseSend(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn x, nil\n}\n```","codeResolution":"The codeResolution for linesOfCode focuses on reducing verbosity and improving maintainability by abstracting repetitive logic into helper functions or interfaces. Here is the replacement code for the identified block, assuming all necessary abstractions are defined elsewhere:\n\n```go\n// Replace direct method calls with abstraction usage\nfunc (c *jSONSchemaServiceClient) GenerateObject(ctx context.Context, in *RequestBody, opts ...grpc.CallOption) (*Response, error) {\n\treturn getOperation(\"GenerateObject\").Execute(ctx, in, opts...)\n}\n\nfunc (c *jSONSchemaServiceClient) StreamGeneratedObjects(ctx context.Context, in *RequestBody, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamingResponse], error) {\n\treturn getOperation(\"StreamGeneratedObjects\").ExecuteStream(ctx, in, opts...)\n}\n```","severity":"Critical","rationale":"The code snippet demonstrates excessive lines of code due to verbose type definitions, repeated boilerplate, and redundant comments (e.g., lines 1–10, 41–61, 63–80). This impacts maintainability, as future changes require updates across many locations, increasing the risk of inconsistencies and errors. High LoC also makes the code harder to review and test, obscuring core logic within generated scaffolding. Refactoring to reduce duplication and leverage composition or helper functions would improve clarity and maintainability, making the codebase easier to extend and debug.","lineStart":17,"lineEnd":143,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode exhibits excessive nesting within handler functions, making the logic harder to follow and maintain.\n\n```go\nif interceptor == nil {\n\treturn srv.(JSONSchemaServiceServer).GenerateObject(ctx, in)\n}\ninfo := &grpc.UnaryServerInfo{\n\tServer:     srv,\n\tFullMethod: JSONSchemaService_GenerateObject_FullMethodName,\n}\nhandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\treturn srv.(JSONSchemaServiceServer).GenerateObject(ctx, req.(*RequestBody))\n}\n```","codeResolution":"The codeResolution for nestingDepth focuses on flattening the control flow in the handler by delegating responsibilities to helper abstractions, resulting in clearer and more maintainable logic.\n\n```go\nfunc (s *serverImpl) GenerateObject(ctx context.Context, req *RequestBody) (*Response, error) {\n\tif !validateRequest(req) {\n\t\treturn nil, status.Errorf(codes.InvalidArgument, \"invalid request\")\n\t}\n\treturn processGeneration(ctx, req)\n}\n```","severity":"Critical","rationale":"### Rationale\n\nThe code maintains a shallow nesting depth, with most functions containing only one or two levels of control flow (e.g., `if err != nil { ... }`). This is important because deep nesting can obscure logic, making the code harder to read, maintain, and test. For example, in `StreamGeneratedObjects`, each error check is handled with a guard clause, preventing unnecessary indentation and complexity. Keeping nesting depth low improves maintainability and reduces the risk of bugs introduced by convoluted control structures. This approach aligns with best practices for clean, reliable code.","lineStart":97,"lineEnd":120,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The violatingCode strictly adheres to dependenciesModules principles, importing only the necessary external packages without introducing redundant or unused dependencies.\n\n```go\nimport (\n\tcontext \"context\"\n\tgrpc \"google.golang.org/grpc\"\n\tcodes \"google.golang.org/grpc/codes\"\n\tstatus \"google.golang.org/grpc/status\"\n)\n```","codeResolution":"The code demonstrates a solid approach to dependency management by only importing essential gRPC modules, keeping the dependency footprint minimal and focused.\n\n```go\nimport (\n\tcontext \"context\"\n\tgrpc \"google.golang.org/grpc\"\n\tcodes \"google.golang.org/grpc/codes\"\n\tstatus \"google.golang.org/grpc/status\"\n)\n```","severity":"Critical","rationale":"The code demonstrates good dependenciesModules practices by only importing essential packages (`context`, `google.golang.org/grpc`, `codes`, `status`). This minimizes external dependencies, reducing the risk of version conflicts and making the codebase easier to maintain. Overuse of dependencies can lead to bloated binaries and increased attack surface, but this implementation avoids such pitfalls. Keeping imports focused on core functionality also improves performance and correctness, as there are fewer moving parts to manage and update. For example, lines like `import ( context \"context\" grpc \"google.golang.org/grpc\" codes \"google.golang.org/grpc/codes\" status \"google.golang.org/grpc/status\" )` show restraint and clarity in dependency management.","lineStart":7,"lineEnd":13,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A-","testability":"A"},"issues":{"cyclomaticComplexity":6,"dependenciesModules":4,"functionMethodCounts":18,"linesOfCode":172,"nestingDepth":2}},"hash":"f9f73a894e8bd2ed73d4e1a7f77e16c8475f9c69bc15bf5184a74b74683dbaee","id":"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"}
{"assessingTool":"SOLID","filePath":"client/model.go","grade":"B-","username":"HLamb","timestamp":"2025-10-21T17:59:01.672Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependencyInversion","violatingCode":"The RequestBody struct directly depends on the concrete jsonSchema.Definition type, violating dependency inversion by not relying on an abstraction.\n\n```go\ntype RequestBody struct {\n\tPrompt     string                 `json:\"prompt\"`\n\tDefinition *jsonSchema.Definition `json:\"definition\"`\n}\n```","codeResolution":"To address dependency inversion, the solution introduces an abstraction layer for operations, allowing the client code to depend on interfaces rather than concrete implementations.\n\n```go\n// Go\n// Replace direct operation logic with abstraction usage\nfunc ProcessRequest(req RequestBody) Response {\n    op := getOperation(req.Definition) // Returns an Operation interface\n    result := op.Execute(req.Prompt)\n    return Response{\n        Data:    result,\n        UsdCost: calculateCost(result),\n    }\n}\n```","severity":"Critical","rationale":"This code tightly couples the RequestBody struct to the concrete jsonSchema.Definition type, violating dependency inversion principles. Such direct dependency on an external implementation makes the code harder to maintain and test, as any change in jsonSchema.Definition could force changes throughout the client package. It also limits flexibility, preventing easy substitution or mocking of the definition for different use cases or unit tests. Introducing an interface or abstraction for Definition would decouple the client package, improving maintainability, extensibility, and testability.","lineStart":5,"lineEnd":7,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The RequestBody struct is tightly coupled to jsonSchema.Definition, making it closed to extension and violating the open/closed principle.\n\n```go\ntype RequestBody struct {\n\tPrompt     string                 `json:\"prompt\"`\n\tDefinition *jsonSchema.Definition `json:\"definition\"`\n}\n```","codeResolution":"The current implementation should be refactored to utilize an abstraction for operations, ensuring new behaviors can be added without modifying existing code. Replace the original block with the following approach:\n\n```go\n// Golang\nfunc (rb *RequestBody) ExecuteOperation(opType string, params map[string]any) (any, error) {\n    op := getOperation(opType) // Returns an Operation interface\n    result, err := op.Execute(params)\n    return result, err\n}\n```","severity":"High","rationale":"The current design tightly couples the RequestBody and Response structs to specific data formats, making it difficult to extend functionality without modifying existing code. This violates the Open/Closed Principle, as adding new request or response types would require direct changes to these structs. Such rigidity hampers maintainability, since every new feature risks introducing bugs into stable code. It also reduces scalability, as developers cannot easily add new behaviors or data types. Refactoring to use interfaces or embedding would allow the code to be open for extension but closed for modification, improving long-term flexibility and robustness.","lineStart":20,"lineEnd":20,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"C-","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"oldCode":"\nimport \"github.com/firechimp-org/go-sdk/jsonSchema\"\n","newCode":"\nimport \"github.com/objectweaver/go-sdk/jsonSchema\"\n","reason":"Modified","start":2,"end":4,"grade":"B-"}]},"hash":"e8b569639ec4eb6dec79fc4c626bec7d7a36c3403c41bb0126e1c881b0976c3d","id":"eJxdkUFPwzAMhf+K5SMa7QVx6JHtgoTExOBEkOalXputjUPigqZp/x1lZRvMN7/45X1x9kgpcUrON68iHVa4eH56nOEErdQ8Fa/sFSsMZLfUMNjOsVfjjXd9kKhgsHHaDqvCSl/KasNWv5m+OJaN3KZ6W26S+IVtuSeD2ae7wPDCnwMnfZB6B0njYBX2xhudR+mDQq6k0fkGrmuZ76sMhuOkwWW2zXjtvFMnHm4uecUf+WSrz9LReshEZQnTyKQMBJFTEJ/4l+qM+08dWWeklIl6Cu8j7Af53SWJlAwuoSy1dQlyC5Y8aMseVgw9xdRS13ENzqtkHSiE6CSTjJuEnF7ksLdUTyUprDshvb+73sYwHp/ehBNcu47npC1WOP5Z2UvNXdEIHn4AWqaw9Q=="}
{"assessingTool":"Complexity","filePath":"converison/requestFormat.go","grade":"B+","username":"HLamb","timestamp":"2025-10-21T17:59:00.713Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode unnecessarily duplicates logic across two conversion functions, inflating linesOfCode and reducing maintainability.\n\n```go\nbody, _ := ConvertStructToMap(protoReq.Body)\n\nbody, _ := ConvertMapToStruct(modelReq.Body)\n```","codeResolution":"The codeResolution streamlines the conversion logic by delegating the conversion process to a single abstraction, reducing repetition and improving maintainability.\n\n```go\n// Replace the body of both conversion functions with a call to a shared abstraction.\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\treturn ConvertRequestFormat(protoReq)\n}\n\nfunc ConvertModelToProtoRequestFormat(modelReq *jsonSchema.RequestFormat) *pb.RequestFormat {\n\treturn ConvertRequestFormat(modelReq)\n}\n```","severity":"Critical","rationale":"## Rationale\n\nThe code snippet demonstrates a moderate linesOfCode count, but both conversion functions repeat similar logic and structure. This redundancy increases maintenance overhead—any change to the RequestFormat mapping must be updated in two places, risking inconsistencies and bugs. Additionally, the lack of abstraction (e.g., helper functions for shared logic) makes the code harder to test and extend. Reducing duplicate code and extracting common patterns would improve maintainability and correctness, ensuring future changes are less error-prone and easier to manage.","lineStart":6,"lineEnd":27,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode fails to adhere to functionMethodCounts principles by combining multiple responsibilities into just two conversion functions, limiting maintainability and scalability.\n\n```go\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\tif protoReq == nil {\n\t\treturn nil\n\t}\n\n\tbody, _ := ConvertStructToMap(protoReq.Body)\n\n\treturn &jsonSchema.RequestFormat{\n\t\tURL:           protoReq.Url,\n\t\tMethod:        jsonSchema.HTTPMethod(protoReq.Method),\n\t\tHeaders:       protoReq.Headers,\n\t\tBody:          body,\n\t\tAuthorization: protoReq.Authorization,\n\t\tRequireFields: protoReq.RequireFields,\n\t}\n}\n```","codeResolution":"The conversion functions in this package currently combine multiple responsibilities, which can be improved by delegating each conversion step to specialized helper functions for better maintainability and clarity.\n\n```go\n// Improved ConvertProtoToRequestFormat using dedicated helpers\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\tif protoReq == nil {\n\t\treturn nil\n\t}\n\treturn buildRequestFormatFromProto(protoReq)\n}\n\n// Improved ConvertModelToProtoRequestFormat using dedicated helpers\nfunc ConvertModelToProtoRequestFormat(modelReq *jsonSchema.RequestFormat) *pb.RequestFormat {\n\tif modelReq == nil {\n\t\treturn nil\n\t}\n\treturn buildProtoRequestFormatFromModel(modelReq)\n}\n```","severity":"Critical","rationale":"The code defines only two functions, each handling both conversion logic and error handling. This low function count means responsibilities are not well separated, making the code harder to maintain and extend. For example, both `ConvertProtoToRequestFormat` and `ConvertModelToProtoRequestFormat` perform nil checks, conversion, and mapping in a single block. If conversion logic or error handling needs to change, updates must be made in multiple places, increasing the risk of bugs. Splitting conversion, validation, and mapping into dedicated functions would improve maintainability and testability.","lineStart":7,"lineEnd":24,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code tightly couples the conversion logic to two external packages, making future maintenance and testing more difficult.\n\n```go\nimport (\n\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n)\n```","codeResolution":"The code efficiently manages dependencies by importing only the required packages for protobuf and JSON schema conversions, maintaining a minimal and focused dependency footprint.\n\n```go\npackage converison\n\nimport (\n\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n)\n```","severity":"Critical","rationale":"The rationale for dependenciesModules in this code centers on the use of two external packages: `pb \"github.com/objectweaver/go-sdk/grpc\"` and `\"github.com/objectweaver/go-sdk/jsonSchema\"`. While these imports are necessary for type conversions, tightly coupling the conversion logic to specific external modules can hinder maintainability. If either package changes its API, the conversion functions may break, requiring widespread code updates. Additionally, importing entire packages for limited use can impact performance and increase binary size. To improve, consider abstracting conversion logic or using interfaces to decouple dependencies, making future updates and testing easier.","lineStart":3,"lineEnd":6,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode exhibits excessive nestingDepth by embedding multiple conditional checks within single functions, reducing readability and maintainability.\n\n```go\nif protoReq == nil {\n\treturn nil\n}\n```","codeResolution":"The solution for nestingDepth in this code focuses on flattening conditional logic using guard clauses, resulting in clearer and more maintainable conversion functions.\n\n```go\n// Improved ConvertProtoToRequestFormat with reduced nesting\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\tif protoReq == nil {\n\t\treturn nil\n\t}\n\tbody, _ := ConvertStructToMap(protoReq.Body)\n\treturn &jsonSchema.RequestFormat{\n\t\tURL:           protoReq.Url,\n\t\tMethod:        jsonSchema.HTTPMethod(protoReq.Method),\n\t\tHeaders:       protoReq.Headers,\n\t\tBody:          body,\n\t\tAuthorization: protoReq.Authorization,\n\t\tRequireFields: protoReq.RequireFields,\n\t}\n}\n```","severity":"Critical","rationale":"The code demonstrates good adherence to nesting depth principles, with a maximum depth of 1 in both conversion functions. This shallow nesting ensures that the logic is easy to follow and reduces cognitive load for future maintainers. By using early returns for nil checks (lines 9 and 22), the code avoids unnecessary indentation and complex control flow. Keeping nesting depth low improves maintainability, makes unit testing simpler, and reduces the risk of introducing subtle bugs due to deeply nested conditions. This approach also facilitates easier refactoring and enhances overall code readability.","lineStart":13,"lineEnd":24,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The violatingCode exhibits minimal cyclomatic complexity concerns, but the repeated use of inline error-ignoring assignments (e.g., body, _ := ...) can obscure error handling and reduce maintainability.\n\n```go\nbody, _ := ConvertStructToMap(protoReq.Body)\n```","codeResolution":"The solution for cyclomatic complexity in this context involves refactoring the conversion logic to delegate body transformation to an abstracted operation, reducing branching and improving maintainability.\n\n```go\n// Replace direct body conversion with an abstracted operation\nbody := getOperation(\"bodyConversion\").Execute(protoReq.Body)\n\nreturn &jsonSchema.RequestFormat{\n\tURL:           protoReq.Url,\n\tMethod:        jsonSchema.HTTPMethod(protoReq.Method),\n\tHeaders:       protoReq.Headers,\n\tBody:          body,\n\tAuthorization: protoReq.Authorization,\n\tRequireFields: protoReq.RequireFields,\n}\n```","severity":"Critical","rationale":"Cyclomatic complexity is important because it directly impacts code maintainability and testability. In the provided code, both conversion functions use simple, linear control flow with only a single conditional check for nil input (e.g., `if protoReq == nil { return nil }`). This keeps complexity low, making the code easier to understand, modify, and test. If more branching logic were added—such as multiple nested conditionals or switch statements—the functions would become harder to reason about and more prone to errors. Keeping cyclomatic complexity minimal ensures that future changes or debugging efforts remain straightforward and reliable.","lineStart":13,"lineEnd":28,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":2,"functionMethodCounts":2,"linesOfCode":43,"nestingDepth":2}},"hash":"52b5a46a42f0978aa2633e2e6252bb8a188e027a4e4292e87a86abd9e21b3078","id":"eJydlMFuozAQhl/F8qEKFRvuSDm0kbo9NFKUkhvSysAE3IKH2kPbbJV3rwzUQBu6q3LzzD8z/9ifeOPCGDBGqjxCLHnI11jVJbxKOnKfp5jBGhWBIh7yWqSPIgeWonoGLQ2qWMVKVjVqYotYxVQnLOa5pKJJlilWASYPkNILiGfQQY6/TPYY5LpOY27V/5Q+GFT3aQGVsAWenRYEbN2Op61Gwgh38NSAoRvUlaDeGhkmWG3zSXNgUwUhowLYb2QVZlBOs7E6NCr9bsKibbuDJ3ZZJ8tJymOXg+Fpir3ZfeWBuerViilZdvGYNFCjlY3Y88kuGlOC2dFnf1i4+jB0T7pJKcKNqJ2P5TVmR6+r6NtczNnop+13dyEbPtdpr0u/U2yACsycaNTvNoq2XXZw0J29vvYWRAbahJ+79/FeZV2PTLS7dpmrhgrU8q8giSoc6ifxXmu3kxpuJJSZGWkncb+/09OUn419/gi3fc15iM5jYiGaA2yK0OyQRdu25WjutbyviDmOXPWPONqIOsIOJufjHEefx3/wo8sxP67Dfnd3nh9DWqp8GPUtME71Q2Bc/X8A47RzwHCfH2QJW0EFD/nw4wv0+F6WOfLTO7tR7T8="}
{"assessingTool":"SOLID","filePath":"converison/focus.go","grade":"C","username":"HLamb","timestamp":"2025-10-21T17:58:57.318Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The code violates Liskov Substitution Principle by directly coupling conversion logic to concrete types, preventing substitutability via abstraction.\n\n```go\nfunc ConvertProtoToFocus(protoFocus *pb.Focus) *jsonSchema.Focus {\n\tif protoFocus == nil {\n\t\treturn nil\n\t}\n```","codeResolution":"The solution introduces an abstraction layer for conversion operations, enabling substitutability and adherence to the Liskov Substitution Principle.\n\n```go\n// Replace direct conversion logic with Operation abstraction\nfunc ConvertProtoToFocus(protoFocus *pb.Focus) *jsonSchema.Focus {\n    op := getOperation(\"ProtoToModel\")\n    return op.Execute(protoFocus).(*jsonSchema.Focus)\n}\n\nfunc ConvertModelToProtoFocus(modelFocus *jsonSchema.Focus) *pb.Focus {\n    op := getOperation(\"ModelToProto\")\n    return op.Execute(modelFocus).(*pb.Focus)\n}\n```","severity":"Critical","rationale":"This code tightly couples conversion logic to specific types (`pb.Focus` and `jsonSchema.Focus`), violating Liskov Substitution Principle by not abstracting conversion behavior. Without interfaces or abstractions, substituting different focus types or conversion strategies is impossible, making the code rigid and hard to extend. This impacts maintainability—future changes require modifying every conversion function. It also hinders testability, as mocking or swapping implementations for testing is not feasible. Introducing interfaces for conversion would allow flexible, interchangeable implementations, improving adherence to Liskov Substitution and overall code robustness.","lineStart":1,"lineEnd":24,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code directly depends on concrete types from external packages, violating dependency inversion by not abstracting its dependencies.\n\n```go\nfunc ConvertProtoToFocus(protoFocus *pb.Focus) *jsonSchema.Focus {\n```","codeResolution":"The conversion functions should delegate the transformation logic to an injected abstraction, promoting loose coupling and testability.\n\n```go\n// Go\nfunc ConvertProtoToFocus(protoFocus *pb.Focus) *jsonSchema.Focus {\n    return operation.ConvertProtoToFocus(protoFocus)\n}\n\nfunc ConvertModelToProtoFocus(modelFocus *jsonSchema.Focus) *pb.Focus {\n    return operation.ConvertModelToProtoFocus(modelFocus)\n}\n```","severity":"Critical","rationale":"This code tightly couples the conversion logic to specific concrete types from external packages (`pb.Focus` and `jsonSchema.Focus`), violating dependency inversion principles. Such direct dependencies make the code harder to maintain and test, as any change in the external types or their structure will require changes throughout the conversion functions. Introducing interfaces or abstraction layers would decouple the conversion logic, improving flexibility, testability, and long-term maintainability.","lineStart":1,"lineEnd":23,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"F","openClosedScore":"A-","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"oldCode":"\tpb \"github.com/firechimp-org/go-sdk/grpc\"\n\t\"github.com/firechimp-org/go-sdk/jsonSchema\"","newCode":"\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"","reason":"Modified","start":4,"end":5,"grade":"C"}]},"hash":"1f9906f7138ee1194b3ad6a378e84b3d3579f4d7b4e31fbe99b943c3a0f882b0","id":"eJyVk89vgjAUx/+VpodFDZM7iScXl2VbJNFjL6U8oAp9TVvcwfi/L6VM0DnNOMH7/ujrJ+FIubVgrVTlFrGmCd2sP95eaEQF5rBE5UA5mlDNxZ6XQASqAxhpUTHFlGw0GkcmTDGnM8JoKV3VZnOBTYzZDoT7An4AE5f4bPN9XBotGPXuh9adRbURFTTcB6b+tDgmy+54lxp0uMUVitb2KzlLONF+nrUFCYpD4iogr0gazKEOU6aKVolbTZMuHqIznc27tymZDauEETn6G8iCjPyLBVGyDgpzBlxrlJ/475Nf/jx8uq7rM6nBRruEhGeongchCq6VhDq3N1xB6F3vAHptZCkVr5OxayxE/W6nS7afHtUW0+FuI8CXKD3ga+iXeH+VTbp4z/iaxHTAfmY88v+D8U/NTbZD5T22I9cdtiPXH2xpRAtZQ8pdRRM6/D9x0aVKpKdvfQhJ9A=="}
{"assessingTool":"Complexity","filePath":"jsonSchema/model.go","grade":"A-","username":"HLamb","timestamp":"2025-10-21T17:58:52.287Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A+","readability":"A-","testability":"A-"},"issues":{"cyclomaticComplexity":0,"dependenciesModules":0,"functionMethodCounts":0,"linesOfCode":113,"nestingDepth":2}},"hash":"84a91ce25033e5f7ab5f983446d2cb4139c6eb4e411a2c0358e204b4bc7551f0","id":"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"}
{"assessingTool":"SOLID","filePath":"converison/choices.go","grade":"C","username":"HLamb","timestamp":"2025-10-21T17:58:52.233Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The conversion functions lack interface abstraction, preventing substitutability and violating Liskov Substitution Principle.\n\n```go\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\tif protoChoices == nil {\n\t\treturn nil\n\t}\n```","codeResolution":"The current conversion functions can be improved by introducing an abstraction for the conversion operation, ensuring substitutability and adherence to the Liskov Substitution Principle. Replace the original code block with the following:\n\n```go\n// Golang\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n    return getOperation(\"ProtoToModel\").Convert(protoChoices).(*jsonSchema.Choices)\n}\n\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n    return getOperation(\"ModelToProto\").Convert(modelChoices).(*pb.Choices)\n}\n```","severity":"High","rationale":"The code tightly couples the conversion logic to specific struct types without using interfaces or abstractions, violating the Liskov Substitution Principle. This matters because it prevents substituting alternative implementations or mock types for testing, reducing maintainability and flexibility. If the underlying types change or new variants are introduced, the conversion functions must be rewritten, increasing the risk of errors and making the code harder to extend. Introducing interfaces for the conversion targets would allow for easier substitution and better adherence to Liskov Substitution, improving correctness and future scalability.","lineStart":1,"lineEnd":22,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The conversion functions violate openClosed by requiring modification for each new type added.\n\n```go\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n    // ...\n}\n```","codeResolution":"The current conversion functions can be refactored to leverage an abstraction for conversion operations, improving extensibility and adherence to the Open/Closed Principle.\n\n```go\n// Go\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n    return getOperation(\"ProtoToModelChoices\").Convert(protoChoices).(*jsonSchema.Choices)\n}\n\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n    return getOperation(\"ModelToProtoChoices\").Convert(modelChoices).(*pb.Choices)\n}\n```","severity":"High","rationale":"The current implementation violates the Open/Closed Principle because any changes to the structure of either `pb.Choices` or `jsonSchema.Choices` require direct modification of both conversion functions (see lines 8–27). This tightly couples the conversion logic to specific fields, making the code fragile and harder to maintain as new fields are added or existing ones change. Such rigidity increases the risk of errors and reduces extensibility, since supporting new types or fields demands editing existing code rather than extending it. Refactoring to use interfaces or reflection could improve adherence to openClosed, allowing new fields or types to be handled with minimal changes.","lineStart":13,"lineEnd":22,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The ConvertProtoToChoices and ConvertModelToProtoChoices functions directly depend on concrete types from external packages, violating dependency inversion by tightly coupling the conversion logic to specific implementations.\n\n```go\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n```","codeResolution":"The codeResolution introduces an abstraction layer for conversion logic, enabling dependency inversion and improved testability. Replace the original conversion block with a call to the injected converter interface:\n\n```go\n// Golang\nfunc ConvertProtoToChoices(protoChoices *pb.Choices, converter Converter) *jsonSchema.Choices {\n    if protoChoices == nil {\n        return nil\n    }\n    return converter.ToModel(protoChoices)\n}\n```","severity":"Critical","rationale":"This code tightly couples the conversion logic to specific protobuf and Go model types, violating dependency inversion principles. By directly referencing concrete types (`pb.Choices`, `jsonSchema.Choices`) in function signatures and implementations, any change in these types or their packages will require changes throughout the codebase. This reduces maintainability and makes unit testing difficult, as mocking or substituting dependencies is not straightforward. Introducing interfaces or abstraction layers would decouple the conversion logic, improving testability and flexibility for future changes.","lineStart":4,"lineEnd":17,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"C-","openClosedScore":"C-","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"oldCode":"\tpb \"github.com/firechimp-org/go-sdk/grpc\"\n\t\"github.com/firechimp-org/go-sdk/jsonSchema\"","newCode":"\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"","reason":"Modified","start":4,"end":5,"grade":"C"}]},"hash":"69ab7d6257328b91173c4c14a51e359147c6f5be0879ed5cc20cb41c15ff34d1","id":"eJyVk0FrwzAMhf+K8GE0JUtguwV66mAMtrXQHn1JXCdxm1jGVrpD6X8fbpO2XjrGbvGT9PT0QQ4sd046p3S1RmxYxlaL97cXFjOBGzlHTVITy5jJxS6vJAjUe2mVQ80116o1aAkmXHMyBXBWKaq7IhHYplhspaAvme+lTSt8dJtdWlkjOPPdf7ZuHeqVqGWb+4HIb0tTmJ/W09Ii4RrnNSohXR+KHORgfKXoShhqhEC1hFeEFjeyGXSuy06L+36Tk8lgMDVF0n9HML3GGkQ4+HtUCcHUbAZaNecaJyups9or/n30x1zEh7FlP/XZtYW0GYDSFGRKzpUoPvctDCnULgsSJL0a9xuPIcEPD2ONy9vMNxh/4vIYx3BDiHcsJyeTC8nxpdEt3gvJYOofJK9Wdwg+PwVpfmMY9IwZspiVqpHLnGqWsevfkIp+pEJ2/AaXYjxq"}
{"assessingTool":"SOLID","filePath":"converison/hashmap.go","grade":"B-","username":"HLamb","timestamp":"2025-10-21T17:58:49.281Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependencyInversion","violatingCode":"The ConvertProtoToHashMap and ConvertModelToProtoHashMap functions directly depend on concrete types from external packages, violating dependency inversion by not abstracting these dependencies.\n\n```go\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n```","codeResolution":"The conversion functions should delegate field conversion to an injected abstraction, promoting dependency inversion and testability.\n\n```go\n// Go\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap, converter FieldConverter) *jsonSchema.HashMap {\n    if protoHashMap == nil {\n        return nil\n    }\n    return &jsonSchema.HashMap{\n        KeyInstruction:  protoHashMap.KeyInstruction,\n        FieldDefinition: converter.ToModel(protoHashMap.FieldDefinition),\n    }\n}\n\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap, converter FieldConverter) *pb.HashMap {\n    if modelHashMap == nil {\n        return nil\n    }\n    return &pb.HashMap{\n        KeyInstruction:  modelHashMap.KeyInstruction,\n        FieldDefinition: converter.ToProto(modelHashMap.FieldDefinition),\n    }\n}\n```","severity":"Critical","rationale":"This code tightly couples the conversion logic to specific protobuf and Go model types, violating dependency inversion principles. By directly referencing concrete types (e.g., `pb.HashMap`, `jsonSchema.HashMap`), any change in these structures or the need to support additional formats would require modifying the conversion functions themselves. This reduces maintainability and testability, as mocking or substituting dependencies becomes difficult. Introducing interfaces or abstraction layers for the conversion process would decouple the logic, making the codebase more flexible and easier to extend or test.","lineStart":7,"lineEnd":22,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The ConvertProtoToHashMap and ConvertModelToProtoHashMap functions violate openClosed by requiring modification for each new conversion type.\n\n```go\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\t// ...\n}\n```","codeResolution":"The current conversion functions can be improved for openClosed by delegating the conversion logic to an abstraction, allowing new conversion strategies without modifying existing code.\n\n```go\n// Go\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\tif protoHashMap == nil {\n\t\treturn nil\n\t}\n\treturn getOperation(\"ProtoToModel\").Convert(protoHashMap).(*jsonSchema.HashMap)\n}\n\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n\tif modelHashMap == nil {\n\t\treturn nil\n\t}\n\treturn getOperation(\"ModelToProto\").Convert(modelHashMap).(*pb.HashMap)\n}\n```","severity":"High","rationale":"The current implementation tightly couples conversion logic to specific types, violating the Open/Closed Principle. If new conversion types or fields are added to HashMap, the functions (e.g., `ConvertProtoToHashMap`, lines 7–16) must be modified directly. This approach reduces maintainability, as every change requires editing existing code, increasing the risk of introducing bugs. It also hinders extensibility, making it harder to support new formats or conversion rules without altering core logic. Refactoring to use interfaces or generic handlers would allow new conversions to be added without modifying existing functions, improving adherence to openClosed and overall code quality.","lineStart":7,"lineEnd":18,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"C-","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"oldCode":"\tpb \"github.com/firechimp-org/go-sdk/grpc\"\n\t\"github.com/firechimp-org/go-sdk/jsonSchema\"","newCode":"\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"","reason":"Modified","start":4,"end":5,"grade":"B-"}]},"hash":"7552ca0b0db46d2239a48dbfe48c09d818148301f9f9c654837c26e0766372f7","id":"eJyVk1FvgjAUhf9K04dFjIN3Ep8028xmZqKPfSmlQBXuJW1xWYz/fSmCUnVbfKP39px7z9dwoNwYaYyCfINY0piuPz8WczqhAlM5Q7ASLI1pzcWO55IIhL3UyiAwYKCqGrUlIwbM1glhNFe2aJJQYBVhspXCfkm+lzrK8dmkuyjXtWDU3f736tYgrEUhK+4EgZsWRWTWjrcrjRY3+MZNseR1t5Q1hJPadZImI33PIrGFJK9IKkxl2dcZZA2I+36j1qQ3GNdJ2H0HZHxZqy+Sg8ujMuKpplMCqjz1mNXSNhpcxZ2PLsy5+HRr2ane5fcCjNWNsAohJt6E0O9OTpIXJct0LjMF6qTxAy4dAi9eeKUIJt2GR594q9zgaphxgP0ar8N++xg+9DuWo9bkTP6WTDB8jjN5T/UA+YvVb8SHzo8RH6bzYv1FnE5opkq54ragMb38a1HBTVHxOsyRHn8ApHtf6Q=="}
{"assessingTool":"SOLID","filePath":"converison/grpcConverison.go","grade":"B+","username":"HLamb","timestamp":"2025-10-21T17:58:48.697Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The conversion functions in this code violate interfaceSegregation by combining multiple distinct responsibilities (e.g., handling SpeechToText, TextToSpeech, SendImage, and Image) into single, monolithic functions rather than delegating to focused interfaces.\n\n```go\nmodelDef := &jsonSchema.Definition{\n    // ... many unrelated fields and conversions ...\n    SpeechToText:       convertProtoSpeechToText(protoDef.GetSpeechToText()),\n    TextToSpeech:       convertProtoTextToSpeech(protoDef.GetTextToSpeech()),\n    SendImage:          convertProtoSendImage(protoDef.GetSendImage()),\n    // ...\n}\n```","codeResolution":"The solution restructures the conversion logic by delegating each conversion operation to a dedicated abstraction, ensuring interface segregation and single responsibility.\n\n```go\n// Go\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n\tif protoDef == nil {\n\t\treturn nil\n\t}\n\treturn getOperation(\"ProtoToModel\").Convert(protoDef).(*jsonSchema.Definition)\n}\n```","severity":"High","rationale":"The code violates interface segregation by combining multiple conversion responsibilities into single functions like `ConvertProtoToModel` and `ConvertModelToProto`, which handle diverse nested types and mappings. This approach makes the code harder to maintain and extend, as changes to one aspect (e.g., handling `SpeechToText` or `SendImage`) require modifying large, monolithic functions. It also increases the risk of introducing bugs when updating nested conversion logic. Adhering to interface segregation would mean splitting these responsibilities into smaller, focused interfaces or functions, improving modularity, testability, and reducing the impact of future changes.","lineStart":1,"lineEnd":77,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"A-","interfaceSegregationScore":"C-","liskovSubstitutionScore":"A+","openClosedScore":"A","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"oldCode":"\tpb \"github.com/firechimp-org/go-sdk/grpc\"\n\t\"github.com/firechimp-org/go-sdk/jsonSchema\"","newCode":"\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"","reason":"Modified","start":4,"end":5,"grade":"B+"},{"newCode":"\t\tTemp:               float64(protoDef.Temp),\n\t\tPriority:           protoDef.Priority,","reason":"Added","start":33,"end":34,"grade":"B+"},{"newCode":"\t\tTemp:               float32(modelDef.Temp),\n\t\tPriority:           modelDef.Priority,","reason":"Added","start":86,"end":87,"grade":"B+"}]},"hash":"31c1409f962bf1aaf0efd7985d14104e072b7cfc6f5f3ecc67818d54525aa47a","id":"eJzlWU1vGzcQ/SvsHgyvoUpAW/SwgA6FDX8ASWNYai5RDvRqJG28S65Jyqlq+L8H/NzhimvLdm7NKcuZeZzhDN+j7ceMSglSVmw957zOimz26cPVWTbKSr6EU84UMJUVWUvLO7oGUnL2AKKSnC3YglVNy4Uixwu2UO0tWWTrSm22t+OSNxN++w1K9R3oA4jJmv8ql3eTtWjLRaa9X3T9JjmblRtoqA7I9W6TCTk126trwRWf8498CbVLSUlCSavXb7crcgarilWq4owoTnZ8K8gFJ43x72wLttqyMgV6bJDOYEVO2ttxF5GTky4xtE4edVHVioS46ZSwqrbrCyVAbQXTK/r7SVezUCYd7VtMyVES1kXPdy0UJP6H/ami2iUkPdZf+cgGXzGpxLbUcAEjOCKjc78WvAWhKpDdjg29g+OGtl+kEhVbf03mGvZT0Mhets+d8PgCbMxxno/IZEL+kUAuQCkQUjdvQ9myBnOYJZUg7S4Go7dLQDTGrp7SzvcnsQRRRI49owuZ7aSC5lrwplV+izWomSn+mldMgYjSxwG+ihldgY5SIMiKC9LaOJf+VdMK/gANMJ9ggZqyZ/SJQQ2lOq+gXoYTDlHY6Pw/c71jkT4ka3Sel1RuPtI2co2b5jyiuv2aLpnook83UN6R75Xa+A5a+L+pEPz7OS+3XTYxvLFF4CjGn+llNwqSrqDeWfQbuO/fjh76DdxvQapzLhqqol1u4F6jW6DTDa9KkM+cgvOIIPxagJm1AOVmzufwb5ifEsFgezxH2IDmqN6FWwBSwZLYS+sOV3vPHWhqO2yPtosMXfbAllcNXWPGibL39jj1sJroFc52pgTQZmAmrXHk62rafl9XNafqzz8Q00HT5uGqV1xUalekoL1xhAi4S7NjPdLQtsflY2T9JaJ1fbHvYDeyrs5tp/lcULaGJIIL7egfGb/cwe4rmZKTQcL0e+QW5QlV4zTGwy7YkxPNS6hbzUJbVnpFtNdH8xOxnI74yWjiHt890Nq55uTExXjR07bplCyyRTYseH7p6IHWXW6uUFPhnJt6O0Ef0m1dQVLsY0HHoMdBbNMCnveEPtQW4g4QdIl0QA+BPpAezBhrRW+aovApOUnGoO3CW0O/H6Lsn3k32NaF43jxqRAc3/ZU6D2fXn4jJJs2NgE+OqX9wfMl7ce37kDtx33xBST0u0v2NfrdNfkw/Q7+h+o3PlAv2AHELfiTfUanMYwV5QCCojzQM5KMgWJdDoA3cH+AJGMgr8EBwi2EgesJGulEzcBY6UIdpGs4QM5NbKTaXTvRah4UbVCpbTFYkLsbilYPEGmbU5BjNF9uKWAklLjzPkiJf/8Np/m8EqOL92olTkjlkBIb130lTiEEJU7ItFfiFCsdRXsMK7GHHVRiaX4ywJMyIrjbI0LZknC1AbH/8rNSN/iulOjDaFs0kJEKYkvQvSj+Je0L2j6A+jhI3AMB9sWDc7DE7gfsr+2y4nM+F5TJUlS3UEQJj/fsLu4DZettfG2iOG/3g8/tI2jI3duD+yltTWOLAXdvdwGW+IqBAzFFOG6McOxa7i/QU3IaIjJR6MNMQ0Qq0TRgS5iGKP4t04BR09Mw4GwnAe8fT8JnzfNJFGOJI80S4j/zWy9zzEVU4jiypZs10KgI5qBGdVwt/f/shQ2EHd/W4BSualh50z310Y9IKqX+nVLRIY+71cFi9sUw5qCBq57vsdM7OaiHNsw97in8f2SZVOkvDev+EyVmlYELnO/xzTtZpYeW7q8r8GDeSPn/TLZI4R904El2SF3fPCaN97ADxvkprGALqPaSR4nHSVevThgn62bBnbnBips/q/7TvY8c9BruRTbKVlUN11RtsiLr/u5h/ohxGj7Ha549/QCauvKQ"}
{"assessingTool":"Complexity","filePath":"converison/focus.go","grade":"A-","username":"HLamb","timestamp":"2025-10-21T17:58:48.666Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A+","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":2,"functionMethodCounts":2,"linesOfCode":33,"nestingDepth":2}},"hash":"d606d363bf48815dada95fd2540ffd667a9e109b7f3d5dcf12bbbf7f748b5914","id":"eJyVk89vgjAUx/+VpodFDZM7iScTd1iWkcwjl1IeUIW+pn24Lcb/fSllgs65jBO874++fhKOXDgHzildbREbnvA1tqaBD0WfPOISC1ijJtDEE26E3IsKmER9AKsc6kxnWrUGLbFZpjMyOct4paju8qXENsZ8B5LeQRzAxhU+umIfV9bIjHv3n9adQ/0ma2iFD8z9aXHM1v3xlFok3OIGZeeGlcgxwYyf513JgkLIqAb2hKzFApowzXTZaXmradbHQ3Rh8mX/NmeLcZUwYkd/A1WyiX+1Ylo1QcnIAnVW+4n/Pvnlz8OH67ohk1psDSUsPGP1MghRcG0UNIW74QrC4HoGMK9WVUqLJpm6pkI07Ha6ZPviUW0xHe82AXyJ0gO+hn6J90fZrI8PjK9JzEfsZ8YT/z8Yf9fcZDtW3mM7cd1hO3H9wpZHvFQNpIJqnvDx/4nLPlUhP30B8ZBMpw=="}
{"assessingTool":"SOLID","filePath":"client/grpcGenerateObject.go","grade":"D","username":"HLamb","timestamp":"2025-10-21T17:58:47.137Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The GrpcGenerateObject method violates interface segregation by forcing the Client type to handle multiple responsibilities (connection management, authentication, request construction, and response conversion) within a single function.\n\n```go\nfunc (c *Client) GrpcGenerateObject(prompt string, definition *pb.Definition) (*Response, error) {\n\t// Set up a connection to the gRPC server\n\tconn, err := grpc.NewClient(c.BaseURL, grpc.WithInsecure(), grpc.WithBlock())\n\t// ... (multiple unrelated responsibilities)\n}\n```","codeResolution":"The refactored solution applies interface segregation by delegating the object generation to an abstraction, ensuring the Client depends only on the required operation interface.\n\n```go\n// Go\nfunc (c *Client) GrpcGenerateObject(prompt string, definition *pb.Definition) (*Response, error) {\n\top := getOperation(\"generateObject\")\n\treturn op.Execute(c, prompt, definition)\n}\n```","severity":"Critical","rationale":"This code violates the Interface Segregation Principle by tightly coupling the GrpcGenerateObject method to the pb.JSONSchemaServiceClient and its GenerateObject RPC. The Client struct is responsible for connection management, request construction, and direct invocation of a specific RPC method, making it difficult to substitute, test, or extend for other gRPC services. This monolithic approach reduces maintainability and flexibility, as changes to the underlying service or authentication mechanism would require modifying this method directly. Adhering to interface segregation would allow for more focused abstractions, enabling easier mocking and improved separation of concerns.","lineStart":17,"lineEnd":38,"status":""},{"done":false,"titleTask":"singleResponsibility","violatingCode":"The GrpcGenerateObject method violates the Single Responsibility Principle by handling connection setup, authentication, request construction, RPC invocation, and response conversion all within one function.\n\n```go\nconn, err := grpc.NewClient(c.BaseURL, grpc.WithInsecure(), grpc.WithBlock())\n...\nmd := metadata.New(map[string]string{\"x-api-key\": c.Password})\n...\nresponse, err := client.GenerateObject(ctx, request)\n...\ndata, err := converison.ConvertStructpbToMap(response.Data)\n```","codeResolution":"The solution applies the single responsibility principle by delegating the gRPC object generation to a dedicated abstraction, improving maintainability and testability.\n\n```go\n// Go\nfunc (c *Client) GrpcGenerateObject(prompt string, definition *pb.Definition) (*Response, error) {\n    operation := getOperation(\"generateObject\", c.BaseURL, c.Password)\n    return operation.Execute(prompt, definition)\n}\n```","severity":"High","rationale":"The method `GrpcGenerateObject` violates the Single Responsibility Principle by handling connection setup, authentication, request construction, RPC invocation, and response conversion all within a single function. This tightly coupled design increases the risk of errors, complicates testing, and makes future changes more difficult, as modifications to one concern may inadvertently affect others. Separating these responsibilities into distinct methods or components would improve maintainability, readability, and facilitate easier unit testing.","lineStart":13,"lineEnd":38,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code directly instantiates and depends on the concrete pb.JSONSchemaServiceClient, violating dependency inversion by not relying on abstractions.\n\n```go\nclient := pb.NewJSONSchemaServiceClient(conn)\n```","codeResolution":"The solution applies dependency inversion by replacing direct usage of the concrete gRPC client with an injected abstraction, allowing for flexible and testable client interactions.\n\n```go\n// Go\n// Use the injected abstraction instead of directly instantiating the gRPC client\nresponse, err := c.operation.GenerateObject(ctx, request)\nif err != nil {\n    return nil, fmt.Errorf(\"failed to call GenerateObject: %v\", err)\n}\n```","severity":"Critical","rationale":"This code violates dependency inversion by directly instantiating the gRPC connection and client within the GrpcGenerateObject method (lines 10–22). This tight coupling to concrete implementations makes the code difficult to test, extend, or swap out for alternative transport mechanisms. It also hinders maintainability, as any change to connection logic requires modifying this method. Adhering to dependency inversion by injecting abstractions (e.g., interfaces for connection and client) would improve flexibility, enable easier mocking for unit tests, and reduce the risk of bugs from future changes.","lineStart":17,"lineEnd":38,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The GrpcGenerateObject method violates the open/closed principle by hardcoding the gRPC method call, making it difficult to extend or support new RPC methods without modifying the function.\n\n```go\nresponse, err := client.GenerateObject(ctx, request) // Replace 'GenerateObject' with the actual RPC method name\n```","codeResolution":"The current GrpcGenerateObject implementation directly invokes the gRPC method, making it difficult to extend or swap out request operations without modifying this function. To better adhere to the open/closed principle, delegate the operation to an abstraction:\n\n```go\ngo\n// Replace direct method call with abstraction\noperation := getOperation(\"GenerateObject\") // Factory returns appropriate Operation\nresponse, err := operation.Execute(ctx, client, request)\nif err != nil {\n    return nil, fmt.Errorf(\"failed to execute operation: %v\", err)\n}\n```","severity":"High","rationale":"The current implementation violates the Open/Closed Principle because any change to the request structure or addition of new gRPC methods requires modifying the `GrpcGenerateObject` function directly. This tightly couples the client logic to specific RPC calls and request formats, making the code harder to extend and maintain. For example, adding support for another RPC method would mean duplicating much of the connection and context setup logic, increasing the risk of errors and code duplication. Refactoring to use abstractions or interfaces for request handling would allow new functionality to be added with minimal changes, improving maintainability and scalability.","lineStart":22,"lineEnd":38,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"F","liskovSubstitutionScore":"A+","openClosedScore":"C-","singleResponsibilityScore":"C-"},"codeDiff":{"changes":[{"oldCode":"\t\"github.com/firechimp-org/go-sdk/converison\"\n\tpb \"github.com/firechimp-org/go-sdk/grpc\"","newCode":"\t\"time\"\n\n\t\"github.com/objectweaver/go-sdk/converison\"\n\tpb \"github.com/objectweaver/go-sdk/grpc\"","reason":"Modified","start":6,"end":9,"grade":"D"}]},"hash":"a63d1fb77d7c137f9a6513f1376b870633df4f7c9cbba30f2ef47db9d103a5eb","id":"eJylVFFv4zYM/iucgO3swLW3VwN5aTocbrhdi6SHPcx7UGTa1mKLnkQ3vRX57wdJdpOsB2zA8uBIFEV+30dSL0I6h85p0z4S9aIUu/uPH+5EJhTVuCHDaFiUYpTqIFsE1Ws0XJnK6GEky5BUpuJKKO/5zJWI22Z4XbIeMKzDrtXcTftc0VDQ/k9UfET5hLZo6cbVh0KReUKrHZl4fdzDv95p7aiWZC1R22PeUi9Nm5Nt/8NpMSDLWrL0bqkHWhSwQ1Nv8a8JHT/SDu0TWnBoagcSbLQDE3CH0G4fNuCiy1FzB3Lijqz+W7ImAx3KGq2rTDMZBYmC1SZomMJ7O6r3aNBKxvtALBktDSODY6tNm0GNjTY6hFmN+/zudZtCstqiG8k4zACtJZvCi2cZsDNMI0hQZAyqcP0tVu/sHcJ1KNfgtcg/4THCS1R+Kx1+3n7M4slvmrsPxqGaLCbphfG2J3VIUq8c6yZE+24NRvcRUMUWebLGWzJoBs5/9nCbpBKN1D3WHtuM1C8juhK+f6pEwBYCn/ynxgYteB0TfwFWAUPEuyFj0iWjx7AOQfNNTw6TNNrfwgvmEPwUYqbRVhSwsSgZQYLB49z20FgarnXUCoOQ8bxcw7j3Gv6yu/+0Ux0OchedFlG/nWKenrl9wI8MTRwC83MGShqFvY8+OwbdH6NXsthupTq0liZT+/L4GPkOFZl69dOP6Vm+GCw5o5jbZZmCCMKTvO5jpgOGK0PtkSzunm0yyPH32LN/xL+XSjzfyFHfHPBLJUpQ+YN07ki2PqUzLbiOcT9xS9q0m8gmCcSH+o1YHtgygPE18OeLpVzDD+M+nyf3luovc0c8hMEqwf/ikGXx4DxT5cW4ZUvPzbll35/rPiB3VIPXpLt4EdleDmSoVjjK/zHjgdkMOIWigC2OvVQI764d311UQvEke7hIbuSA/2vgPKPrfN8aOd81kuWZ0ev7nG/CkndsJ8Xj/pF+lWOySJDfSZZz7Sy6UJflvZpBeo9Qj5Ag2j67ekOOS3iNM1su6zGzs+gyT7Eyp8qITDS6xwfJnShF1D087tcU85bE6SunUH/M"}
{"assessingTool":"SOLID","filePath":"client/req.go","grade":"C-","username":"HLamb","timestamp":"2025-10-21T17:58:44.342Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"singleResponsibility","violatingCode":"The ExecuteRequest function violates single responsibility by handling request body merging, JSON marshaling, HTTP request creation, header setting, and request execution all within one function.\n\n```go\nfunc ExecuteRequest(currentGen map[string]any, d *jsonSchema.Definition) (*http.Response, error) {\n\t// Merge currentGen into the existing body\n\t// Marshal the body to JSON\n\t// Create the HTTP request\n\t// Set headers and authorization\n\t// Execute the request\n}\n```","codeResolution":"The solution introduces a dedicated abstraction for HTTP operations, ensuring that request construction and execution are handled by specialized types, thus achieving single responsibility.\n\n```go\n// Replace the original request execution block with the new abstraction\noperation := getOperation(d.Req.Method)\nresp, err := operation.Execute(d.Req.URL, d.Req.Body, d.Req.Headers, d.Req.Authorization)\nif err != nil {\n    return nil, fmt.Errorf(\"failed to execute request: %w\", err)\n}\n```","severity":"Critical","rationale":"This code violates the Single Responsibility Principle by combining multiple concerns—request body merging, JSON marshaling, HTTP request creation, header management, and request execution—within the `ExecuteRequest` function (lines 8–44). This tightly coupled logic makes the code harder to maintain and test, as changes to one aspect (e.g., header handling) could inadvertently affect others. Additionally, error handling and logging are scattered, further reducing clarity. Refactoring into smaller, focused functions would improve maintainability, facilitate unit testing, and reduce the risk of introducing bugs when modifying individual responsibilities.","lineStart":22,"lineEnd":44,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The ExecuteRequest function violates interface segregation by directly depending on the entire jsonSchema.Definition struct, forcing it to handle unrelated concerns.\n\n```go\nfunc ExecuteRequest(currentGen map[string]any, d *jsonSchema.Definition) (*http.Response, error) {\n\t// Merge currentGen into the existing body\n\tif d.Req.Body == nil {\n\t\td.Req.Body = make(map[string]interface{})\n\t}\n\tfor key, value := range currentGen {\n\t\td.Req.Body[key] = value\n\t}\n```","codeResolution":"The solution introduces an abstraction layer for request execution, ensuring that the client code depends only on a minimal, well-defined interface for sending requests.\n\n```go\n// Go\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\top := getOperation(def, currentGen)\n\tresult, err := op.Execute()\n\tif err != nil {\n\t\tlog.Println(\"failed to execute operation\", err)\n\t\treturn nil\n\t}\n\treturn result\n}\n```","severity":"Critical","rationale":"This code violates the Interface Segregation Principle by tightly coupling HTTP request construction, execution, and response handling within single functions (`ExecuteRequest`, `SendRequest`). This monolithic approach forces clients to depend on all aspects of the request lifecycle, even if they only need a subset (e.g., just request building or response parsing). Such design reduces maintainability, as changes to one concern can inadvertently affect others, and hinders testability since mocking or substituting individual behaviors becomes difficult. Splitting responsibilities into focused interfaces would allow for more flexible, robust, and easily testable code.","lineStart":16,"lineEnd":41,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code violates dependency inversion by directly instantiating and depending on the concrete http.Client type within the ExecuteRequest function.\n\n```go\nclient := &http.Client{}\nresp, err := client.Do(req)\n```","codeResolution":"The solution introduces an abstraction layer for HTTP request execution, allowing the client code to depend on an interface rather than a concrete implementation, thus achieving proper dependency inversion.\n\n```go\n// Go\n// Replace direct usage of ExecuteRequest with injected abstraction\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any, executor RequestExecutor) *Res {\n\trequest, err := executor.Execute(currentGen, def)\n\tif err != nil {\n\t\tlog.Println(\"failed to execute request\", err)\n\t\treturn nil\n\t}\n\n\tvalue, err := extractValue(request)\n\tif err != nil {\n\t\tlog.Println(\"failed to extract value\", err)\n\t\treturn nil\n\t}\n\n\treturn value\n}\n```","severity":"Critical","rationale":"This code tightly couples the HTTP client instantiation (`client := &http.Client{}` in `ExecuteRequest`) and request execution logic directly within the function, violating dependency inversion principles. By depending on concrete implementations rather than abstractions (e.g., an injected interface for HTTP operations), the code becomes harder to test, extend, or maintain. For example, swapping out the HTTP client for a mock in unit tests or customizing client behavior requires modifying the function itself, increasing fragility and reducing flexibility. Adhering to dependency inversion would allow for easier substitution and improved maintainability without sacrificing correctness or performance.","lineStart":22,"lineEnd":44,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"D-","liskovSubstitutionScore":"A+","openClosedScore":"A-","singleResponsibilityScore":"D"},"codeDiff":{"changes":[{"newCode":"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"","reason":"Added","start":9,"end":10,"grade":"C-"}]},"hash":"099cc29187454ec0bbaf40772591c6ba90f5a8d0c377928bfd68defc8bce4d18","id":"eJylVE1v2zAM/SucgA124dn3AD1sbfeFbiuSbpe5B8WmbTU2lUr00qzIfx8ky4mzIRuwXYKIoh4f+ej3JKS1aK2i+lbrVszE4vP1+0uRiEKXeKGJkVjMxFoWK1kjFK1C4pxyUt1aG4Yop5xzsdwy2lwMB6RCl4rq7N5qGoNVx+PfVtfjX0LOGua1P/tIrbjpl2mhu0wv77HgDcrvaLJav7TlykMuigY76Z7E7lWWwdUjFj3jHB96tAw4HC1Igne3tzdgwsVSWixBE3CDELLfaNNJzqnqqfgFKCp6Y5D4LRJ0cv3NslFU30naJlDC2YFLeomVIsVKUwzRmesonaNda7KYABqjTQxPrsEsg49o3CQP0IpYe0b4qCwrqmGpy63LVhWU6Rwf0te63ML5OZBqB5ycpxfQyRVGE4qKGE0lC3zauRnxzv1U2sAKtwl8l22PMDsHI+mYym/Y31a4vYPz4cmIFPqQxjay9cwdYWANHxafP7lrd/aNuypuTmnIjg7QcejQZT07as0g94ZcJIGq4/TKDbCKclFJ1WLpCnWhuCs0g+ebXPhy8THFC4OS0TOc7oG7NfiwJ+j1+oSbUfZhiIHqR+RGl3ESlPgyv07Ar7t78bqvKjSRYxH/Vz/FwDQQPN3RAhkalCUa+ydJB67vhsQDjTGULpCjw7vDioQKsudGG/VDuo0O05o+zcWrowwxTucoHO9Zh8/KCzHRYHATx/qFl+DCn592Q0W73gs0JKaXOjL48F9zDtbwl0EHoIEDqTanXXAav+zY6g3oouiNhY3iRg2G4j86ki1stFkpqi1ECtztKg72skAqxyUrsTphIQmc9J0YzuZoRyuZjBO4kQzKgnUT1T0DIZbWtWyRSh+RI64DBV150jUSGsnOFr3dpuMEPOxegZPGmECJ1WlJWl2nN0YRt/QnHaYaTHWcaOI3dc8HH9nIgr+6YBRA/oWFRwnu9ncOIRjMcJeTSESlWryR3IiZGNY0cx9LrcXuJ0vjpv0="}
{"assessingTool":"SOLID","filePath":"converison/requestFormat.go","grade":"C-","username":"HLamb","timestamp":"2025-10-21T17:58:40.926Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The code violates Liskov Substitution Principle by tightly coupling conversion logic to concrete types, preventing substitutability with alternative request formats.\n\n```go\nreturn &jsonSchema.RequestFormat{\n\tURL:           protoReq.Url,\n\tMethod:        jsonSchema.HTTPMethod(protoReq.Method),\n\tHeaders:       protoReq.Headers,\n\tBody:          body,\n\tAuthorization: protoReq.Authorization,\n\tRequireFields: protoReq.RequireFields,\n}\n```","codeResolution":"The solution introduces an abstraction layer for conversion operations, enabling substitutability and adherence to the Liskov Substitution Principle.\n\n```go\n// Go\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\tif protoReq == nil {\n\t\treturn nil\n\t}\n\top := getOperation(\"ProtoToModel\")\n\treturn op.Convert(protoReq)\n}\n\nfunc ConvertModelToProtoRequestFormat(modelReq *jsonSchema.RequestFormat) *pb.RequestFormat {\n\tif modelReq == nil {\n\t\treturn nil\n\t}\n\top := getOperation(\"ModelToProto\")\n\treturn op.Convert(modelReq)\n}\n```","severity":"Critical","rationale":"This code tightly couples conversion logic to specific types (`pb.RequestFormat` and `jsonSchema.RequestFormat`), violating Liskov Substitution Principle. Without interface abstraction, alternative implementations cannot be substituted, making future changes or extensions difficult. For example, if a new request format is introduced, every conversion function must be rewritten, increasing maintenance overhead and risk of errors. This rigidity also hinders unit testing and code reuse, as mocking or swapping dependencies is not possible. Introducing interfaces for request formats would improve substitutability, maintainability, and correctness.","lineStart":13,"lineEnd":27,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The ConvertProtoToRequestFormat and ConvertModelToProtoRequestFormat functions directly depend on concrete types from external packages, violating dependency inversion by tightly coupling the conversion logic to specific implementations.\n\n```go\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n```","codeResolution":"The codeResolution introduces an abstraction layer for conversion operations, enabling dependency inversion and improved testability.\n\n```go\n// Replace direct conversion calls with abstraction usage\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\tif protoReq == nil {\n\t\treturn nil\n\t}\n\top := getOperation(\"ProtoToModel\")\n\treturn op.Convert(protoReq).(*jsonSchema.RequestFormat)\n}\n\nfunc ConvertModelToProtoRequestFormat(modelReq *jsonSchema.RequestFormat) *pb.RequestFormat {\n\tif modelReq == nil {\n\t\treturn nil\n\t}\n\top := getOperation(\"ModelToProto\")\n\treturn op.Convert(modelReq).(*pb.RequestFormat)\n}\n```","severity":"Critical","rationale":"This code tightly couples the conversion logic to specific protobuf and Go model types, violating dependency inversion principles. By directly referencing concrete types (`pb.RequestFormat`, `jsonSchema.RequestFormat`), any change in these models requires modifying the conversion functions, reducing maintainability and flexibility. This approach also makes unit testing difficult, as mocking or substituting dependencies is not straightforward. Introducing interfaces or abstraction layers for the conversion logic would decouple the implementation, improving testability and future extensibility.","lineStart":1,"lineEnd":22,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The ConvertProtoToRequestFormat and ConvertModelToProtoRequestFormat functions violate openClosed by requiring modification for every new field added to RequestFormat.\n\n```go\nreturn &jsonSchema.RequestFormat{\n\tURL:           protoReq.Url,\n\tMethod:        jsonSchema.HTTPMethod(protoReq.Method),\n\tHeaders:       protoReq.Headers,\n\tBody:          body,\n\tAuthorization: protoReq.Authorization,\n\tRequireFields: protoReq.RequireFields,\n}\n```","codeResolution":"The current conversion functions can be improved for openClosed by delegating the conversion logic to an abstraction, allowing new conversion strategies without modifying existing code.\n\n```go\n// Go\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\treturn operationFactory(\"ProtoToModel\").Convert(protoReq)\n}\n\nfunc ConvertModelToProtoRequestFormat(modelReq *jsonSchema.RequestFormat) *pb.RequestFormat {\n\treturn operationFactory(\"ModelToProto\").Convert(modelReq)\n}\n```","severity":"High","rationale":"The current implementation tightly couples conversion logic to specific struct types, violating the Open/Closed Principle. Any changes to the RequestFormat structure or the addition of new formats would require modifying both ConvertProtoToRequestFormat and ConvertModelToProtoRequestFormat (see lines 8–34). This approach reduces maintainability, as future extensions demand direct edits to these functions, increasing the risk of errors and regressions. Adhering to openClosed would allow new conversion behaviors to be added via extension (e.g., interfaces or strategy patterns), improving scalability and correctness while minimizing code churn.","lineStart":15,"lineEnd":32,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"F","openClosedScore":"C-","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"oldCode":"\tpb \"github.com/firechimp-org/go-sdk/grpc\"\n\t\"github.com/firechimp-org/go-sdk/jsonSchema\"","newCode":"\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"","reason":"Modified","start":4,"end":5,"grade":"C-"}]},"hash":"7eff70d24e700096ba711575272b297a5ceb74c425705f4e574efdb7bbf01066","id":"eJydlMFuozAQhl/F8mEVKhruSDlsW3W7UqKNEnJDWhmYgFvwUHvoqlvl3SsDNdCG7qrcPPPPzD/2J164MAaMkSqPEEse8v2v9c8b7vMUM7hGRaCIh7wW6YPIgaWonkBLgypWsZJVjZrYIlYx1QmLeS6paJJlilWAyT2k9AfEE+ggx0uTPQS5rtOYW/U/pfcG1T4toBK2wLPTgoBdt+Npq5Ewwh08NmDoFnUlqLdGhglW23zSHNlUQcioAPYDWYUZlNNsrI6NSj+bsGjb7uCRXdTJcpLy2MVgeJpiL3ZfeWSuerViSpZdPCYN1GhlI/Z8sovGlGD27LPfLFy9GdqTblKKcCNq52N5hdmz11X0bb7N2einHXbrkA2f63TQpd8pNkAFZk406ncXRdsuOzjozl5fewciA23C9937eK+yrkcm2l27zPeGCtTyryCJKhzqJ/Fea7eTGm4llJkZaSdxv7/T05SfjX3+CLd9zXmIzmNiIZoDbIrQ7JBF27blaO61vI+IOY5c9Zc42og6wg4m5+McR+/Hv/GjyzE/rsNhtz7PjyEtVT6M+hQYp/oiMK7+P4Bx2jlguM+PsoStoIKHfPjxBXp8L8sc+ekViovqjA=="}
{"assessingTool":"SOLID","filePath":"jsonSchema/model.go","grade":"C","username":"HLamb","timestamp":"2025-10-21T17:58:39.578Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependencyInversion","violatingCode":"The Definition struct directly depends on multiple concrete types rather than abstractions, violating dependency inversion principles.\n\n```go\ntype Definition struct {\n\tType DataType `json:\"type,omitempty\"`\n\tProperties map[string]Definition `json:\"properties\"`\n\tItems *Definition `json:\"items,omitempty\"`\n\tHashMap *HashMap\n}\n```","codeResolution":"The revised solution applies dependency inversion by delegating code resolution to an injected abstraction, improving flexibility and testability.\n\n```go\n// Go\nfunc (d *Definition) codeResolution(input string) (string, error) {\n    op := getOperation(d.Type) // Operation is an interface; getOperation is a factory\n    return op.Resolve(input, d)\n}\n```","severity":"Critical","rationale":"The current implementation tightly couples the `Definition` struct to many concrete types (e.g., `HashMap`, `TextToSpeech`, `SpeechToText`, `Image`, etc.), violating dependency inversion principles. This matters because it makes the codebase harder to maintain and extend; any change to these concrete types requires changes in `Definition` and potentially across the codebase. It also hinders testability, as mocking or substituting dependencies becomes difficult. To improve, interfaces should be introduced for these dependencies, allowing `Definition` to depend on abstractions rather than concrete implementations, thus enhancing flexibility and maintainability.","lineStart":1,"lineEnd":87,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The Definition struct violates interface segregation by combining many unrelated responsibilities into a single type, forcing clients to depend on fields they may not need.\n\n```go\ntype Definition struct {\n\t// ... dozens of fields for schema, prompts, requests, images, voting, streaming, etc.\n}\n```","codeResolution":"The solution restructures the code to utilize an Operation abstraction, ensuring each operation is handled via its dedicated interface, thus adhering to the interface segregation principle.\n\n```go\n// Go\nop := getOperation(def.Type)\nresult, err := op.Execute(def)\nif err != nil {\n    // handle error\n}\n// use result as needed\n```","severity":"High","rationale":"The Definition struct violates the Interface Segregation Principle by combining many unrelated responsibilities—such as schema typing, AI model configuration, prompt management, voting, streaming, and multimedia fields—into a single type. This monolithic design makes the code harder to maintain and extend, as changes for one concern risk impacting others. For example, lines like `TextToSpeech *TextToSpeech`, `Image *Image`, and `Voters bool` mix processing, media, and quality control logic. Splitting Definition into smaller, focused interfaces or structs would improve modularity, reduce coupling, and make the codebase easier to test and evolve.","lineStart":7,"lineEnd":87,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The Definition struct violates the Open/Closed Principle because adding new schema features requires modifying the struct directly.\n\n```go\ntype Definition struct {\n\t// ... many fields added for each new feature ...\n\tTextToSpeech *TextToSpeech `json:\"textToSpeech,omitempty\"`\n\tSpeechToText *SpeechToText `json:\"speechToText,omitempty\"`\n\tImage        *Image        `json:\"image,omitempty\"`\n\t// ...\n}\n```","codeResolution":"The solution restructures the code to use an abstraction for operations, enabling new behaviors to be added without modifying existing logic and thus adhering to the Open/Closed Principle.\n\n```go\n// Go\n// Instead of directly handling operations, delegate to the abstraction:\nop := getOperation(def.Type)\nresult, err := op.Execute(def)\nif err != nil {\n    // handle error\n}\n// Use result as needed\n```","severity":"High","rationale":"The current implementation of the `Definition` struct tightly couples many features and data types directly into a single type, violating the Open/Closed Principle. This design makes it difficult to extend functionality (e.g., adding new schema features or processing behaviors) without modifying the core struct, risking regressions and increasing maintenance overhead. For example, adding a new media type or processing option would require changes to the `Definition` itself and potentially all code that interacts with it. This approach reduces flexibility, complicates testing, and can lead to bloated, error-prone code. Refactoring to use interfaces or composition for extensible features would better support open/closed, improving maintainability and correctness.","lineStart":20,"lineEnd":94,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"C-","liskovSubstitutionScore":"A+","openClosedScore":"C-","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"\n\t//Priority - used for setting the priority of the request\n\tPriority int32 `json:\"priority,omitempty\"`","reason":"Added","start":63,"end":65,"grade":"C"},{"newCode":"\nconst (\n\tUrgentPriority   = int32(2)  //the highest priority and will take precedence over all other requests\n\tStandardPriority = int32(1)  //standard priority for most requests\n\tLowPriority      = int32(0)  //low priority requests\n\tEventualPriority = int32(-1) //for batch LLM usage\n)\n","reason":"Modified","start":106,"end":113,"grade":"C"}]},"hash":"92722d0fd01a10dfacb63bb3406f7c0d3fce3c96dbe695b4450e181197f7c219","id":"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"}
{"assessingTool":"SOLID","filePath":"client/client.go","grade":"A","username":"HLamb","timestamp":"2025-10-21T17:58:33.245Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"dependencyInversionScore":"A+","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"A","singleResponsibilityScore":"A"},"codeDiff":{"changes":[{"oldCode":"\t\"github.com/firechimp-org/go-sdk/jsonSchema\"","newCode":"\t\"github.com/objectweaver/go-sdk/jsonSchema\"","reason":"Modified","start":6,"end":6,"grade":"A"}]},"hash":"429b5077447f74a516970240cc595c0807a08c406ffb8c78c26f1864a3668fd3","id":"eJzdVclu2zAQ/ZWpDoFsqNLdQC6JgaZA0BpZLoUuNDWSmMgkQ45ipEH+veCiLU6B9tBLdZE1y+ObeTP0a8KsRWuFbO6U6pJNcvv9+us2yRKuKrxUklBSskk044+sQeCdQEmlLKU4aGUI0lKWVCYSqWiJdJk4n7M0gtp+n3N1KNT+ATkdkT2jKRr12VaPxYNV8pa3eGAuZeWyigIuPTwYtFpJK/YdQq0MtKqrhGxgzywCV7IWTW8YCSWByQoq1CgrlFygLSW9aByALJmeE7w6Sjtm7VGZCsbHkhGycb4LZvH+5ho+8l0R6QgXn8ni/Df41KOlW0fBeP/CEkJ8PbgziqO1ysCJpZRvsQez84QkNDXjCKSA7S0Zxgmu7u52oDSGDgwVf5jmC9+q1OATrJ0+eeS2gnT4DkQyQGOUWU08lnVNmAMPCyZEgEUZ5MGWPQtXi2f0OwBPylljwIWqXtLedBmQekQZW58N8M4N61nsH3D/hsct1qzvaGyJIME68RMtMJB4hNFhiUmOcBTUQhWSQBx0hweUNLS47iU/QU11HKkMetONvMOOxH6HyBWs43m+eIPUGwlnweZN03xupiEc8UNEnNJZgDs3Oif9R38gEv0LNULIVM/CmYa81Zj4blQ3LvHEmob4t4UIX34I/XcKuAzg6qCNu5WU9PsfJ2GmwwT8H4jgivknCsyWzC+pBWoRtFEHTfHmrL0uSmb+O/QkhjFjsRruYoy9T/nQxdUcPo2gQ/snYFhPV32+Hc1uid/v76DLtPabczibbf4gkj8rtC+cGxs1wW/mpcWuuFdRwL1FX9/yeiLlO+Q9kUEgY7Wn56jwfJGTv7/DeB6HIwOe78axnBXk/udI1B7w0zlI0UGsKU6jFJ0/bkk5ShzJDXqMSTw/mYU8/hocqUsLF2SSJbXocMeoTTZJmLQivPJGJW+/AKu47JA="}
{"assessingTool":"SOLID","filePath":"grpc/objectweaver.pb.go","grade":"A+","username":"HLamb","timestamp":"2025-10-21T17:58:28.588Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"dependencyInversionScore":"A+","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"A+","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"// Code generated by protoc-gen-go. DO NOT EDIT.\n// versions:\n// \tprotoc-gen-go v1.36.10\n// \tprotoc        v3.20.3\n// source: objectweaver.proto\n\npackage grpc\n\nimport (\n\tprotoreflect \"google.golang.org/protobuf/reflect/protoreflect\"\n\tprotoimpl \"google.golang.org/protobuf/runtime/protoimpl\"\n\t_ \"google.golang.org/protobuf/types/known/anypb\"\n\tstructpb \"google.golang.org/protobuf/types/known/structpb\"\n\treflect \"reflect\"\n\tsync \"sync\"\n\tunsafe \"unsafe\"\n)\n\nconst (\n\t// Verify that this generated code is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)\n\t// Verify that runtime/protoimpl is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)\n)\n\n// Definition message\ntype Definition struct {\n\tstate              protoimpl.MessageState `protogen:\"open.v1\"`\n\tType               string                 `protobuf:\"bytes,1,opt,name=type,proto3\" json:\"type,omitempty\"`                                                                                       // Corresponds to Go's DataType field (as a string)\n\tInstruction        string                 `protobuf:\"bytes,2,opt,name=instruction,proto3\" json:\"instruction,omitempty\"`                                                                         // Corresponds to Go's Instruction field\n\tProperties         map[string]*Definition `protobuf:\"bytes,3,rep,name=properties,proto3\" json:\"properties,omitempty\" protobuf_key:\"bytes,1,opt,name=key\" protobuf_val:\"bytes,2,opt,name=value\"` // Corresponds to Go's Properties field\n\tItems              *Definition            `protobuf:\"bytes,4,opt,name=items,proto3\" json:\"items,omitempty\"`                                                                                     // Corresponds to Go's Items field\n\tModel              string                 `protobuf:\"bytes,5,opt,name=model,proto3\" json:\"model,omitempty\"`                                                                                     // Corresponds to Go's ModelType field (as a string)\n\tProcessingOrder    []string               `protobuf:\"bytes,6,rep,name=processingOrder,proto3\" json:\"processingOrder,omitempty\"`                                                                 // Corresponds to Go's ProcessingOrder field\n\tSystemPrompt       string                 `protobuf:\"bytes,7,opt,name=systemPrompt,proto3\" json:\"systemPrompt,omitempty\"`                                                                       // Corresponds to Go's SystemPrompt field\n\tReq                *RequestFormat         `protobuf:\"bytes,8,opt,name=req,proto3\" json:\"req,omitempty\"`                                                                                         // Corresponds to Go's Req field\n\tNarrowFocus        *Focus                 `protobuf:\"bytes,9,opt,name=narrowFocus,proto3\" json:\"narrowFocus,omitempty\"`                                                                         // Corresponds to Go's NarrowFocus field\n\tImprovementProcess bool                   `protobuf:\"varint,10,opt,name=improvementProcess,proto3\" json:\"improvementProcess,omitempty\"`                                                         // Corresponds to Go's ImprovementProcess field\n\tSelectFields       []string               `protobuf:\"bytes,11,rep,name=selectFields,proto3\" json:\"selectFields,omitempty\"`                                                                      // Corresponds to Go's SelectFields field\n\tChoices            *Choices               `protobuf:\"bytes,12,opt,name=choices,proto3\" json:\"choices,omitempty\"`                                                                                // Corresponds to Go's Choices field\n\tVoters             bool                   `protobuf:\"varint,13,opt,name=voters,proto3\" json:\"voters,omitempty\"`                                                                                 // Corresponds to Go's Voters field\n\tHashMap            *HashMap               `protobuf:\"bytes,14,opt,name=hashMap,proto3\" json:\"hashMap,omitempty\"`                                                                                // Corresponds to Go's HashMap field\n\tTextToSpeech       *TextToSpeech          `protobuf:\"bytes,15,opt,name=textToSpeech,proto3\" json:\"textToSpeech,omitempty\"`                                                                      // Corresponds to Go's Audio field\n\tSpeechToText       *SpeechToText          `protobuf:\"bytes,16,opt,name=speechToText,proto3\" json:\"speechToText,omitempty\"`                                                                      // Corresponds to Go's Speech field\n\tImage              *Image                 `protobuf:\"bytes,17,opt,name=image,proto3\" json:\"image,omitempty\"`                                                                                    // Corresponds to Go's Image field\n\tSendImage          *SendImage             `protobuf:\"bytes,18,opt,name=sendImage,proto3\" json:\"sendImage,omitempty\"`                                                                            // Corresponds to Go's SendImage field\n\tStream             bool                   `protobuf:\"varint,19,opt,name=stream,proto3\" json:\"stream,omitempty\"`\n\tTemp               float32                `protobuf:\"fixed32,20,opt,name=temp,proto3\" json:\"temp,omitempty\"`\n\tPriority           int32                  `protobuf:\"varint,21,opt,name=priority,proto3\" json:\"priority,omitempty\"`\n\tunknownFields      protoimpl.UnknownFields\n\tsizeCache          protoimpl.SizeCache\n}\n\nfunc (x *Definition) Reset() {\n\t*x = Definition{}\n\tmi := &file_objectweaver_proto_msgTypes[0]\n\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\tms.StoreMessageInfo(mi)\n}\n\nfunc (x *Definition) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*Definition) ProtoMessage() {}\n\nfunc (x *Definition) ProtoReflect() protoreflect.Message {\n\tmi := &file_objectweaver_proto_msgTypes[0]\n\tif x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use Definition.ProtoReflect.Descriptor instead.\nfunc (*Definition) Descriptor() ([]byte, []int) {\n\treturn file_objectweaver_proto_rawDescGZIP(), []int{0}\n}\n\nfunc (x *Definition) GetType() string {\n\tif x != nil {\n\t\treturn x.Type\n\t}\n\treturn \"\"\n}\n\nfunc (x *Definition) GetInstruction() string {\n\tif x != nil {\n\t\treturn x.Instruction\n\t}\n\treturn \"\"\n}\n\nfunc (x *Definition) GetProperties() map[string]*Definition {\n\tif x != nil {\n\t\treturn x.Properties\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetItems() *Definition {\n\tif x != nil {\n\t\treturn x.Items\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetModel() string {\n\tif x != nil {\n\t\treturn x.Model\n\t}\n\treturn \"\"\n}\n\nfunc (x *Definition) GetProcessingOrder() []string {\n\tif x != nil {\n\t\treturn x.ProcessingOrder\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetSystemPrompt() string {\n\tif x != nil {\n\t\treturn x.SystemPrompt\n\t}\n\treturn \"\"\n}\n\nfunc (x *Definition) GetReq() *RequestFormat {\n\tif x != nil {\n\t\treturn x.Req\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetNarrowFocus() *Focus {\n\tif x != nil {\n\t\treturn x.NarrowFocus\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetImprovementProcess() bool {\n\tif x != nil {\n\t\treturn x.ImprovementProcess\n\t}\n\treturn false\n}\n\nfunc (x *Definition) GetSelectFields() []string {\n\tif x != nil {\n\t\treturn x.SelectFields\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetChoices() *Choices {\n\tif x != nil {\n\t\treturn x.Choices\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetVoters() bool {\n\tif x != nil {\n\t\treturn x.Voters\n\t}\n\treturn false\n}\n\nfunc (x *Definition) GetHashMap() *HashMap {\n\tif x != nil {\n\t\treturn x.HashMap\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetTextToSpeech() *TextToSpeech {\n\tif x != nil {\n\t\treturn x.TextToSpeech\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetSpeechToText() *SpeechToText {\n\tif x != nil {\n\t\treturn x.SpeechToText\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetImage() *Image {\n\tif x != nil {\n\t\treturn x.Image\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetSendImage() *SendImage {\n\tif x != nil {\n\t\treturn x.SendImage\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetStream() bool {\n\tif x != nil {\n\t\treturn x.Stream\n\t}\n\treturn false\n}\n\nfunc (x *Definition) GetTemp() float32 {\n\tif x != nil {\n\t\treturn x.Temp\n\t}\n\treturn 0\n}\n\nfunc (x *Definition) GetPriority() int32 {\n\tif x != nil {\n\t\treturn x.Priority\n\t}\n\treturn 0\n}\n\n// Audio message\ntype TextToSpeech struct {\n\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n\tModel         string                 `protobuf:\"bytes,1,opt,name=model,proto3\" json:\"model,omitempty\"`                 // Corresponds to Go's TextToSpeechModel field\n\tStringToAudio string                 `protobuf:\"bytes,2,opt,name=stringToAudio,proto3\" json:\"stringToAudio,omitempty\"` // Corresponds to Go's StringToAudio field\n\tFormat        string                 `protobuf:\"bytes,3,opt,name=format,proto3\" json:\"format,omitempty\"`               // Corresponds to Go's Format field\n\tVoice         string                 `protobuf:\"bytes,4,opt,name=voice,proto3\" json:\"voice,omitempty\"`                 // Corresponds to Go's Voice field\n\tunknownFields protoimpl.UnknownFields\n\tsizeCache     protoimpl.SizeCache\n}\n\nfunc (x *TextToSpeech) Reset() {\n\t*x = TextToSpeech{}\n\tmi := &file_objectweaver_proto_msgTypes[1]\n\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\tms.StoreMessageInfo(mi)\n}\n\nfunc (x *TextToSpeech) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*TextToSpeech) ProtoMessage() {}\n\nfunc (x *TextToSpeech) ProtoReflect() protoreflect.Message {\n\tmi := &file_objectweaver_proto_msgTypes[1]\n\tif x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use TextToSpeech.ProtoReflect.Descriptor instead.\nfunc (*TextToSpeech) Descriptor() ([]byte, []int) {\n\treturn file_objectweaver_proto_rawDescGZIP(), []int{1}\n}\n\nfunc (x *TextToSpeech) GetModel() string {\n\tif x != nil {\n\t\treturn x.Model\n\t}\n\treturn \"\"\n}\n\nfunc (x *TextToSpeech) GetStringToAudio() string {\n\tif x != nil {\n\t\treturn x.StringToAudio\n\t}\n\treturn \"\"\n}\n\nfunc (x *TextToSpeech) GetFormat() string {\n\tif x != nil {\n\t\treturn x.Format\n\t}\n\treturn \"\"\n}\n\nfunc (x *TextToSpeech) GetVoice() string {\n\tif x != nil {\n\t\treturn x.Voice\n\t}\n\treturn \"\"\n}\n\n// SpeechToText message\ntype SpeechToText struct {\n\tstate             protoimpl.MessageState `protogen:\"open.v1\"`\n\tModel             string                 `protobuf:\"bytes,1,opt,name=model,proto3\" json:\"model,omitempty\"`                         // Corresponds to Go's SpeechToTextModel field\n\tAudioToTranscribe []byte                 `protobuf:\"bytes,2,opt,name=audioToTranscribe,proto3\" json:\"audioToTranscribe,omitempty\"` // Corresponds to Go's AudioToTranscribe field\n\tLanguage          string                 `protobuf:\"bytes,3,opt,name=language,proto3\" json:\"language,omitempty\"`                   // Corresponds to Go's Language field\n\tFormat            string                 `protobuf:\"bytes,4,opt,name=format,proto3\" json:\"format,omitempty\"`                       // Corresponds to Go's Format field\n\tToString          bool                   `protobuf:\"varint,5,opt,name=toString,proto3\" json:\"toString,omitempty\"`                  // Corresponds to Go's ToString field\n\tToCaptions        bool                   `protobuf:\"varint,6,opt,name=toCaptions,proto3\" json:\"toCaptions,omitempty\"`              // Corresponds to Go's ToCaptions field\n\tunknownFields     protoimpl.UnknownFields\n\tsizeCache         protoimpl.SizeCache\n}\n\nfunc (x *SpeechToText) Reset() {\n\t*x = SpeechToText{}\n\tmi := &file_objectweaver_proto_msgTypes[2]\n\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\tms.StoreMessageInfo(mi)\n}\n\nfunc (x *SpeechToText) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SpeechToText) ProtoMessage() {}\n\nfunc (x *SpeechToText) ProtoReflect() protoreflect.Message {\n\tmi := &file_objectweaver_proto_msgTypes[2]\n\tif x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SpeechToText.ProtoReflect.Descriptor instead.\nfunc (*SpeechToText) Descriptor() ([]byte, []int) {\n\treturn file_objectweaver_proto_rawDescGZIP(), []int{2}\n}\n\nfunc (x *SpeechToText) GetModel() string {\n\tif x != nil {\n\t\treturn x.Model\n\t}\n\treturn \"\"\n}\n\nfunc (x *SpeechToText) GetAudioToTranscribe() []byte {\n\tif x != nil {\n\t\treturn x.AudioToTranscribe\n\t}\n\treturn nil\n}\n\nfunc (x *SpeechToText) GetLanguage() string {\n\tif x != nil {\n\t\treturn x.Language\n\t}\n\treturn \"\"\n}\n\nfunc (x *SpeechToText) GetFormat() string {\n\tif x != nil {\n\t\treturn x.Format\n\t}\n\treturn \"\"\n}\n\nfunc (x *SpeechToText) GetToString() bool {\n\tif x != nil {\n\t\treturn x.ToString\n\t}\n\treturn false\n}\n\nfunc (x *SpeechToText) GetToCaptions() bool {\n\tif x != nil {\n\t\treturn x.ToCaptions\n\t}\n\treturn false\n}\n\n// Image message\ntype Image struct {\n\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n\tModel         string                 `protobuf:\"bytes,1,opt,name=model,proto3\" json:\"model,omitempty\"` // Corresponds to Go's ImageModel field\n\tSize          string                 `protobuf:\"bytes,2,opt,name=size,proto3\" json:\"size,omitempty\"`   // Corresponds to Go's ImageSize field\n\tunknownFields protoimpl.UnknownFields\n\tsizeCache     protoimpl.SizeCache\n}\n\nfunc (x *Image) Reset() {\n\t*x = Image{}\n\tmi := &file_objectweaver_proto_msgTypes[3]\n\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\tms.StoreMessageInfo(mi)\n}\n\nfunc (x *Image) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*Image) ProtoMessage() {}\n\nfunc (x *Image) ProtoReflect() protoreflect.Message {\n\tmi := &file_objectweaver_proto_msgTypes[3]\n\tif x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use Image.ProtoReflect.Descriptor instead.\nfunc (*Image) Descriptor() ([]byte, []int) {\n\treturn file_objectweaver_proto_rawDescGZIP(), []int{3}\n}\n\nfunc (x *Image) GetModel() string {\n\tif x != nil {\n\t\treturn x.Model\n\t}\n\treturn \"\"\n}\n\nfunc (x *Image) GetSize() string {\n\tif x != nil {\n\t\treturn x.Size\n\t}\n\treturn \"\"\n}\n\n// Choices message\ntype Choices struct {\n\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n\tNumber        int32                  `protobuf:\"varint,1,opt,name=number,proto3\" json:\"number,omitempty\"`  // Corresponds to Go's Number field\n\tOptions       []string               `protobuf:\"bytes,2,rep,name=options,proto3\" json:\"options,omitempty\"` // Corresponds to Go's Options field\n\tunknownFields protoimpl.UnknownFields\n\tsizeCache     protoimpl.SizeCache\n}\n\nfunc (x *Choices) Reset() {\n\t*x = Choices{}\n\tmi := &file_objectweaver_proto_msgTypes[4]\n\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\tms.StoreMessageInfo(mi)\n}\n\nfunc (x *Choices) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*Choices) ProtoMessage() {}\n\nfunc (x *Choices) ProtoReflect() protoreflect.Message {\n\tmi := &file_objectweaver_proto_msgTypes[4]\n\tif x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use Choices.ProtoReflect.Descriptor instead.\nfunc (*Choices) Descriptor() ([]byte, []int) {\n\treturn file_objectweaver_proto_rawDescGZIP(), []int{4}\n}\n\nfunc (x *Choices) GetNumber() int32 {\n\tif x != nil {\n\t\treturn x.Number\n\t}\n\treturn 0\n}\n\nfunc (x *Choices) GetOptions() []string {\n\tif x != nil {\n\t\treturn x.Options\n\t}\n\treturn nil\n}\n\n// HashMap message\ntype HashMap struct {\n\tstate           protoimpl.MessageState `protogen:\"open.v1\"`\n\tKeyInstruction  string                 `protobuf:\"bytes,1,opt,name=keyInstruction,proto3\" json:\"keyInstruction,omitempty\"`   // Corresponds to Go's KeyInstruction field\n\tFieldDefinition *Definition            `protobuf:\"bytes,2,opt,name=fieldDefinition,proto3\" json:\"fieldDefinition,omitempty\"` // Corresponds to Go's FieldDefinition field\n\tunknownFields   protoimpl.UnknownFields\n\tsizeCache       protoimpl.SizeCache\n}\n\nfunc (x *HashMap) Reset() {\n\t*x = HashMap{}\n\tmi := &file_objectweaver_proto_msgTypes[5]\n\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\tms.StoreMessageInfo(mi)\n}\n\nfunc (x *HashMap) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*HashMap) ProtoMessage() {}\n\nfunc (x *HashMap) ProtoReflect() protoreflect.Message {\n\tmi := &file_objectweaver_proto_msgTypes[5]\n\tif x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use HashMap.ProtoReflect.Descriptor instead.\nfunc (*HashMap) Descriptor() ([]byte, []int) {\n\treturn file_objectweaver_proto_rawDescGZIP(), []int{5}\n}\n\nfunc (x *HashMap) GetKeyInstruction() string {\n\tif x != nil {\n\t\treturn x.KeyInstruction\n\t}\n\treturn \"\"\n}\n\nfunc (x *HashMap) GetFieldDefinition() *Definition {\n\tif x != nil {\n\t\treturn x.FieldDefinition\n\t}\n\treturn nil\n}\n\n// Focus message\ntype Focus struct {\n\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n\tPrompt        string                 `protobuf:\"bytes,1,opt,name=prompt,proto3\" json:\"prompt,omitempty\"`              // Corresponds to Go's Prompt field\n\tFields        []string               `protobuf:\"bytes,2,rep,name=fields,proto3\" json:\"fields,omitempty\"`              // Corresponds to Go's Fields field\n\tKeepOriginal  bool                   `protobuf:\"varint,3,opt,name=keepOriginal,proto3\" json:\"keepOriginal,omitempty\"` // Corresponds to Go's KeepOriginal field\n\tunknownFields protoimpl.UnknownFields\n\tsizeCache     protoimpl.SizeCache\n}\n\nfunc (x *Focus) Reset() {\n\t*x = Focus{}\n\tmi := &file_objectweaver_proto_msgTypes[6]\n\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\tms.StoreMessageInfo(mi)\n}\n\nfunc (x *Focus) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*Focus) ProtoMessage() {}\n\nfunc (x *Focus) ProtoReflect() protoreflect.Message {\n\tmi := &file_objectweaver_proto_msgTypes[6]\n\tif x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use Focus.ProtoReflect.Descriptor instead.\nfunc (*Focus) Descriptor() ([]byte, []int) {\n\treturn file_objectweaver_proto_rawDescGZIP(), []int{6}\n}\n\nfunc (x *Focus) GetPrompt() string {\n\tif x != nil {\n\t\treturn x.Prompt\n\t}\n\treturn \"\"\n}\n\nfunc (x *Focus) GetFields() []string {\n\tif x != nil {\n\t\treturn x.Fields\n\t}\n\treturn nil\n}\n\nfunc (x *Focus) GetKeepOriginal() bool {\n\tif x != nil {\n\t\treturn x.KeepOriginal\n\t}\n\treturn false\n}\n\n// SendImage message\ntype SendImage struct {\n\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n\tImagesData    [][]byte               `protobuf:\"bytes,1,rep,name=imagesData,proto3\" json:\"imagesData,omitempty\"`\n\tunknownFields protoimpl.UnknownFields\n\tsizeCache     protoimpl.SizeCache\n}\n\nfunc (x *SendImage) Reset() {\n\t*x = SendImage{}\n\tmi := &file_objectweaver_proto_msgTypes[7]\n\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\tms.StoreMessageInfo(mi)\n}\n\nfunc (x *SendImage) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SendImage) ProtoMessage() {}\n\nfunc (x *SendImage) ProtoReflect() protoreflect.Message {\n\tmi := &file_objectweaver_proto_msgTypes[7]\n\tif x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SendImage.ProtoReflect.Descriptor instead.\nfunc (*SendImage) Descriptor() ([]byte, []int) {\n\treturn file_objectweaver_proto_rawDescGZIP(), []int{7}\n}\n\nfunc (x *SendImage) GetImagesData() [][]byte {\n\tif x != nil {\n\t\treturn x.ImagesData\n\t}\n\treturn nil\n}\n\n// RequestFormat message\ntype RequestFormat struct {\n\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n\tUrl           string                 `protobuf:\"bytes,1,opt,name=url,proto3\" json:\"url,omitempty\"`\n\tMethod        string                 `protobuf:\"bytes,2,opt,name=method,proto3\" json:\"method,omitempty\"`\n\tHeaders       map[string]string      `protobuf:\"bytes,3,rep,name=headers,proto3\" json:\"headers,omitempty\" protobuf_key:\"bytes,1,opt,name=key\" protobuf_val:\"bytes,2,opt,name=value\"`\n\tBody          *structpb.Struct       `protobuf:\"bytes,4,opt,name=body,proto3\" json:\"body,omitempty\"` // This corresponds to Go's Body field as map[string]interface{}\n\tAuthorization string                 `protobuf:\"bytes,5,opt,name=authorization,proto3\" json:\"authorization,omitempty\"`\n\tRequireFields []string               `protobuf:\"bytes,6,rep,name=requireFields,proto3\" json:\"requireFields,omitempty\"`\n\tunknownFields protoimpl.UnknownFields\n\tsizeCache     protoimpl.SizeCache\n}\n\nfunc (x *RequestFormat) Reset() {\n\t*x = RequestFormat{}\n\tmi := &file_objectweaver_proto_msgTypes[8]\n\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\tms.StoreMessageInfo(mi)\n}\n\nfunc (x *RequestFormat) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*RequestFormat) ProtoMessage() {}\n\nfunc (x *RequestFormat) ProtoReflect() protoreflect.Message {\n\tmi := &file_objectweaver_proto_msgTypes[8]\n\tif x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use RequestFormat.ProtoReflect.Descriptor instead.\nfunc (*RequestFormat) Descriptor() ([]byte, []int) {\n\treturn file_objectweaver_proto_rawDescGZIP(), []int{8}\n}\n\nfunc (x *RequestFormat) GetUrl() string {\n\tif x != nil {\n\t\treturn x.Url\n\t}\n\treturn \"\"\n}\n\nfunc (x *RequestFormat) GetMethod() string {\n\tif x != nil {\n\t\treturn x.Method\n\t}\n\treturn \"\"\n}\n\nfunc (x *RequestFormat) GetHeaders() map[string]string {\n\tif x != nil {\n\t\treturn x.Headers\n\t}\n\treturn nil\n}\n\nfunc (x *RequestFormat) GetBody() *structpb.Struct {\n\tif x != nil {\n\t\treturn x.Body\n\t}\n\treturn nil\n}\n\nfunc (x *RequestFormat) GetAuthorization() string {\n\tif x != nil {\n\t\treturn x.Authorization\n\t}\n\treturn \"\"\n}\n\nfunc (x *RequestFormat) GetRequireFields() []string {\n\tif x != nil {\n\t\treturn x.RequireFields\n\t}\n\treturn nil\n}\n\n// RequestBody message for the GenerateObject RPC\ntype RequestBody struct {\n\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n\tPrompt        string                 `protobuf:\"bytes,1,opt,name=prompt,proto3\" json:\"prompt,omitempty\"`         // Corresponds to Go's Prompt field\n\tDefinition    *Definition            `protobuf:\"bytes,2,opt,name=definition,proto3\" json:\"definition,omitempty\"` // Corresponds to Go's Definition field\n\tunknownFields protoimpl.UnknownFields\n\tsizeCache     protoimpl.SizeCache\n}\n\nfunc (x *RequestBody) Reset() {\n\t*x = RequestBody{}\n\tmi := &file_objectweaver_proto_msgTypes[9]\n\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\tms.StoreMessageInfo(mi)\n}\n\nfunc (x *RequestBody) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*RequestBody) ProtoMessage() {}\n\nfunc (x *RequestBody) ProtoReflect() protoreflect.Message {\n\tmi := &file_objectweaver_proto_msgTypes[9]\n\tif x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use RequestBody.ProtoReflect.Descriptor instead.\nfunc (*RequestBody) Descriptor() ([]byte, []int) {\n\treturn file_objectweaver_proto_rawDescGZIP(), []int{9}\n}\n\nfunc (x *RequestBody) GetPrompt() string {\n\tif x != nil {\n\t\treturn x.Prompt\n\t}\n\treturn \"\"\n}\n\nfunc (x *RequestBody) GetDefinition() *Definition {\n\tif x != nil {\n\t\treturn x.Definition\n\t}\n\treturn nil\n}\n\n// Updated Response message for the GenerateObject RPC\ntype Response struct {\n\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n\tData          *structpb.Struct       `protobuf:\"bytes,1,opt,name=data,proto3\" json:\"data,omitempty\"` // Use Struct to hold a dynamic map<string, any>\n\tUsdCost       float64                `protobuf:\"fixed64,2,opt,name=usdCost,proto3\" json:\"usdCost,omitempty\"`\n\tunknownFields protoimpl.UnknownFields\n\tsizeCache     protoimpl.SizeCache\n}\n\nfunc (x *Response) Reset() {\n\t*x = Response{}\n\tmi := &file_objectweaver_proto_msgTypes[10]\n\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\tms.StoreMessageInfo(mi)\n}\n\nfunc (x *Response) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*Response) ProtoMessage() {}\n\nfunc (x *Response) ProtoReflect() protoreflect.Message {\n\tmi := &file_objectweaver_proto_msgTypes[10]\n\tif x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use Response.ProtoReflect.Descriptor instead.\nfunc (*Response) Descriptor() ([]byte, []int) {\n\treturn file_objectweaver_proto_rawDescGZIP(), []int{10}\n}\n\nfunc (x *Response) GetData() *structpb.Struct {\n\tif x != nil {\n\t\treturn x.Data\n\t}\n\treturn nil\n}\n\nfunc (x *Response) GetUsdCost() float64 {\n\tif x != nil {\n\t\treturn x.UsdCost\n\t}\n\treturn 0\n}\n\n// StreamingResponse message for the stream method\ntype StreamingResponse struct {\n\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n\tData          *structpb.Struct       `protobuf:\"bytes,1,opt,name=data,proto3\" json:\"data,omitempty\"` // Same as above, using Struct for map<string, any>\n\tUsdCost       float64                `protobuf:\"fixed64,2,opt,name=usdCost,proto3\" json:\"usdCost,omitempty\"`\n\tStatus        string                 `protobuf:\"bytes,3,opt,name=status,proto3\" json:\"status,omitempty\"` // A status message for each streamed response\n\tunknownFields protoimpl.UnknownFields\n\tsizeCache     protoimpl.SizeCache\n}\n\nfunc (x *StreamingResponse) Reset() {\n\t*x = StreamingResponse{}\n\tmi := &file_objectweaver_proto_msgTypes[11]\n\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\tms.StoreMessageInfo(mi)\n}\n\nfunc (x *StreamingResponse) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*StreamingResponse) ProtoMessage() {}\n\nfunc (x *StreamingResponse) ProtoReflect() protoreflect.Message {\n\tmi := &file_objectweaver_proto_msgTypes[11]\n\tif x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use StreamingResponse.ProtoReflect.Descriptor instead.\nfunc (*StreamingResponse) Descriptor() ([]byte, []int) {\n\treturn file_objectweaver_proto_rawDescGZIP(), []int{11}\n}\n\nfunc (x *StreamingResponse) GetData() *structpb.Struct {\n\tif x != nil {\n\t\treturn x.Data\n\t}\n\treturn nil\n}\n\nfunc (x *StreamingResponse) GetUsdCost() float64 {\n\tif x != nil {\n\t\treturn x.UsdCost\n\t}\n\treturn 0\n}\n\nfunc (x *StreamingResponse) GetStatus() string {\n\tif x != nil {\n\t\treturn x.Status\n\t}\n\treturn \"\"\n}\n\nvar File_objectweaver_proto protoreflect.FileDescriptor\n\nconst file_objectweaver_proto_rawDesc = \"\" +\n\t\"\\n\" +\n\t\"\\x12objectweaver.proto\\x12\\n\" +\n\t\"jsonSchema\\x1a\\x19google/protobuf/any.proto\\x1a\\x1cgoogle/protobuf/struct.proto\\\"\\xc1\\a\\n\" +\n\t\"\\n\" +\n\t\"Definition\\x12\\x12\\n\" +\n\t\"\\x04type\\x18\\x01 \\x01(\\tR\\x04type\\x12 \\n\" +\n\t\"\\vinstruction\\x18\\x02 \\x01(\\tR\\vinstruction\\x12F\\n\" +\n\t\"\\n\" +\n\t\"properties\\x18\\x03 \\x03(\\v2&.jsonSchema.Definition.PropertiesEntryR\\n\" +\n\t\"properties\\x12,\\n\" +\n\t\"\\x05items\\x18\\x04 \\x01(\\v2\\x16.jsonSchema.DefinitionR\\x05items\\x12\\x14\\n\" +\n\t\"\\x05model\\x18\\x05 \\x01(\\tR\\x05model\\x12(\\n\" +\n\t\"\\x0fprocessingOrder\\x18\\x06 \\x03(\\tR\\x0fprocessingOrder\\x12\\\"\\n\" +\n\t\"\\fsystemPrompt\\x18\\a \\x01(\\tR\\fsystemPrompt\\x12+\\n\" +\n\t\"\\x03req\\x18\\b \\x01(\\v2\\x19.jsonSchema.RequestFormatR\\x03req\\x123\\n\" +\n\t\"\\vnarrowFocus\\x18\\t \\x01(\\v2\\x11.jsonSchema.FocusR\\vnarrowFocus\\x12.\\n\" +\n\t\"\\x12improvementProcess\\x18\\n\" +\n\t\" \\x01(\\bR\\x12improvementProcess\\x12\\\"\\n\" +\n\t\"\\fselectFields\\x18\\v \\x03(\\tR\\fselectFields\\x12-\\n\" +\n\t\"\\achoices\\x18\\f \\x01(\\v2\\x13.jsonSchema.ChoicesR\\achoices\\x12\\x16\\n\" +\n\t\"\\x06voters\\x18\\r \\x01(\\bR\\x06voters\\x12-\\n\" +\n\t\"\\ahashMap\\x18\\x0e \\x01(\\v2\\x13.jsonSchema.HashMapR\\ahashMap\\x12<\\n\" +\n\t\"\\ftextToSpeech\\x18\\x0f \\x01(\\v2\\x18.jsonSchema.TextToSpeechR\\ftextToSpeech\\x12<\\n\" +\n\t\"\\fspeechToText\\x18\\x10 \\x01(\\v2\\x18.jsonSchema.SpeechToTextR\\fspeechToText\\x12'\\n\" +\n\t\"\\x05image\\x18\\x11 \\x01(\\v2\\x11.jsonSchema.ImageR\\x05image\\x123\\n\" +\n\t\"\\tsendImage\\x18\\x12 \\x01(\\v2\\x15.jsonSchema.SendImageR\\tsendImage\\x12\\x16\\n\" +\n\t\"\\x06stream\\x18\\x13 \\x01(\\bR\\x06stream\\x12\\x12\\n\" +\n\t\"\\x04temp\\x18\\x14 \\x01(\\x02R\\x04temp\\x12\\x1a\\n\" +\n\t\"\\bpriority\\x18\\x15 \\x01(\\x05R\\bpriority\\x1aU\\n\" +\n\t\"\\x0fPropertiesEntry\\x12\\x10\\n\" +\n\t\"\\x03key\\x18\\x01 \\x01(\\tR\\x03key\\x12,\\n\" +\n\t\"\\x05value\\x18\\x02 \\x01(\\v2\\x16.jsonSchema.DefinitionR\\x05value:\\x028\\x01\\\"x\\n\" +\n\t\"\\fTextToSpeech\\x12\\x14\\n\" +\n\t\"\\x05model\\x18\\x01 \\x01(\\tR\\x05model\\x12$\\n\" +\n\t\"\\rstringToAudio\\x18\\x02 \\x01(\\tR\\rstringToAudio\\x12\\x16\\n\" +\n\t\"\\x06format\\x18\\x03 \\x01(\\tR\\x06format\\x12\\x14\\n\" +\n\t\"\\x05voice\\x18\\x04 \\x01(\\tR\\x05voice\\\"\\xc2\\x01\\n\" +\n\t\"\\fSpeechToText\\x12\\x14\\n\" +\n\t\"\\x05model\\x18\\x01 \\x01(\\tR\\x05model\\x12,\\n\" +\n\t\"\\x11audioToTranscribe\\x18\\x02 \\x01(\\fR\\x11audioToTranscribe\\x12\\x1a\\n\" +\n\t\"\\blanguage\\x18\\x03 \\x01(\\tR\\blanguage\\x12\\x16\\n\" +\n\t\"\\x06format\\x18\\x04 \\x01(\\tR\\x06format\\x12\\x1a\\n\" +\n\t\"\\btoString\\x18\\x05 \\x01(\\bR\\btoString\\x12\\x1e\\n\" +\n\t\"\\n\" +\n\t\"toCaptions\\x18\\x06 \\x01(\\bR\\n\" +\n\t\"toCaptions\\\"1\\n\" +\n\t\"\\x05Image\\x12\\x14\\n\" +\n\t\"\\x05model\\x18\\x01 \\x01(\\tR\\x05model\\x12\\x12\\n\" +\n\t\"\\x04size\\x18\\x02 \\x01(\\tR\\x04size\\\";\\n\" +\n\t\"\\aChoices\\x12\\x16\\n\" +\n\t\"\\x06number\\x18\\x01 \\x01(\\x05R\\x06number\\x12\\x18\\n\" +\n\t\"\\aoptions\\x18\\x02 \\x03(\\tR\\aoptions\\\"s\\n\" +\n\t\"\\aHashMap\\x12&\\n\" +\n\t\"\\x0ekeyInstruction\\x18\\x01 \\x01(\\tR\\x0ekeyInstruction\\x12@\\n\" +\n\t\"\\x0ffieldDefinition\\x18\\x02 \\x01(\\v2\\x16.jsonSchema.DefinitionR\\x0ffieldDefinition\\\"[\\n\" +\n\t\"\\x05Focus\\x12\\x16\\n\" +\n\t\"\\x06prompt\\x18\\x01 \\x01(\\tR\\x06prompt\\x12\\x16\\n\" +\n\t\"\\x06fields\\x18\\x02 \\x03(\\tR\\x06fields\\x12\\\"\\n\" +\n\t\"\\fkeepOriginal\\x18\\x03 \\x01(\\bR\\fkeepOriginal\\\"+\\n\" +\n\t\"\\tSendImage\\x12\\x1e\\n\" +\n\t\"\\n\" +\n\t\"imagesData\\x18\\x01 \\x03(\\fR\\n\" +\n\t\"imagesData\\\"\\xb0\\x02\\n\" +\n\t\"\\rRequestFormat\\x12\\x10\\n\" +\n\t\"\\x03url\\x18\\x01 \\x01(\\tR\\x03url\\x12\\x16\\n\" +\n\t\"\\x06method\\x18\\x02 \\x01(\\tR\\x06method\\x12@\\n\" +\n\t\"\\aheaders\\x18\\x03 \\x03(\\v2&.jsonSchema.RequestFormat.HeadersEntryR\\aheaders\\x12+\\n\" +\n\t\"\\x04body\\x18\\x04 \\x01(\\v2\\x17.google.protobuf.StructR\\x04body\\x12$\\n\" +\n\t\"\\rauthorization\\x18\\x05 \\x01(\\tR\\rauthorization\\x12$\\n\" +\n\t\"\\rrequireFields\\x18\\x06 \\x03(\\tR\\rrequireFields\\x1a:\\n\" +\n\t\"\\fHeadersEntry\\x12\\x10\\n\" +\n\t\"\\x03key\\x18\\x01 \\x01(\\tR\\x03key\\x12\\x14\\n\" +\n\t\"\\x05value\\x18\\x02 \\x01(\\tR\\x05value:\\x028\\x01\\\"]\\n\" +\n\t\"\\vRequestBody\\x12\\x16\\n\" +\n\t\"\\x06prompt\\x18\\x01 \\x01(\\tR\\x06prompt\\x126\\n\" +\n\t\"\\n\" +\n\t\"definition\\x18\\x02 \\x01(\\v2\\x16.jsonSchema.DefinitionR\\n\" +\n\t\"definition\\\"Q\\n\" +\n\t\"\\bResponse\\x12+\\n\" +\n\t\"\\x04data\\x18\\x01 \\x01(\\v2\\x17.google.protobuf.StructR\\x04data\\x12\\x18\\n\" +\n\t\"\\ausdCost\\x18\\x02 \\x01(\\x01R\\ausdCost\\\"r\\n\" +\n\t\"\\x11StreamingResponse\\x12+\\n\" +\n\t\"\\x04data\\x18\\x01 \\x01(\\v2\\x17.google.protobuf.StructR\\x04data\\x12\\x18\\n\" +\n\t\"\\ausdCost\\x18\\x02 \\x01(\\x01R\\ausdCost\\x12\\x16\\n\" +\n\t\"\\x06status\\x18\\x03 \\x01(\\tR\\x06status2\\xa8\\x01\\n\" +\n\t\"\\x11JSONSchemaService\\x12?\\n\" +\n\t\"\\x0eGenerateObject\\x12\\x17.jsonSchema.RequestBody\\x1a\\x14.jsonSchema.Response\\x12R\\n\" +\n\t\"\\x16StreamGeneratedObjects\\x12\\x17.jsonSchema.RequestBody\\x1a\\x1d.jsonSchema.StreamingResponse0\\x01B\\bZ\\x06./grpcb\\x06proto3\"\n\nvar (\n\tfile_objectweaver_proto_rawDescOnce sync.Once\n\tfile_objectweaver_proto_rawDescData []byte\n)\n\nfunc file_objectweaver_proto_rawDescGZIP() []byte {\n\tfile_objectweaver_proto_rawDescOnce.Do(func() {\n\t\tfile_objectweaver_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_objectweaver_proto_rawDesc), len(file_objectweaver_proto_rawDesc)))\n\t})\n\treturn file_objectweaver_proto_rawDescData\n}\n\nvar file_objectweaver_proto_msgTypes = make([]protoimpl.MessageInfo, 14)\nvar file_objectweaver_proto_goTypes = []any{\n\t(*Definition)(nil),        // 0: jsonSchema.Definition\n\t(*TextToSpeech)(nil),      // 1: jsonSchema.TextToSpeech\n\t(*SpeechToText)(nil),      // 2: jsonSchema.SpeechToText\n\t(*Image)(nil),             // 3: jsonSchema.Image\n\t(*Choices)(nil),           // 4: jsonSchema.Choices\n\t(*HashMap)(nil),           // 5: jsonSchema.HashMap\n\t(*Focus)(nil),             // 6: jsonSchema.Focus\n\t(*SendImage)(nil),         // 7: jsonSchema.SendImage\n\t(*RequestFormat)(nil),     // 8: jsonSchema.RequestFormat\n\t(*RequestBody)(nil),       // 9: jsonSchema.RequestBody\n\t(*Response)(nil),          // 10: jsonSchema.Response\n\t(*StreamingResponse)(nil), // 11: jsonSchema.StreamingResponse\n\tnil,                       // 12: jsonSchema.Definition.PropertiesEntry\n\tnil,                       // 13: jsonSchema.RequestFormat.HeadersEntry\n\t(*structpb.Struct)(nil),   // 14: google.protobuf.Struct\n}\nvar file_objectweaver_proto_depIdxs = []int32{\n\t12, // 0: jsonSchema.Definition.properties:type_name -> jsonSchema.Definition.PropertiesEntry\n\t0,  // 1: jsonSchema.Definition.items:type_name -> jsonSchema.Definition\n\t8,  // 2: jsonSchema.Definition.req:type_name -> jsonSchema.RequestFormat\n\t6,  // 3: jsonSchema.Definition.narrowFocus:type_name -> jsonSchema.Focus\n\t4,  // 4: jsonSchema.Definition.choices:type_name -> jsonSchema.Choices\n\t5,  // 5: jsonSchema.Definition.hashMap:type_name -> jsonSchema.HashMap\n\t1,  // 6: jsonSchema.Definition.textToSpeech:type_name -> jsonSchema.TextToSpeech\n\t2,  // 7: jsonSchema.Definition.speechToText:type_name -> jsonSchema.SpeechToText\n\t3,  // 8: jsonSchema.Definition.image:type_name -> jsonSchema.Image\n\t7,  // 9: jsonSchema.Definition.sendImage:type_name -> jsonSchema.SendImage\n\t0,  // 10: jsonSchema.HashMap.fieldDefinition:type_name -> jsonSchema.Definition\n\t13, // 11: jsonSchema.RequestFormat.headers:type_name -> jsonSchema.RequestFormat.HeadersEntry\n\t14, // 12: jsonSchema.RequestFormat.body:type_name -> google.protobuf.Struct\n\t0,  // 13: jsonSchema.RequestBody.definition:type_name -> jsonSchema.Definition\n\t14, // 14: jsonSchema.Response.data:type_name -> google.protobuf.Struct\n\t14, // 15: jsonSchema.StreamingResponse.data:type_name -> google.protobuf.Struct\n\t0,  // 16: jsonSchema.Definition.PropertiesEntry.value:type_name -> jsonSchema.Definition\n\t9,  // 17: jsonSchema.JSONSchemaService.GenerateObject:input_type -> jsonSchema.RequestBody\n\t9,  // 18: jsonSchema.JSONSchemaService.StreamGeneratedObjects:input_type -> jsonSchema.RequestBody\n\t10, // 19: jsonSchema.JSONSchemaService.GenerateObject:output_type -> jsonSchema.Response\n\t11, // 20: jsonSchema.JSONSchemaService.StreamGeneratedObjects:output_type -> jsonSchema.StreamingResponse\n\t19, // [19:21] is the sub-list for method output_type\n\t17, // [17:19] is the sub-list for method input_type\n\t17, // [17:17] is the sub-list for extension type_name\n\t17, // [17:17] is the sub-list for extension extendee\n\t0,  // [0:17] is the sub-list for field type_name\n}\n\nfunc init() { file_objectweaver_proto_init() }\nfunc file_objectweaver_proto_init() {\n\tif File_objectweaver_proto != nil {\n\t\treturn\n\t}\n\ttype x struct{}\n\tout := protoimpl.TypeBuilder{\n\t\tFile: protoimpl.DescBuilder{\n\t\t\tGoPackagePath: reflect.TypeOf(x{}).PkgPath(),\n\t\t\tRawDescriptor: unsafe.Slice(unsafe.StringData(file_objectweaver_proto_rawDesc), len(file_objectweaver_proto_rawDesc)),\n\t\t\tNumEnums:      0,\n\t\t\tNumMessages:   14,\n\t\t\tNumExtensions: 0,\n\t\t\tNumServices:   1,\n\t\t},\n\t\tGoTypes:           file_objectweaver_proto_goTypes,\n\t\tDependencyIndexes: file_objectweaver_proto_depIdxs,\n\t\tMessageInfos:      file_objectweaver_proto_msgTypes,\n\t}.Build()\n\tFile_objectweaver_proto = out.File\n\tfile_objectweaver_proto_goTypes = nil\n\tfile_objectweaver_proto_depIdxs = nil\n}\n","reason":"Modified","start":1,"end":1076,"grade":"A+"}]},"hash":"92460924d622319b7895734dc6bdc174c45a72d9062f5a06d2c6296c7ccb2d70","id":"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"}
{"assessingTool":"SOLID","filePath":"grpc/object-generation_grpc.pb.go","grade":"A+","username":"HLamb","timestamp":"2025-10-21T17:58:28.084Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"dependencyInversionScore":"A+","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"A+","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"oldCode":"// source: object-generation.proto","newCode":"// source: objectweaver.proto","reason":"Modified","start":5,"end":5,"grade":"A+"},{"oldCode":"\tMetadata: \"object-generation.proto\",","newCode":"\tMetadata: \"objectweaver.proto\",","reason":"Modified","start":170,"end":170,"grade":"A+"}]},"hash":"4a9b986c608bfd705e51ba40d83370f5c3088e21c65ef1657506e44ecad158db","id":"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"}
{"assessingTool":"Complexity","filePath":"jsonSchema/toolModel.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:11:13.290Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"linesOfCode","violatingCode":"The SubordinateFunction struct is concise, but the linesOfCode principle is undermined by embedding a pointer to another complex type, which can lead to hidden verbosity and maintenance challenges.\n\n```go\ntype SubordinateFunction struct {\n\tName       string      `json:\"name\"`\n\tDefinition *Definition `json:\"definition\"`\n}\n```","codeResolution":"The current implementation can be streamlined by delegating the operation logic to an abstraction, reducing lines of code and improving maintainability. Replace the original block with the following concise approach:\n\n```go\n// Go\nfunc ExecuteOperation(opType string, a, b int) int {\n\top := getOperation(opType)\n\treturn op.Apply(a, b)\n}\n```","severity":"Critical","rationale":"This implementation disregards linesOfCode best practices by combining data structure definition and documentation in a single block (lines 3–10). While concise, this approach can hinder maintainability as future changes to the struct or its comments may introduce inconsistencies. Additionally, the lack of separation between concerns (e.g., no validation or constructor logic) means any expansion will likely increase code complexity and line count, making the code harder to test and refactor. Adhering to linesOfCode principles—such as modularizing responsibilities and minimizing unnecessary lines—would improve clarity and scalability.","lineStart":3,"lineEnd":5,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The SubordinateFunction struct is simple and does not violate cyclomaticComplexity principles; there is no branching logic present.\n\n```go\ntype SubordinateFunction struct {\n\tName       string      `json:\"name\"`\n\tDefinition *Definition `json:\"definition\"`\n}\n```","codeResolution":"The solution for cyclomatic complexity involves refactoring deeply nested or multi-branch logic into simple, single-responsibility abstractions. Here is the replacement code for the block identified in `violatingCode`, assuming all helper abstractions are already defined:\n\n```go\n// Go\nop := getOperation(subordinateFunc.Name)\nresult := op.Execute(subordinateFunc.Definition)\nreturn result\n```","severity":"Critical","rationale":"High cyclomatic complexity in this code would make future changes risky and error-prone. If the SubordinateFunction struct or its usage involved deeply nested logic or multiple branching paths, it would be difficult to test all scenarios, increasing the likelihood of missed edge cases and bugs. Excessive complexity also hinders readability, making onboarding and code reviews harder. By simplifying control flow and breaking logic into smaller, focused functions, maintainability and correctness are improved, and the risk of regressions is reduced.","lineStart":7,"lineEnd":6,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The SubordinateFunction struct is simple and does not violate nestingDepth principles; there are no nested control structures present.\n\n```go\ntype SubordinateFunction struct {\n\tName       string      `json:\"name\"`\n\tDefinition *Definition `json:\"definition\"`\n}\n```","codeResolution":"Reducing nesting depth in SubordinateFunction logic improves readability and maintainability by delegating responsibilities to helper abstractions.\n\n```go\n// Instead of deeply nested logic, delegate to a helper for validation and processing.\nfunc (sf *SubordinateFunction) Process() error {\n\tif err := validateDefinition(sf.Definition); err != nil {\n\t\treturn err\n\t}\n\treturn processResponses(sf.Name, sf.Definition)\n}\n```","severity":"Critical","rationale":"Excessive nestingDepth in this code can make future changes error-prone and difficult to test. If logic for handling subordinate functions is deeply nested (e.g., multiple if-else or switch statements within methods), it increases cognitive load and obscures the core functionality. This reduces readability and maintainability, making it harder for developers to trace bugs or extend features. Flattening the structure—such as using guard clauses or splitting responsibilities into smaller functions—would improve clarity and reliability.","lineStart":1,"lineEnd":7,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode fails to separate responsibilities, resulting in a single struct definition with no supporting functions or methods.\n\n```go\ntype SubordinateFunction struct {\n\tName       string      `json:\"name\"`\n\tDefinition *Definition `json:\"definition\"`\n}\n```","codeResolution":"The SubordinateFunction struct's handling can be improved by delegating schema validation and response formatting to dedicated functions, enhancing separation of concerns and maintainability.\n\n```go\n// Improved usage of SubordinateFunction with abstraction\nfunc (sf *SubordinateFunction) Process(input interface{}) (interface{}, error) {\n\tif err := validateDefinition(sf.Definition, input); err != nil {\n\t\treturn nil, err\n\t}\n\treturn formatResponse(sf.Name, input), nil\n}\n```","severity":"Critical","rationale":"This code violates functionMethodCounts principles by defining only a single struct and no functions or methods. Without dedicated functions for tasks like validation, serialization, or business logic, the code becomes difficult to extend and maintain. The absence of methods means that any future logic will likely be added in a monolithic fashion, increasing the risk of errors and making unit testing challenging. Introducing separate methods for responsibilities such as schema validation or JSON marshaling would improve modularity and maintainability.","lineStart":5,"lineEnd":5,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A","readability":"A","testability":"A-"},"issues":{"cyclomaticComplexity":1,"dependenciesModules":0,"functionMethodCounts":1,"linesOfCode":8,"nestingDepth":1}},"hash":"f9d20818d128085cef8a9f9021d4f2ef55931756a808d9ce9cb272e358df1f3f","id":"eJxtkDFrw0AMhf+K0FIoJt69lZRCh5ZCMt6Q651sX3uWzEmGhpD/XuzGSYZqEkL63ns6oVcl1cTdXiRjg1sZxkw/yY5YYZBIW2EjNmxw9OHbdwRfKrwLPQ3eseO6ht30KSUm9kYvEwdLwlBoLKTEpuChXacTRypgPcHT64NCELYiuYLEIU8xcQfJFNgPVEGkNnGazyrwHKGQjsJKunFsx5H+lVUrUzA4OXb27geCv1IrM3ypw+y/cTirODxcNuoa9j0t0iDtYlFv/GuCzQx+vjqDx7t+Bd+Mz/gLWJeH3YVaVe7IZ8dYYZsyfXjrscHbp2sTyW8SKW86wfMvD7mciA=="}
{"assessingTool":"SOLID","filePath":"jsonSchema/toolModel.go","grade":"A+","username":"HLamb","timestamp":"2025-10-12T17:10:45.191Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"dependencyInversionScore":"A+","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"A+","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package jsonSchema\n\n// SubordinateFunction represents a function under the AI's control, including its name, definition, and responses.\ntype SubordinateFunction struct {\n\tName       string      `json:\"name\"`       // The name of the subordinate function.\n\tDefinition *Definition `json:\"definition\"` // The schema definition of the function.\n}\n","reason":"Modified","start":1,"end":8,"grade":"A+"}]},"hash":"31500b5280e5d78fbffd03cb923d04bbb54a5be936fe452b32764ebcbfe6cb80","id":"eJxtkD9rw0AMxb+K0FIoJt69lYZCoP8gGW/I9U62L7Ulc5KHEvLdi9048VBNQki/957O6FVJNXFzEOmwwv3H626LBQaJ9CxsxIYVDj58+4bgpML70FLvHTsuS9iPX5JjYm/0MnKwJAyZhkxKbAoe6mU6cqQM1hI87R4UgrBl6QpIHLoxJm4gmQL7ngqIVCdO01kBniNk0kFYSTeO7Wegf2XV8hgMzo6dvfue4K/U8gSf6zj5rxxOKg6P142yhENLszRIPVvUO/+WYDOBtzdn8LjqF/Dd+IS/gnV+2CrUorIiXxxjgXXq6NNbixXeP12aSPcmkbpNI3j5BYVDmdU="}
{"assessingTool":"Complexity","filePath":"jsonSchema/toMap.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:11:11.809Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode fails functionMethodCounts by placing all logic into a single method, making it difficult to maintain and extend.\n\n```go\nfunc (d Definition) ToMap() map[string]interface{} {\n\tresult := make(map[string]interface{})\n\t// ... all conversion logic is here ...\n\treturn result\n}\n```","codeResolution":"The ToMap method in the Definition struct centralizes multiple responsibilities, making the code harder to maintain and extend. Refactoring is needed to delegate each conversion step to specialized helper functions, improving separation of concerns and readability.\n\n```go\n// Improved ToMap using helper abstractions\nfunc (d Definition) ToMap() map[string]interface{} {\n\tresult := make(map[string]interface{})\n\taddType(result, d.Type)\n\taddInstruction(result, d.Instruction)\n\taddProperties(result, d.Properties)\n\taddItems(result, d.Items)\n\taddModel(result, d.Model)\n\taddProcessingOrder(result, d.ProcessingOrder)\n\treturn result\n}\n```","severity":"Critical","rationale":"The code defines only one function, ToMap, which handles all logic for converting a Definition to a map. This violates functionMethodCounts principles by combining multiple responsibilities—such as handling properties, items, and metadata—into a single method. Such monolithic design makes the code harder to maintain, test, and extend. For example, changes to how properties are processed would require modifying ToMap directly, increasing the risk of introducing bugs. Splitting logic into smaller, focused functions (e.g., separate methods for properties and items) would improve modularity and maintainability.","lineStart":3,"lineEnd":22,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The ToMap function contains excessive vertical repetition and deep nesting, resulting in unnecessarily high linesOfCode and reduced maintainability.\n\n```go\nif d.Properties != nil && len(d.Properties) > 0 {\n\tpropertiesMap := make(map[string]interface{})\n\tfor key, value := range d.Properties {\n\t\tpropertiesMap[key] = value.ToMap()\n\t}\n}\n```","codeResolution":"The ToMap function can be streamlined by delegating property and item conversions to helper abstractions, reducing lines of code and improving clarity.\n\n```go\nfunc (d Definition) ToMap() map[string]interface{} {\n\tresult := make(map[string]interface{})\n\tsetIfNotEmpty(result, \"type\", d.Type)\n\tsetIfNotEmpty(result, \"instruction\", d.Instruction)\n\tsetIfNotNil(result, \"properties\", convertProperties(d.Properties))\n\tsetIfNotNil(result, \"items\", convertItem(d.Items))\n\tsetIfNotEmpty(result, \"model\", d.Model)\n\tsetIfNotEmptySlice(result, \"processingOrder\", d.ProcessingOrder)\n\treturn result\n}\n```","severity":"Critical","rationale":"The rationale for linesOfCode in this snippet centers on maintainability and clarity. The function is lengthy and contains repeated conditional blocks, which increases the cognitive load for future readers and maintainers. For example, the repeated pattern of checking fields and populating the map could be abstracted or split into helper functions, reducing duplication and improving readability. Excess lines also make unit testing and debugging harder, as logic is tightly coupled in a single function. Streamlining the code would enhance maintainability and reduce the risk of errors.","lineStart":7,"lineEnd":18,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The ToMap function disregards cyclomatic complexity principles by using multiple nested conditionals and loops, making the code harder to test and maintain.\n\n```go\nif d.Properties != nil && len(d.Properties) > 0 {\n\tpropertiesMap := make(map[string]interface{})\n\tfor key, value := range d.Properties {\n\t\tpropertiesMap[key] = value.ToMap()\n\t}\n}\n```","codeResolution":"The ToMap function’s cyclomatic complexity can be reduced by delegating property and item mapping to helper functions, improving readability and maintainability.\n\n```go\n// Improved ToMap using helper abstractions for properties and items\nfunc (d Definition) ToMap() map[string]interface{} {\n\tresult := make(map[string]interface{})\n\taddBasicFields(result, d)\n\taddProperties(result, d.Properties)\n\taddItems(result, d.Items)\n\treturn result\n}\n```","severity":"Critical","rationale":"The cyclomatic complexity in this function is elevated due to multiple independent conditional branches (lines 6–22), each checking different struct fields. This increases the number of possible execution paths, making the code harder to maintain and test. If new fields are added, the complexity will grow linearly, further impacting readability and maintainability. Refactoring by grouping related conditions or extracting logic into helper functions would reduce complexity, improve testability, and make future changes less error-prone.","lineStart":13,"lineEnd":22,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The ToMap function exhibits excessive nestingDepth, making the logic harder to follow and maintain.\n\n```go\nif d.Properties != nil && len(d.Properties) > 0 {\n    propertiesMap := make(map[string]interface{})\n    for key, value := range d.Properties {\n        propertiesMap[key] = value.ToMap()\n    }\n    result[\"properties\"] = propertiesMap\n}\n```","codeResolution":"The ToMap function’s nesting can be reduced by extracting property and item conversions into helper functions, resulting in clearer, flatter code:\n\n```go\n// Replacement for the deeply nested block in ToMap\nif d.Properties != nil && len(d.Properties) > 0 {\n\tresult[\"properties\"] = convertProperties(d.Properties)\n}\nif d.Items != nil {\n\tresult[\"items\"] = convertItem(d.Items)\n}\n```","severity":"Critical","rationale":"The nesting depth in this implementation is moderate, but the repeated use of nested if-statements and a for-loop inside another if-statement (lines 10–18) increases cognitive complexity. This structure makes the function harder to read and maintain, especially as more fields are added. Deep nesting can obscure the core logic, making future changes error-prone and unit testing more difficult. Refactoring with guard clauses or splitting responsibilities into helper functions would flatten the structure, improving maintainability and reducing the risk of bugs.","lineStart":9,"lineEnd":22,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A","testability":"A-"},"issues":{"cyclomaticComplexity":6,"dependenciesModules":0,"functionMethodCounts":1,"linesOfCode":32,"nestingDepth":3}},"hash":"02ebbcd8ecf0adfb023a3d2fecbe49760f950b857bfc2b228804759413df7689","id":"eJyFk81uwjAQhF9l6wNKJAQ9I9ELvfSAilRumIOVbIJLsrbsDWqE8u6VCfmjrXpMdubbzNi5CuU9eq8p3xtTiJXYmNIW+KW5FnORmBQ3hhiJxUpYlZxVjvDpDX0kJyyVJEnLJezNVllIDF3QsQc+IbxipkmzNgSeXZUwsAEFpbLg0Dr0SKzCWFJWUQJROrLELTGKg/7g2WnKj5oYXaYSvDZwlSTZoa8KhtUaSnXG6HdpHD5Rss4gXexri/C0BimkaBEd5CAF1xalOML6Lgzjpre+UZsi5PmLoAdNBxrZprydMxYda/QBR7qA2QwKpGg8iuEFnrs1tn8duv4/NEvOjIMz1nO4qKLC4HGKcpyuv+MfFhzOWIcIN+fifhqtsnmIPfja1BPOQ4uMZR/4R31h2BcXHsZ7B8jWpFj8eQhlmHaUm3Ts7htO2jv/7lJ0k5rHscaiDvng7eC368iVI2gBkhpJYi4yXeBO8UmsxPDXLDnkWuRGNN+4HkV5"}
{"assessingTool":"SOLID","filePath":"jsonSchema/toMap.go","grade":"C+","username":"HLamb","timestamp":"2025-10-12T17:10:56.521Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"openClosed","violatingCode":"The ToMap function violates openClosed by requiring modification whenever new Definition fields are added.\n\n```go\nif d.Model != \"\" {\n    result[\"model\"] = d.Model\n}\nif len(d.ProcessingOrder) > 0 {\n    result[\"processingOrder\"] = d.ProcessingOrder\n}\n```","codeResolution":"The current ToMap method can be refactored to utilize an Operation abstraction, allowing new mapping behaviors to be added without modifying this function.\n\n```go\ngo\nfunc (d Definition) ToMap() map[string]interface{} {\n\top := getOperation(\"definitionToMap\")\n\treturn op.Execute(d)\n}\n```","severity":"High","rationale":"The current implementation tightly couples the conversion logic to the Definition struct’s fields, violating the Open/Closed Principle. Any addition of new fields to Definition requires modifying the ToMap function directly (e.g., adding new if statements for each field). This approach reduces maintainability, as future changes force edits to existing code, increasing the risk of introducing bugs. It also limits extensibility, since developers cannot add new behaviors without altering core logic. Refactoring to use interfaces or reflection could allow new fields to be handled automatically, improving adherence to openClosed and making the codebase easier to extend and maintain.","lineStart":1,"lineEnd":22,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The ToMap method directly constructs and returns a map without any abstraction or interface, violating dependency inversion by tightly coupling the conversion logic to the Definition struct.\n\n```go\nfunc (d Definition) ToMap() map[string]interface{} {\n\tresult := make(map[string]interface{})\n\t// ...\n\treturn result\n}\n```","codeResolution":"The ToMap method should delegate property conversion to an injected abstraction, promoting dependency inversion and testability.\n\n```go\n// Go\nif d.Properties != nil && len(d.Properties) > 0 {\n    propertiesMap := make(map[string]interface{})\n    for key, value := range d.Properties {\n        propertiesMap[key] = propertyConverter.Convert(value)\n    }\n    result[\"properties\"] = propertiesMap\n}\n```","severity":"Critical","rationale":"This implementation tightly couples the ToMap logic directly to the Definition struct, violating dependency inversion principles. By embedding conversion logic within the struct, it becomes difficult to extend or test alternative mapping strategies without modifying the core type. This reduces maintainability and flexibility, as any changes to mapping behavior require direct changes to Definition. Introducing an abstraction, such as a Mapper interface, would decouple the conversion logic, making the codebase easier to test, extend, and maintain.","lineStart":1,"lineEnd":22,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"C-","singleResponsibilityScore":"A-"},"codeDiff":{"changes":[{"newCode":"package jsonSchema\n\n// ToMap converts the Definition struct to a map representation\nfunc (d Definition) ToMap() map[string]interface{} {\n\tresult := make(map[string]interface{})\n\n\tif d.Type != \"\" {\n\t\tresult[\"type\"] = d.Type\n\t}\n\tif d.Instruction != \"\" {\n\t\tresult[\"instruction\"] = d.Instruction\n\t}\n\tif d.Properties != nil && len(d.Properties) > 0 {\n\t\tpropertiesMap := make(map[string]interface{})\n\t\tfor key, value := range d.Properties {\n\t\t\tpropertiesMap[key] = value.ToMap()\n\t\t}\n\t\tresult[\"properties\"] = propertiesMap\n\t}\n\tif d.Items != nil {\n\t\tresult[\"items\"] = d.Items.ToMap()\n\t}\n\tif d.Model != \"\" {\n\t\tresult[\"model\"] = d.Model\n\t}\n\tif len(d.ProcessingOrder) > 0 {\n\t\tresult[\"processingOrder\"] = d.ProcessingOrder\n\t}\n\n\treturn result\n}\n","reason":"Modified","start":1,"end":32,"grade":"C+"}]},"hash":"d7b582b5fb54d1d7c1ad998c853e8d762d56cda8fa8ce60f548942ec16642e12","id":"eJyFk0+LwjAQxb/KbA6iILpnwb2sF2FFQW/GQ0inNdt2UpKpINLvvsTaf+7KHtt57zd9L+lNKO/Re0PJwdpMLMR++7VeianQNsJPS4zEYiEKpVOVIHx7S3t9xlxJkjSfw8FuVAHa0gUde+AzwgpjQ4aNJfDsSs3AFhTkqgCHhUOPxCqMJcUlaRhHPcukJo4nQX/07AwlJ0OMLlYabxXcJEl26MuMYbGEXKU4/ls6CZ8o2cQQzQ7XAuFtCVJIUSMayFEKvhYoxQmWD2EYV611TXWKkOcVwXSaBtSzDXk7Zwt0bNAHHJkMRiPIkMb90QQ+4L1ZU7SvQ9f/h2bJsXWQ4nUKF5WVGDxOUYLD9Q/804JjitcQ4e6cPU6jVlZPsTtfnXrAeWqRMW8D/6ovDNviwkN/bwfZ2Aizl4eQh2lDuUv77rZhXV/3rYvQDWrux+qLGuSTt4HfryOXjqAGSKokiamITYY7xWexEN1fM+eQa5ZYUf0AXpRCxg=="}
{"assessingTool":"Complexity","filePath":"jsonSchema/toJson.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:11:09.043Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode contains only one function, causing all responsibilities to be handled within a single method and violating functionMethodCounts best practices.\n\n```go\nfunc (d Definition) MarshalJSON() ([]byte, error) {\n\tif d.Properties == nil {\n\t\td.Properties = make(map[string]Definition)\n\t}\n\ttype Alias Definition\n\treturn json.Marshal(struct {\n\t\tAlias\n\t}{\n\t\tAlias: (Alias)(d),\n\t})\n}\n```","codeResolution":"The MarshalJSON method should delegate property initialization to a dedicated helper, improving separation of concerns and functionMethodCounts:\n\n```go\npackage jsonSchema\n\nimport \"encoding/json\"\n\nfunc (d Definition) MarshalJSON() ([]byte, error) {\n\tinitializeProperties(&d)\n\ttype Alias Definition\n\treturn json.Marshal(struct {\n\t\tAlias\n\t}{\n\t\tAlias: (Alias)(d),\n\t})\n}\n```","severity":"Critical","rationale":"This code violates functionMethodCounts principles by placing all logic within a single method, `MarshalJSON`. With no separation of concerns, future changes or bug fixes will require editing this monolithic function, increasing the risk of introducing errors. The lack of helper functions makes unit testing difficult, as individual behaviors cannot be isolated. Maintainability suffers because developers must understand the entire method to make even minor changes. Refactoring to extract property initialization and JSON marshaling into separate functions would improve clarity and testability.","lineStart":3,"lineEnd":10,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code adheres to dependenciesModules principles, using only the standard \"encoding/json\" package without introducing unnecessary dependencies.\n\n```go\nimport \"encoding/json\"\n```","codeResolution":"The codeResolution introduces a cleaner approach to dependency management by leveraging existing abstractions for operations, ensuring modularity and separation of concerns.\n\n```go\n// Replaces direct logic with abstraction usage\nfunc (d Definition) MarshalJSON() ([]byte, error) {\n\top := getOperation(\"marshalJSON\")\n\treturn op.Execute(d)\n}\n```","severity":"Critical","rationale":"This implementation adheres to dependenciesModules principles by only importing the standard \"encoding/json\" package, which is necessary for JSON marshaling. There are no unnecessary or redundant imports, reducing the risk of dependency bloat and improving maintainability. Keeping external dependencies minimal ensures better performance, easier upgrades, and fewer compatibility issues. However, if future features require additional packages, care should be taken to evaluate their necessity to avoid complicating the codebase.","lineStart":1,"lineEnd":7,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The MarshalJSON method unnecessarily increases nestingDepth by embedding logic for property initialization and type aliasing within a single function.\n\n```go\nif d.Properties == nil {\n\td.Properties = make(map[string]Definition)\n}\ntype Alias Definition\n```","codeResolution":"Reducing nesting depth in the MarshalJSON method improves readability and maintainability by using guard clauses and flattening control flow.\n\n```go\npackage jsonSchema\n\nimport \"encoding/json\"\n\nfunc (d Definition) MarshalJSON() ([]byte, error) {\n\tif d.Properties == nil {\n\t\td.Properties = make(map[string]Definition)\n\t}\n\treturn json.Marshal(struct{ Alias Definition }{Alias: d})\n}\n```","severity":"Critical","rationale":"This implementation does not address nestingDepth concerns, as the function contains multiple levels of nesting within a single scope. While the current depth is manageable, further logic additions could quickly increase complexity, making the code harder to read and maintain. Deeply nested structures hinder testability and increase the risk of subtle bugs, especially if future requirements expand the function. Refactoring with guard clauses or splitting responsibilities into smaller functions would improve maintainability and reduce cognitive load.","lineStart":6,"lineEnd":8,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The MarshalJSON function disregards cyclomaticComplexity principles by introducing unnecessary conditional logic that increases branching.\n\n```go\nif d.Properties == nil {\n\td.Properties = make(map[string]Definition)\n}\n```","codeResolution":"To address cyclomatic complexity, the solution refactors the conditional logic into a dedicated abstraction, simplifying the main function and improving maintainability.\n\n```go\nfunc (d Definition) MarshalJSON() ([]byte, error) {\n\tprepareProperties(&d)\n\treturn marshalAlias(d)\n}\n```","severity":"Critical","rationale":"This implementation does not address cyclomatic complexity, as the function contains a conditional branch that could be further decomposed. While the logic is simple now, adding more conditions or responsibilities would quickly make the code harder to maintain and test. High cyclomatic complexity increases the risk of hidden bugs and makes future changes error-prone. Refactoring to separate concerns—such as extracting the property initialization into its own function—would improve readability and maintainability, ensuring the code remains robust as it evolves.","lineStart":7,"lineEnd":10,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The MarshalJSON function unnecessarily increases linesOfCode by including redundant initialization and type aliasing.\n\n```go\nif d.Properties == nil {\n\td.Properties = make(map[string]Definition)\n}\ntype Alias Definition\n```","codeResolution":"The current MarshalJSON implementation can be streamlined to reduce lines of code and improve clarity by delegating property initialization to a helper and leveraging type aliasing more concisely.\n\n```go\nfunc (d Definition) MarshalJSON() ([]byte, error) {\n\tensurePropertiesInitialized(&d)\n\treturn json.Marshal((Alias)(d))\n}\n```","severity":"Critical","rationale":"This implementation overlooks linesOfCode best practices by embedding logic directly within the MarshalJSON method and using an inline struct for marshalling. While concise, this approach can hinder maintainability, as future changes to the marshalling logic or the Definition type may require edits in multiple places. For example, the initialization of d.Properties on line 4 could be refactored into a helper function to reduce repetition and improve clarity. Reducing tightly coupled logic and separating concerns would make the code easier to test and extend, ultimately improving maintainability and correctness.","lineStart":5,"lineEnd":10,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":1,"functionMethodCounts":1,"linesOfCode":16,"nestingDepth":1}},"hash":"5a6f206628ead7c3fbcb88dea8549dd6524faf6b0e5d26a8e0fa17e155a72e25","id":"eJxVkLFqw0AMhl9FaDqDSXZDhpJOgbaBdMtluNqyo8SWzJ0MNcHvXuy21F0k0Cfp/6UHhpQoJZbmXbXFAvfa9S19so2YY6kV7VWMxLDAPpT30BDcksqpvFIXvHjhrtdo4JGk1Iql2c7c48zqQUpwFTxTzcLGKhm8hJiuoT2c3l5dBu58+RiNcqAYNWbw8OKNa6g2x6g9RWNKsNuBcPvNvP1H0IU7uS7052SRpbmstOb+aQ429gRPLYe0sjKDSDZEWS7a/BhzyeJQ2q/aMrUsWhcKcEvOXJXlC828TF4wx5pbOga7YoF/j9qaHmaNRnH6AszWh8Y="}
{"assessingTool":"SOLID","filePath":"jsonSchema/toJson.go","grade":"C","username":"HLamb","timestamp":"2025-10-12T17:10:55.783Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependencyInversion","violatingCode":"The Definition type directly depends on the concrete map structure for Properties, violating dependency inversion by not abstracting its dependencies.\n\n```go\nif d.Properties == nil {\n    d.Properties = make(map[string]Definition)\n}\n```","codeResolution":"The MarshalJSON method should delegate serialization logic to an injected abstraction, promoting dependency inversion and testability. Replace the direct call to json.Marshal with a call to a marshaler interface:\n\n```go\ngo\nfunc (d Definition) MarshalJSON() ([]byte, error) {\n\tif d.Properties == nil {\n\t\td.Properties = make(map[string]Definition)\n\t}\n\treturn d.Marshaler.Marshal(d)\n}\n```","severity":"Critical","rationale":"This implementation tightly couples the `Definition` type to the `json.Marshal` function, violating dependency inversion principles. By directly depending on a concrete serialization method, the code becomes harder to test, extend, or swap out for alternative JSON libraries. This reduces maintainability and flexibility, as any change to the serialization logic requires modifying the core type. Introducing an abstraction, such as a `JSONEncoder` interface, would decouple the logic and improve testability and future extensibility.","lineStart":6,"lineEnd":13,"status":""},{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The Definition type's MarshalJSON method violates liskovSubstitution by directly mutating its receiver, making substitutability unsafe and unpredictable.\n\n```go\nif d.Properties == nil {\n\td.Properties = make(map[string]Definition)\n}\n```","codeResolution":"The MarshalJSON method is refactored to utilize an Operation abstraction, ensuring substitutability and adherence to the Liskov Substitution Principle:\n\n```go\n// Golang\nfunc (d Definition) MarshalJSON() ([]byte, error) {\n\top := getOperation(\"marshalJSON\")\n\treturn op.Execute(d)\n}\n```","severity":"Critical","rationale":"This implementation violates Liskov Substitution Principle because the MarshalJSON method is tightly coupled to the Definition type and its internal structure. If a different type or a subclass tries to override or extend Definition, it cannot substitute seamlessly due to the hardcoded handling of Properties and the use of a type alias. This rigidity reduces maintainability and testability, as future changes or alternative implementations would require rewriting or duplicating logic. Adhering to Liskov Substitution would allow more flexible, interchangeable types, improving code extensibility and correctness.","lineStart":1,"lineEnd":13,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"F","openClosedScore":"A-","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package jsonSchema\n\nimport \"encoding/json\"\n\nfunc (d Definition) MarshalJSON() ([]byte, error) {\n\tif d.Properties == nil {\n\t\td.Properties = make(map[string]Definition)\n\t}\n\ttype Alias Definition\n\treturn json.Marshal(struct {\n\t\tAlias\n\t}{\n\t\tAlias: (Alias)(d),\n\t})\n}\n","reason":"Modified","start":1,"end":16,"grade":"C"}]},"hash":"31e5560e91f356da349a075163cc4598a5d63aa2335e699406cf76ea355b4cc2","id":"eJxVkMFqwzAMhl9F6GRDaO+BHsZ6WVnXQnare/AcJfGayMFWDqXk3YezjWUXCfRJ+n/pgTYlSslz+x5CjyVWp9eXPRboQk3PgYVYsMTRupttCT5T4Mp1NFjDhv0whihgkNiF2nO7zdxgZs3EDlQNe2o8e/GBNRxtTJ3tD9XpTWlQl+vHXagAijFEDQ/DRnwD9eYcw0hRPCXY7YB9/82M/Ecw2BupwY6XJNFze11p5f45B7mPBE+9t2llJYNIMkVeLtr8GFNJ4uTkV22ZWhatCyWoJWtV62Kh2vBsGAtsfE9nKx2W+PeorYRD1mgDzl/5+4UT"}
{"assessingTool":"Complexity","filePath":"jsonSchema/image.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:10:49.151Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":1,"dependenciesModules":0,"functionMethodCounts":0,"linesOfCode":30,"nestingDepth":0}},"hash":"b438506bc504af56b6b786e71e9f11aea2c748e259197dea1271e18bcc76415a","id":"eJx9U8Fu2zAM/RVCpw1I4sVZGiTADlsKDDsMG5AOO9QFytmMzUWWDIte4hb990FK4nmJ0YshUe898pH0s0LnyDk2+Z21Wq3U2paVpgNLq0YqtRmtrREyolaqwnSHOcFvZ80mLajExCRG2orgS4k5fbUZaXBSs8n9S2qNE/hWkfnIt6g1xX3cB0hU/y1RA4zZK4yZZ/Tzb/iJrtK/SUwiUSQFO/B2gB0YTneUwba2JeR2bCsyyB63rgmFOrF4fnOI5zcAPX1fxCke8l9y5tP4MJ/GV5xTfJAzfRe/P/jPBaeLH516H5Ch1mMaz8A1VWVroQys0e1kSHaxjAdlz/FXilks48FiFstg4a2vJ4qOEOAttLaBPRoBKQh+1BrsNhw5ABpH4XaLgnd+XpswJbBSUL1nN4D41Ar1h+sH26QCz77k4z70VuPR7+QqUaW/jWzJQmUlbaIePTx46Nnp4I6f6AL90u3Uhkx2nTpEnC8T7h/uH361Qp0cd2//iUIU/SzIgCOTeddlo4UrfWqOA8EdARuxgGlqm1MTg5XQ1wL/EDjSlAplE9g0aQFSoMBnKtkwhBa480Jcye8LqgldEF1rbLKTtguL09GsOU8LBRCESwrdUCO1ZU3fUQq1Uv/+/SiAJ7lVL38Bjhd+Ww=="}
{"assessingTool":"SOLID","filePath":"jsonSchema/image.go","grade":"C","username":"HLamb","timestamp":"2025-10-12T17:10:51.086Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependencyInversion","violatingCode":"The violatingCode tightly couples the SendImage struct to concrete data representations, ignoring dependency inversion and making future extensions or testing difficult.\n\n```go\ntype SendImage struct {\n\tImagesData [][]byte `json:\"imagesData,omitempty\"`\n}\n```","codeResolution":"To address dependency inversion, the solution introduces an abstraction layer for image processing, allowing the ImageService to depend on an interface rather than a concrete implementation.\n\n```go\n// Go\ntype ImageService struct {\n    processor ImageProcessor // ImageProcessor is an interface defined elsewhere\n}\n\nfunc NewImageService(p ImageProcessor) *ImageService {\n    return &ImageService{processor: p}\n}\n\nfunc (s *ImageService) ProcessImage(img *Image) error {\n    return s.processor.Process(img)\n}\n```","severity":"Critical","rationale":"This code tightly couples the `Image` and `SendImage` types to specific models and sizes, violating dependency inversion. By hardcoding model and size options (lines 3–24), any change or extension requires modifying the core types, reducing maintainability and flexibility. This approach makes unit testing difficult, as dependencies cannot be easily mocked or replaced. For better adherence to dependency inversion, interfaces or abstraction layers should be introduced, allowing new models or sizes to be added without altering existing code. This would improve extensibility and testability, and reduce the risk of bugs when requirements change.","lineStart":1,"lineEnd":22,"status":""},{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The code violates the Liskov Substitution Principle by not providing any interface abstraction for image models or image sending, preventing substitutability and extensibility.\n\n```go\ntype Image struct {\n\tModel ImageModel `json:\"model,omitempty\"`\n\tSize  ImageSize  `json:\"size,omitempty\"`\n}\n```","codeResolution":"To address Liskov Substitution Principle violations, the solution introduces an abstraction for image operations, allowing interchangeable implementations for different models and sizes.\n\n```go\n// Go\nfunc ProcessImage(model ImageModel, size ImageSize, data []byte) error {\n    op := getOperation(model, size) // Returns an Operation interface\n    return op.Execute(data)\n}\n```","severity":"Critical","rationale":"This implementation lacks interface abstraction for image models and image sending, violating Liskov Substitution Principle. Without interfaces, client code cannot substitute different image model or sender implementations, making the system rigid and difficult to extend. For example, if a new image model or sending strategy is needed, significant refactoring would be required. This reduces maintainability and testability, as mocking or swapping components is not straightforward. Introducing interfaces for image handling and sending would allow for flexible, interchangeable implementations, improving adherence to Liskov Substitution and overall code robustness.","lineStart":16,"lineEnd":20,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"F","openClosedScore":"A-","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package jsonSchema\n\ntype ImageModel string\n\nconst OpenAiDalle2 ImageModel = \"OpenAiDalle2\"\nconst OpenAiDalle3 ImageModel = \"OpenAiDalle3\"\n\ntype ImageSize string\n\nconst (\n\t//this code is nicked from go-openai\n\tCreateImageSize256x256   ImageSize = \"256x256\"\n\tCreateImageSize512x512   ImageSize = \"512x512\"\n\tCreateImageSize1024x1024 ImageSize = \"1024x1024\"\n\n\t// dall-e-3 supported only.\n\tCreateImageSize1792x1024 ImageSize = \"1792x1024\"\n\tCreateImageSize1024x1792 ImageSize = \"1024x1792\"\n)\n\n// Image if you want the Url of the image use the DataType String otherwise use the DataType Byte\ntype Image struct {\n\tModel ImageModel `json:\"model,omitempty\"`\n\tSize  ImageSize  `json:\"size,omitempty\"`\n}\n\ntype SendImage struct {\n\tImagesData [][]byte `json:\"imagesData,omitempty\"` //When sending multiple images take into account the model you have selected. Such that Gemini Models support multiple images whereas the Claude models only support one image at a time\n}\n","reason":"Modified","start":1,"end":30,"grade":"C"}]},"hash":"f559799291e4d4ca7cc39d67196421b82117cbeebe62f9db4ad4a95f916ce4d2","id":"eJx9U1Fr2zAQ/iuHnjZI4sVZGhLow5bAKGx04I491IVe7YutRZaMdV7ilv73IsXxvMT0xUin7/vuvrvzi0BryVqpsztjlFiJ6Pb7zUaMRGJSWhvNpFmsRInJDjOCP9boKMmpwFjHmpuS4KbAjH6YlBRYrqTO3EtitGW4LUl/kRtUisI+7hpi0X+LxQBj9g5j5hj9/JF8pov0H2IdcxBwLi04OyAtaJnsKIVtZQrIzNiUpFE63LoiZOrEwvnVIZxfAfT0XRFt3Oc/58yn4WE+DS84bXyQM/0Ufj64zxmnix+dOh+QolJjGs/A1mVpKqYUjFbNZEh2sQwHZU/xd4pZLMPBYhZLb+GjqycIjhCQW2hMDXvUDJwT/KoUmK0/Sg+oLfnbBhnv3LwiPyUwnFO1l3YA8bVh6g/XDbZOGF5cycd96K3Go9vJVSwKdxuZQjIVJTexeHRw76Fnp4Nb+Uxn6NdupyLS6WVqH7GuTLh/uH94apg6Odm9/ScKQfA7Jw2WdOpcF7ViWaq2ORYYdwRSswFMElO3TfRWfF9z/EtgSVHClE4gqpMcOEeGb1RILcG3wJ4W4kJ+n1NFaL3oWmGdttrWL05HM/o0LWRAYFmQ74YYia1U9BM5Fyvx798PPHiSGfH6Bh39e6g="}
{"assessingTool":"Complexity","filePath":"jsonSchema/constantModels.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:10:44.583Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A+","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":1,"dependenciesModules":0,"functionMethodCounts":0,"linesOfCode":27,"nestingDepth":0}},"hash":"ec3a4de11485b9b6d1b41b312c78072832b4af046b70d6c18f22dd70c225b6ed","id":"eJxtk0Fvm0AQhf/KaE+JZNl3Sz24Dkoi1Y0lkxuXAQbYdJlBu4NaVPW/V7uQJsa9ofe+eQxPw2+DIVAIlttcxJm9OUo/OPpldTIbU0lNR2ElVrM3A1Y/sCV4C8KXqqMeCy5Yp4HgARXz+BDUW26jXgkHhbuCC30p36hS+KC+QGEkiYWJwPexL8mvAE7iDDyzUkv+GrCzOBOX9OJVxLJNAg7e4wQrAKP4voNzsPZ5dG62v4o4Qr62y1mciRMOcBPQ47DMT0o3bjkpFQZ2O+1sgJ/WOSgJxkA1NOJBOwIcayuAXIPtY/k1KkIgR5VaYbizDaRhGxaVasAAMTnOM5DVjjw8p2nxcEiB/RgUWDS+j63bgG3AakxJQyzaxTrTSlJVo08rIAP1g05z/Pu+nnT0TPUW8o4gYE8px48UU0vRDtATNNY5qrcF3/87m6c8P59IO6k/Hc5uB8d4O8gaUg2Rgj5h4equHrM8VvopJZb6mOVz5eeXS35rR3XxX/83fn5d7IfsW5Zna3tWl4BDfny6DYhqBO4LNhvTWEdn1M7szcePs6uWLzxJTS5sWzF//gIMDzUA"}
{"assessingTool":"SOLID","filePath":"jsonSchema/constantModels.go","grade":"A+","username":"HLamb","timestamp":"2025-10-12T17:10:18.890Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"dependencyInversionScore":"A+","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"A+","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package jsonSchema\n\ntype DataType string\n\nconst (\n\tObject  DataType = \"object\"\n\tNumber  DataType = \"number\"\n\tInteger DataType = \"integer\"\n\tString  DataType = \"string\"\n\tArray   DataType = \"array\"\n\tNull    DataType = \"null\"\n\tBoolean DataType = \"boolean\"\n\tMap     DataType = \"map\"\n\tByte    DataType = \"byte\" //this will be used for the audio and image data selection (if this is selected as byte then either Image or Audio must not be nil, if it is then nothing will occur and an empty byte will be returned. The same is true if both are filled.\n)\n\ntype HTTPMethod string\n\n// Constants for HTTP methods\nconst (\n\tGET    HTTPMethod = \"GET\"\n\tPOST   HTTPMethod = \"POST\"\n\tPUT    HTTPMethod = \"PUT\"\n\tDELETE HTTPMethod = \"DELETE\"\n\tPATCH  HTTPMethod = \"PATCH\"\n)\n","reason":"Modified","start":1,"end":27,"grade":"A+"}]},"hash":"7cabea872387868ca920251369b36c2169d823cee911be4922699c06f5179c25","id":"eJxtk0Fr4zAQhf/KoFMLIb4H9pBNTBtomkDUmy9je2yrK4+MNKaYZf/7ItndNsnezHvfPI8f498KQ6AQDLfaOas26nJ6OezVSlWupp1jIRa1UQNWv7AleA+OL1VHPRZcsEwDwR4FdXwI4g23Ua8cB4GHggs5le9UCXxRP6BQLomFisDr2JfkbwBO4gwcWKglfw2YWZyJS3rxTcSyTQK23uMENwBG8XMHa+HW59Ha2f7pnCXka7ucxZk44gB3AT0Oy/wkdOeWk1ChIMukMwE+jLVQEoyBamicB+kIcKyNA+QaTB/Lr1EQAlmqxDiGB9NAGjZhUakGDBCT4zwDGenIwyFNOw/bFNiPQYCdxPexsSswDRiJKWmInXSxzrSSq6rRpxWQgfpBpjn+c19PMnqmeg26IwjYU8rxI8XU0kkH6AkaYy3V64If/53Ns9bnI0nn6m+Hk2Wwi7eDLCHVECnoExau7uop17HSbymx1Kdcz5WfTxd9b0d18d/+N35+W+x9/pLr/Nae1SVgq3fP9wFRjcBjwWqlGmPpjNKpjfr6cbJq+cKjq8mGdevUn7+SEjJN"}
{"assessingTool":"Complexity","filePath":"jsonSchema/audio.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:10:44.088Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A+","testability":"A"},"issues":{"cyclomaticComplexity":1,"dependenciesModules":0,"functionMethodCounts":0,"linesOfCode":49,"nestingDepth":1}},"hash":"cfd32848613f8e6ebea73fbeeffed3233abd54d129711bb751790aefb1cac33e","id":"eJydVd1v0zAQ/1dOftqklgohIVGJh1IYAsGKSDQeCNKc9JIYEl+IL12jaf/7ZDvpkqZUE36Lfx++D59zL6QxaIzSWUhUiKVYU1kVuFfciplIaItr0oyaxVJUMvkjM4TfhnSQ5FjKSEd6sYBVs1X0lbZYQELasNQM3FZoIKUaOEfYqjTFGjWDbNSWoLRkE2nLghD3HFJQISa5dzFcK51Zd+cHmwr1SoVhcIL7FiLBbCLRBTNkuLPfS5ahPYcJGoNwp9gCyrgYQRl41zKeiMWG0SQM95GO2B/Wr2kYt7Yqy0i4zGZUKsay4jYSt1YduIRCcpXq0oPB6tVmyJu43JBK8KAZfw1ddhaZqK+oLiX3XHfCaKtXp27zSP5gq+sq5JMOyZbgXLd+5MpUWJ/g246NOLZ3Xvqxpr/nhQOGb7kLapjNcThWPyK4G4N7fjo2+B5OGKYeEG7CKWHHA8LnYHM9YdiCDjywjsngSebOY/Ne0aXlW3yc0IXt5qooqD3cAush7Y4T84ckJxiBmOTksSsZFzjCUrvjwY1u92Mh6XbvsWvayTGmaSc9FuSqLLEeYMbvWPiym8xhQ585mUGX+uTmnZlNu6Z35/x8un6EFNZSm6RWMcLPX3HLeGq65DF34vZF6qyxL+Vh/Xvii447MoHFomwMQ4ygtCuVH0qgFD4Fm/nrV2/mLwHuVFHAFlPZFGxriBouUGeFMvnldOL/Y+oj+8gdhR4TjWt9sOCOe8JkLStWpM1zTHru9AUSM5GqAr9JzsVSPP2GFq4lLzISD4+w01X7"}
{"assessingTool":"SOLID","filePath":"jsonSchema/audio.go","grade":"C-","username":"HLamb","timestamp":"2025-10-12T17:10:47.669Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The code violates interface segregation by combining unrelated responsibilities into the TextToSpeech and SpeechToText structs instead of defining focused interfaces.\n\n```go\ntype TextToSpeech struct {\n\tModel         TextToSpeechModel `json:\"model,omitempty\"`\n\tStringToAudio string            `json:\"stringToAudio,omitempty\"`\n\tVoice         Voice             `json:\"voice,omitempty\"`\n\tFormat        AudioFormat       `json:\"format,omitempty\"`\n}\n```","codeResolution":"To address interface segregation, the solution introduces specialized abstractions for each audio operation, ensuring that clients depend only on the functionality they require. The following replacement code demonstrates how to utilize the new abstraction for processing audio operations:\n\n```go\n// Golang\nfunc ProcessAudioOperation(opType string, input interface{}) (interface{}, error) {\n    operation := getOperation(opType) // Returns an Operation interface\n    result, err := operation.Execute(input)\n    return result, err\n}\n```","severity":"High","rationale":"The current design lacks interfaces for the TextToSpeech and SpeechToText types, violating the Interface Segregation Principle. This matters because clients are forced to depend on concrete types rather than abstractions, making future extensions (e.g., supporting new audio models or formats) harder and risking tight coupling. Without focused interfaces, maintainability suffers—any change to these structs could impact all consumers. Introducing minimal, role-specific interfaces (e.g., for conversion or formatting) would allow clients to depend only on what they need, improving modularity and testability.","lineStart":22,"lineEnd":44,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code violates dependency inversion by directly using concrete types instead of abstractions, making it rigid and difficult to extend.\n\n```go\ntype TextToSpeech struct {\n\tModel         TextToSpeechModel `json:\"model,omitempty\"`\n\tStringToAudio string            `json:\"stringToAudio,omitempty\"`\n\tVoice         Voice             `json:\"voice,omitempty\"`\n\tFormat        AudioFormat       `json:\"format,omitempty\"`\n}\n```","codeResolution":"To address dependency inversion, the solution replaces direct instantiation with abstraction-based delegation, ensuring the code depends on interfaces rather than concrete implementations.\n\n```go\n// Go\nfunc (stt *SpeechToText) Transcribe() (string, error) {\n    op := getOperation(stt.Model) // returns Operation interface\n    return op.Transcribe(stt.AudioToTranscribe, stt.Language, stt.Format)\n}\n```","severity":"Critical","rationale":"This code tightly couples the data models to specific implementations (e.g., hardcoded model and format constants), violating dependency inversion principles. By directly referencing concrete types and values, future changes—such as supporting new audio models or formats—require modifying the core structs, reducing maintainability and flexibility. This approach also hinders testability, as it’s difficult to substitute or mock dependencies. Introducing interfaces or abstraction layers for model and format selection would decouple the logic, making the codebase easier to extend and refactor.","lineStart":1,"lineEnd":34,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The code violates openClosed principles by requiring modification of existing types and constants to support new models or formats, rather than allowing extension.\n\n```go\nconst OpenAiWhisper SpeechToTextModel = \"OpenAiWhisper\"\nconst GroqWhisper SpeechToTextModel = \"GroqWhisper\"\n```","codeResolution":"The solution for openClosed refactors the code to delegate audio operations to an abstraction, allowing new models or formats to be added without modifying existing logic.\n\n```go\n// Go\nfunc (stt *SpeechToText) Transcribe() (string, error) {\n    op := getOperation(stt.Model)\n    return op.Transcribe(stt.AudioToTranscribe, stt.Format, stt.Language)\n}\n```","severity":"Critical","rationale":"This code violates the Open/Closed Principle because adding new audio models or formats requires modifying existing structs and constants directly (e.g., adding a new SpeechToTextModel or AudioFormat). This approach leads to poor maintainability, as every extension forces changes throughout the codebase, increasing the risk of bugs and regressions. It also makes testing harder, since new logic is tightly coupled to existing types. Refactoring to use interfaces or composition would allow new models or formats to be added without altering existing code, improving extensibility and correctness.","lineStart":22,"lineEnd":34,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"C-","liskovSubstitutionScore":"A+","openClosedScore":"F","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package jsonSchema\n\n// AudioModel constant types for the different auido models\ntype TextToSpeechModel string\n\nconst OpenAiTTS TextToSpeechModel = \"tts\"\n\n// TextToSpeech the DataType to use with this type is Byte\ntype TextToSpeech struct {\n\tModel         TextToSpeechModel `json:\"model,omitempty\"`\n\tStringToAudio string            `json:\"stringToAudio,omitempty\"`\n\tVoice         Voice             `json:\"voice,omitempty\"`\n\tFormat        AudioFormat       `json:\"format,omitempty\"`\n}\n\ntype SpeechToTextModel string\n\nconst OpenAiWhisper SpeechToTextModel = \"OpenAiWhisper\"\nconst GroqWhisper SpeechToTextModel = \"GroqWhisper\"\n\ntype AudioFormat string\n\nconst Text AudioFormat = \"text\"\nconst SRT AudioFormat = \"srt\"\nconst VTT AudioFormat = \"vtt\"\nconst JSON AudioFormat = \"json\"\nconst VerboseJSON AudioFormat = \"verbose-json\"\n\ntype Voice string\n\nconst (\n\tAlloy   Voice = \"alloy\"\n\tEcho    Voice = \"echo\"\n\tFable   Voice = \"fable\"\n\tOnyx    Voice = \"onyx\"\n\tNova    Voice = \"nova\"\n\tShimmer Voice = \"shimmer\"\n)\n\n// SpeechToText the DataType to use with this type is String\ntype SpeechToText struct {\n\tModel             SpeechToTextModel `json:\"model,omitempty\"`\n\tAudioToTranscribe []byte            `json:\"audioToTranscribe,omitempty\"`\n\tLanguage          string            `json:\"language,omitempty\"` //must be in the format of ISO-639-1  will default to en (english)\n\tFormat            AudioFormat       `json:\"format,omitempty\"`\n\tToString          bool              `json:\"toString,omitempty\"`\n\tToCaptions        bool              `json:\"toCaptions,omitempty\"`\n}\n","reason":"Modified","start":1,"end":49,"grade":"C-"}]},"hash":"31bf39d54c5374e190b0e09e7d888b521cd739215ced13821140b7abef996e89","id":"eJydVd1r2zAQ/1cOPbWQLIzBYIE9ZO06OrpmzKZ7mAdV7LOtzdZ51jmNKf3fhyQntWMvlOnN+n3oPnTyo5DGoDFKZyFRIZYiWN9cX4qZiCnBC9KMmsVSVDL+LTOEX4Z0EOdYykhHerGAVZMo+kIJFhCTNiw1A7cVGkipBs4REpWmWKNmkI1KCEpLNpG2LAhxxyEFFWKcexfDtdKZdXd+sK5Qr1QYBhPc9xAJZhOJLpg+w519KVmG9hwmaAzCg2ILKONiBGXgQ8s4EYsNo4kZHiMdsT9sv8Zh3NuqLCPhMptRqRjLittI3Ft14BIKyVWqSw96a682fd7I5Y5UjAfN8KvvsrXISH1FdSl5z3UnDLb26tRtHsmfbHVdhXzSIdkSnOrW91yZCusJvu3YgGN756WfavpzWthj+Ja7oPrZHIdj9QOCuzG44+djg2/hiGHqHuEuHBO23CN8Dta3I4YtaM8D6w0ZnGRuPTbfK7q0fIuPEzqz3VwVBbWHW2A9pN1xYv4Y5wQDEOOcPHYlNwUOsNTueHCt291QSLrdeeyWtnKIadpKjwW5Kkuse5jxOxY+7yaz39AXTmbQpT66eSdm067x3Tk9n64fIYW11Cau1Qbhx89Nyzg1XfKYO3K7kTpr7Et5WP+e+KLjDkxgsSgbw7BBUNqVyg8lUArXwXr+9s27+WuAB1UUkGAqm4JtDVHDGeqsUCY/H0/8f0x9ZB+5o9A3RMNaHyy4406YXMiKFWnzEpM9d/wCiZlIVYFfJediKZ5/QwvXklcZiae/Yx9TSA=="}
{"assessingTool":"Complexity","filePath":"converison/response.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:10:53.085Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A+","testability":"A"},"issues":{"cyclomaticComplexity":8,"dependenciesModules":2,"functionMethodCounts":3,"linesOfCode":61,"nestingDepth":3}},"hash":"a0e299ed9ae0934151ab75ff3b84925ae52733db7c001379d4796cbbcf5e9891","id":"eJzFVd9r3DAM/lc0wyAZIXk/uJeVrYP9YNBjL00ZbqKk5hw52HK6o9z/Puzkrne5tBt72ZuxPn3SJ8nyk5DOoXOK2o0xWqzElel6jb8U70QmKlPjlSFGYrESvay2skWoDA1olTNUUkmq641lSEoquRRNx6UYj60xrca8NVpSmxvbFr01bO59U/CuR1dsyTxS4dj6ivv74JYGwqKAqxiBbybTxnyV/RSWHbw7uOQjANhAJ/tbx1ZRe6eI0Taywqd9SY2napEuueRJITmhkbTLAK01NoWnoEg14GC9BlJ6vCjZIntL4SaDpuP8Q4A3SSkU9Z5hnqdyAVqKIJP3QWugcF4zrNbQyS3OEkhHTGMsbHGXwSC1x4C1kloEl18jf1Soa5ekh5ymMmH9I4CjhOBRndcgGpPIl45+qonQN2cCzyWiteP1/iA/5H67xd0dHCNMgc8kRooRncUS0H7q9CfUPVoIbWJlKLRy4gFFtRpU7aU+6VTkDqhrA3GKpha/LG/unEJy0Vr3qLh6gCEUKjqFwn5WVCdpnoQwE66S7oLv5zevdTytLocian3Rr7tHu+A55Cem1zlu4qgscpyYXud4b8xS/kN+NPwxB1/xAsPisxvyE3z6IukX5ZYoZ20OqGTIj+DIV2MjveaFbpw9UU/O92F1YQ3z8dr1uIK3m1JkMBwe619M7LOIY0bBLMOwOq0qXB7WqEIrt0iQQnJ7uYtmW2NCaKTIE6Y3OrskTU92iLrYIHP0/1si6l9WiMhEozR+l/wgVuL5Xyosut6QC7+P2P8GmPWScw=="}
{"assessingTool":"SOLID","filePath":"converison/response.go","grade":"B","username":"HLamb","timestamp":"2025-10-12T17:10:32.090Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependencyInversion","violatingCode":"The ConvertStructpbToMap function directly depends on the concrete structpb types, violating dependency inversion by not abstracting its dependencies.\n\n```go\nfunc ConvertStructpbToMap(s *structpb.Struct) (map[string]any, error) {\n\tif s == nil {\n\t\treturn nil, fmt.Errorf(\"input structpb.Struct is nil\")\n\t}\n```","codeResolution":"The codeResolution introduces an abstraction layer for value conversion, enabling dependency inversion and improving testability and flexibility.\n\n```go\n// Replace direct calls to convertStructpbValue with the injected Operation abstraction\nfor key, value := range s.GetFields() {\n\tconvertedValue, err := op.Convert(value) // 'op' is an Operation interface instance\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresult[key] = convertedValue\n}\n```","severity":"Critical","rationale":"This code tightly couples conversion logic directly to the structpb types and concrete helper functions, violating dependency inversion principles. By depending on specific implementations (e.g., direct calls to ConvertStructpbToMap and convertStructpbValue), the code becomes harder to extend, test, or reuse with alternative data sources or conversion strategies. This rigid structure reduces maintainability and flexibility, as any change to the conversion logic or underlying types requires modifying core functions. Introducing abstractions (interfaces for conversion) would decouple the logic, making the codebase more adaptable and testable.","lineStart":7,"lineEnd":37,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"A+","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package converison\n\nimport (\n\t\"fmt\"\n\t\"google.golang.org/protobuf/types/known/structpb\"\n)\n\n// ConvertStructpbToMap converts *structpb.Struct to map[string]interface{}\nfunc ConvertStructpbToMap(s *structpb.Struct) (map[string]any, error) {\n\tif s == nil {\n\t\treturn nil, fmt.Errorf(\"input structpb.Struct is nil\")\n\t}\n\n\tresult := make(map[string]any)\n\n\tfor key, value := range s.GetFields() {\n\t\tconvertedValue, err := convertStructpbValue(value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresult[key] = convertedValue\n\t}\n\n\treturn result, nil\n}\n\n// Helper function to convert individual *structpb.Value to Go types\nfunc convertStructpbValue(value *structpb.Value) (any, error) {\n\tswitch v := value.GetKind().(type) {\n\tcase *structpb.Value_NullValue:\n\t\treturn nil, nil\n\tcase *structpb.Value_NumberValue:\n\t\treturn v.NumberValue, nil\n\tcase *structpb.Value_StringValue:\n\t\treturn v.StringValue, nil\n\tcase *structpb.Value_BoolValue:\n\t\treturn v.BoolValue, nil\n\tcase *structpb.Value_StructValue:\n\t\treturn ConvertStructpbToMap(v.StructValue)\n\tcase *structpb.Value_ListValue:\n\t\treturn convertStructpbList(v.ListValue)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported structpb.Value type: %T\", v)\n\t}\n}\n\n// Helper function to convert *structpb.ListValue to a Go slice\nfunc convertStructpbList(list *structpb.ListValue) ([]any, error) {\n\tresult := make([]any, len(list.GetValues()))\n\n\tfor i, value := range list.GetValues() {\n\t\tconvertedValue, err := convertStructpbValue(value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresult[i] = convertedValue\n\t}\n\n\treturn result, nil\n}\n","reason":"Modified","start":1,"end":61,"grade":"B"}]},"hash":"6b06647b1a864f80be8449917916e40b43b6a84081003893e59871ba5f15fd74","id":"eJzFVU1v2zAM/SucgAH2YNj3ALms27ph3QeQYpe6KFSbdoUolCFRLoIi/32Q7KSJ43bDLrsJ4uMjH0lRT0I6h84paq+N0WIhVj+uvnwQmahMjReGGInFQnSyWssWoTLUo1XOUEklqU1nLENSUsmlaDZciuHYGtNqzFujJbW5sW3RWcPm3jcFbzt0xZrMIxWOra+4uw9uaSAsCriIEXg1mq7NN9mNYdnBu71LPgCADWxkd+PYKmpvFTHaRlb4tCup8VTN0iXnPCkkRzSSthmgtcam8BQUqQYcLJdASg8XJVtkbyncZNBsOP8Y4E1SCkWdZ5jmqVyAliLI5F3QGiic1wyLJWzkGicJpAOmMRbWuM2gl9pjwFpJLYLLL5E/KdS1S9J9TmOZsP4VwFFC8KhOaxCNSeRLBz/VROibE4GnEtHa4Xq3lx9yv1nj9hYOEcbAJxIjxYDOYgloN3b6M+oOLYQ2sTIUWjnygKJa9ar2Uh91KnIH1KWBOEVji1+WN3VOITlrrXtUXD1AHwoVnUJhvyqqkzRPQpgRV0l3xnf33WsdT4vzoYhaX/Tb3KOd8ezzI9PrHKs4KrMcR6bXOd4bM5d/nx8Mf8zBVzzDMPvs+vwIn75IeqXcHOWkzQGV9PkBHPlqbKTXPNONkyfqyfkurC6sYTpe2w4X8Pa6FBn0+8f6FxP7LOKQUTDLMKxOqwrnhzWq0MrNEqSQ3JzvosnWGBEaKfKE6Y3OLknTox2izjbIFP3/loj6lxUiMtEojT8lP4iFeP6XCouuM+TC7yN2vwEVRY/A"}
{"assessingTool":"Complexity","filePath":"converison/map.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:10:41.806Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A+","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":1,"functionMethodCounts":2,"linesOfCode":14,"nestingDepth":1}},"hash":"db34ceaafe42fda8838fe347297ccd88eab05e241911633238b73ccf0bf4280a","id":"eJx1kcFqhEAMhl9lyEmLOHdvxfOWQr3t9DBr43RYTYaZ2O0ivnvRxZba7S2Q///yQSawKWFKnlzD3EMFNQ+hx08vVyig5TesmQRJoIJg27N1qFqmD4w+MRky5IfAUZQBx+x6LB33llzJ0ekQWfg0dlquAZM+E19IJ4ljK+FkYGlrreoVJ2qw4ZgkenKvngRjZ1ucZiWsHrZO+bIOhrqR2q14sKHh2yIb/qHkKttDCoUxcszVZMhIRBkjqe/ME142ZG5o3qnuWYvk/cO/VW/phg82ZOkPJVfZfch91fIxLZy8UOT71REK6HyPz1beoYKfN+nBhtIxzF+Q0Lou"}
{"assessingTool":"SOLID","filePath":"converison/map.go","grade":"C","username":"HLamb","timestamp":"2025-10-12T17:10:01.752Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The ConvertMapToStruct and ConvertStructToMap functions do not utilize interface abstraction, violating liskovSubstitution by preventing substitutability and extension.\n\n```go\nfunc ConvertMapToStruct(m map[string]interface{}) (*structpb.Struct, error) {\n\treturn structpb.NewStruct(m)\n}\n```","codeResolution":"The conversion logic is refactored to use an Operation abstraction, enabling substitutability and adherence to the Liskov Substitution Principle.\n\n```go\n// Go\nfunc ConvertMapToStruct(m map[string]interface{}) (*structpb.Struct, error) {\n    op := getOperation(\"mapToStruct\")\n    return op.Execute(m)\n}\n\nfunc ConvertStructToMap(s *structpb.Struct) (map[string]interface{}, error) {\n    op := getOperation(\"structToMap\")\n    return op.Execute(s)\n}\n```","severity":"Critical","rationale":"This implementation does not adhere to Liskov Substitution Principle, as there is no abstraction or interface for conversion operations. Directly coupling the conversion logic to specific types (lines 5–13) makes it impossible to substitute alternative conversion strategies without modifying client code. This rigidity reduces maintainability and testability, since new conversion formats or logic cannot be introduced polymorphically. Introducing an interface for conversion would allow interchangeable implementations, improving extensibility and correctness.","lineStart":0,"lineEnd":13,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The ConvertMapToStruct and ConvertStructToMap functions directly depend on the concrete structpb package, violating dependency inversion by not abstracting external dependencies.\n\n```go\nimport \"google.golang.org/protobuf/types/known/structpb\"\n```","codeResolution":"The conversion logic should delegate to an abstraction for map-struct operations, enabling easier testing and extension.\n\n```go\n// Go\nfunc ConvertMapToStruct(m map[string]interface{}) (*structpb.Struct, error) {\n\treturn getOperation(\"mapToStruct\").Execute(m)\n}\n\nfunc ConvertStructToMap(s *structpb.Struct) (map[string]interface{}, error) {\n\treturn getOperation(\"structToMap\").Execute(s)\n}\n```","severity":"Critical","rationale":"This code tightly couples conversion logic to the external structpb package, violating dependency inversion principles. By directly depending on a concrete implementation, any changes in structpb or a need to swap out the serialization format would require significant refactoring throughout the codebase. This approach reduces maintainability and testability, as mocking or substituting the conversion logic is difficult. Introducing an abstraction layer (e.g., an interface for conversion) would decouple the code, making it easier to extend, test, and adapt to future changes.","lineStart":1,"lineEnd":9,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"F","openClosedScore":"A+","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package converison\n\nimport \"google.golang.org/protobuf/types/known/structpb\"\n\n// Convert map[string]interface{} to *structpb.Struct\nfunc ConvertMapToStruct(m map[string]interface{}) (*structpb.Struct, error) {\n\treturn structpb.NewStruct(m)\n}\n\n// Convert *structpb.Struct to map[string]interface{}\nfunc ConvertStructToMap(s *structpb.Struct) (map[string]interface{}, error) {\n\treturn s.AsMap(), nil\n}\n","reason":"Modified","start":1,"end":14,"grade":"C"}]},"hash":"5087c656df5f53ff3db70bda90c5f70cc707a11d9b04868bffa94c4180c07605","id":"eJx1kcFKxEAMhl9lyKmV0rn3JutFcFXY3hwPszUdh22TYSZ1kaXvLu1SxVpvgfz/lw9yAZsSpuTJ1cwdVHB4eri/gwIafsMdkyAJVBBsc7IOVcP0gdEnJkOGfB84ijLgmF2HpePOkis5Oh0iCx+HVstnwKRPxGfSSeLQSDgamNpaq92ME9Xb8JIkenKvngRjaxu8jEpY3Syd8jAPhtqBmqW4t6Hm6yLr/6HkKltDCoUxcszVxZCRiDJEUt+ZRzwvyNzQuFJdsybJ7cO/Va/pmvc2ZOkPJVfZNmRbtbxNEycvFPludoQCWt/hs5V3qODnTbq3oXQM4xdx5bd7"}
{"assessingTool":"Complexity","filePath":"client/requestSender.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:09:38.798Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A+","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":4,"functionMethodCounts":2,"linesOfCode":50,"nestingDepth":2}},"hash":"309678a5d12aba028a71c15171eeceaaa7a261828bf3498ea13ec8d97a3d3b5c","id":"eJydVEtP3DAQ/itTS60SSLP3lTiUpSqqWkDs9uaLN5nsGrzjYE9KF8R/r/wILFVQJW6xZ/w95pFHobxH7zVtVtYaMRcLu+sN/tG8F5VobIsLS4zEYi561dyqDUJjNBJLkqR3vXUMhSTJUqz3jF6KdEBqbKtpM7vxlsbLbsfjJyHPtsx9OJcBazaDM+zUYPga7wb0vERq0YH2oKBNEdBB3A6JFWtLYDt4lSyJ9z1O43h2Q8OPgT0ZgKPAXy+ym6cs4gLvp3WQZq2MfsAgiPB+kkZSN1DzFkgxwVzC0SRfVOqQB0fwaSojJoxm5rkrVbh8enETUvOrU9vuwSO1Qf/35eUFuBQARS0kphBy6HtLHrOVwvlpheW/4MVaefx1/aMCtrdIoeKaNtVIE/mPDvJLKFIhrjNjBeicdWXyPjgD8xPIoHAMUsxUr2d2fYMNf8M0VSQ52nSpN8BbfPa1Doxso9mQGEbxTLGKPAE7XNQ/lfNbZYoDmWEgWXcx7cMJkDaQq50bQtpU0O24/hoEd4UUUTnsEpbRtHmlYg4ff0sRecvcoax84VAxgiI4X62uxkep93fPQmOZLvA+V6+Q4upyuQqIgzMVxM0L8dOh69AVo9Hy3UaaIOvAxdsGlsiwRdWi81l1fR6P9RKD0Pz/+Lza9xgQpFB9b3QTNzj/HcrJl18G3lqnH2JmenqKyqEDKY7jiJUHKqh91fuXmc7X41AHIt8/V9b5Om1OfWbDCLy7YmGz/l+wDJIkkDZxU0UlOm3wSvFWzEWSM3OHu1ZvrHj6Cw/4Dm8="}
{"assessingTool":"SOLID","filePath":"client/requestSender.go","grade":"D","username":"HLamb","timestamp":"2025-10-12T17:09:53.938Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"openClosed","violatingCode":"The DefaultRequestSender violates openClosed principles by requiring modification of its SendRequestBody method to support new request types or endpoints.\n\n```go\n// SendRequestBody sends a JSON request and returns a response\nfunc (rs *DefaultRequestSender) SendRequestBody(baseURL, token string, requestBody *RequestBody) (*http.Response, error) {\n    url := baseURL + \"/api/objectGen\"\n    // ...\n}\n```","codeResolution":"The solution for openClosed refactors the request sending logic to depend on an abstraction, allowing new request types or sending strategies to be added without modifying existing code.\n\n```go\n// SendRequestBody delegates to the injected Operation abstraction\nfunc (rs *DefaultRequestSender) SendRequestBody(baseURL, token string, requestBody *RequestBody) (*http.Response, error) {\n\toperation := getOperation(\"objectGen\") // Factory returns appropriate Operation\n\treturn operation.Execute(rs.client, baseURL, token, requestBody)\n}\n```","severity":"Critical","rationale":"This implementation violates the Open/Closed Principle because any change to the request format, endpoint, or headers requires direct modification of the `SendRequestBody` method (lines 15–49). This tightly couples the logic, making it difficult to extend for new request types or authentication schemes without editing existing code. Such rigidity hampers maintainability and increases the risk of introducing bugs when requirements evolve. Adhering to openClosed would allow new behaviors (e.g., custom headers or endpoints) to be added via extension—such as interfaces or strategy patterns—rather than modification, resulting in more robust and scalable code.","lineStart":20,"lineEnd":38,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The DefaultRequestSender directly depends on the concrete *http.Client type, violating dependency inversion by not relying on an abstraction.\n\n```go\ntype DefaultRequestSender struct{\n\tclient *http.Client\n}\n```","codeResolution":"The solution introduces an abstraction for sending requests, allowing the client code to depend on an interface rather than a concrete implementation, thus achieving proper dependency inversion.\n\n```go\n// Replace direct usage of DefaultRequestSender with the RequestSender interface\nfunc SendRequestBody(sender RequestSender, baseURL, token string, requestBody *RequestBody) (*http.Response, error) {\n    return sender.SendRequestBody(baseURL, token, requestBody)\n}\n```","severity":"Critical","rationale":"The code directly depends on the concrete *http.Client* type within *DefaultRequestSender*, violating dependency inversion. This tight coupling makes it difficult to substitute alternative HTTP clients (e.g., for testing or extending functionality), reducing maintainability and flexibility. Without abstraction, changes to the HTTP layer require modifications throughout the codebase, increasing the risk of bugs and making unit testing challenging. Introducing an interface for the HTTP client would decouple dependencies, improving testability and future extensibility.","lineStart":13,"lineEnd":38,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The DefaultRequestSender violates interface segregation by combining request creation, serialization, and sending logic into a single method, forcing clients to depend on all responsibilities.\n\n```go\nfunc (rs *DefaultRequestSender) SendRequestBody(baseURL, token string, requestBody *RequestBody) (*http.Response, error) {\n    // ... handles serialization, request creation, and sending ...\n}\n```","codeResolution":"The current DefaultRequestSender implementation can be improved by delegating request sending to a more focused abstraction, ensuring better adherence to the interface segregation principle:\n\n```go\n// Go\nfunc (rs *DefaultRequestSender) SendRequestBody(baseURL, token string, requestBody *RequestBody) (*http.Response, error) {\n\tsender := getRequestSender(rs.client)\n\treturn sender.SendJSON(baseURL+\"/api/objectGen\", token, requestBody)\n}\n```","severity":"High","rationale":"The current implementation violates the Interface Segregation Principle by combining request creation, serialization, and sending logic into a single method (`SendRequestBody`). This monolithic approach forces clients to depend on all aspects of the request process, even if they only need a subset of the functionality. Such tight coupling reduces maintainability, as changes to one responsibility (e.g., serialization) can impact unrelated consumers. It also hinders testability and flexibility, making it harder to swap out or mock specific behaviors. Refactoring into smaller, focused interfaces would improve modularity and adherence to interface segregation.","lineStart":17,"lineEnd":38,"status":""},{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The DefaultRequestSender violates Liskov Substitution Principle because it does not use an interface abstraction, preventing substitutability with other implementations.\n\n```go\ntype DefaultRequestSender struct{\n\tclient *http.Client\n}\n```","codeResolution":"To improve Liskov Substitution Principle adherence, the SendRequestBody logic should delegate to a RequestSender abstraction, allowing interchangeable implementations:\n\n```go\ngo\n// Replace direct usage of DefaultRequestSender with the RequestSender interface\nfunc SendRequestBody(sender RequestSender, baseURL, token string, requestBody *RequestBody) (*http.Response, error) {\n    return sender.SendRequestBody(baseURL, token, requestBody)\n}\n```","severity":"High","rationale":"The current implementation tightly couples the DefaultRequestSender to its own methods, lacking an interface abstraction. This violates the Liskov Substitution Principle because other request sender implementations cannot be substituted without changing client code. As a result, maintainability suffers—future enhancements or alternative senders (e.g., for testing or different protocols) require refactoring across the codebase. This rigidity also impacts correctness, as consumers cannot rely on polymorphic behavior. Introducing a RequestSender interface would allow seamless substitution, improving extensibility and adherence to LSP.","lineStart":9,"lineEnd":38,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"C-","liskovSubstitutionScore":"C-","openClosedScore":"F","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package client\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// DefaultRequestSender is a default implementation of RequestSender\ntype DefaultRequestSender struct{\n\tclient *http.Client\n}\n\n// NewDefaultRequestSender initializes a new DefaultRequestSender\nfunc NewDefaultRequestSender(client *http.Client) *DefaultRequestSender {\n\treturn &DefaultRequestSender{\n\t\tclient: client,\n\t}\n}\n\n// SendRequestBody sends a JSON request and returns a response\nfunc (rs *DefaultRequestSender) SendRequestBody(baseURL, token string, requestBody *RequestBody) (*http.Response, error) {\n\turl := baseURL + \"/api/objectGen\"\n\n\t// Serialize the request body to JSON\n\tjsonData, err := json.Marshal(requestBody)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error marshalling request body: %v\", err)\n\t}\n\n\t// Create an HTTP request\n\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating request: %v\", err)\n\t}\n\n\t// Set headers\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Authorization\", \"Bearer \"+token)\n\n\t// Send the request and return the response\n\tresp, err := rs.client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error sending request: %v\", err)\n\t}\n\n\treturn resp, nil\n}\n","reason":"Modified","start":1,"end":50,"grade":"D"}]},"hash":"d3b07376b505f35ebf98d592e4a59d7ec723c838816fa0d18279ecab5b940123","id":"eJydVEtP3DAQ/itTS60SSLP3lXoobFVaUUDs9uaLN5nsGrzjYE+KFsR/r/wILFVQJW6xZ/w95pFHobxH7zVtVtYaMRfLy/MfC1GJxrZ4aomRWMxFr5pbtUFojEZiSZL0rreOoZAkWYr1ntFLkQ5IjW01bWY33tJ42e14/CTk2Za5D+cyYM1msMBODYav8W5Az0ukFh1oDwraFAG96w3ukFixtgS2g1fJknjf4zSOZzc0/BjYkwE4Cvz1aXbzlEVc4P20DtKsldEPGAQR3k/SSOoGat4CKSaYSzia5ItKHfLgCD5NZcSE0cw8d6UKl08vbkJqfnVi2z14pDbo/7m8vACXAqCohcQUQg59b8ljtlI4P62w/Be8WCuPv6/PK2B7ixQqrmlTjTSR/+ggv4QiFeI6M1aAzllXJu+DMzD/AhkUjkGKmer1zK5vsOHvmKaKJEebLvUGeIvPvtaBkW00GxLDKC4Uq8gTsMNF/Us5v1WmOJAZBpJ1F9M+fAHSBnK1c0NImwq6HdffguCukCIqh13CMpo2r1TM4eMfKSJvmTuUlZ86VIygCM5Wq6vxUer93bPQWKYLvM/VK6S4ulyuAuLgTAVx80L8ZOg6dMVotHy3kSbIOnDxtoElMmxRteh8Vl2fxWO9xCA0/z8+r/Y9BgQpVN8b3cQNzn+HcvLl14G31umHmJmenqBy6ECK4zhi5YEKal/1/mWm8/U41IHI98+Vdb5Om1MvbBiBd1csbNb/C5ZBkgTSJm6qqESnDV4p3oq5SHJm7nDX6o0VT38B1o4LvA=="}
{"assessingTool":"Complexity","filePath":"client/processResponse.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:10:31.368Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode suffers from excessive vertical space and redundant error handling, resulting in unnecessary lines of code.\n\n```go\ndefer func(Body io.ReadCloser) {\n\terr := Body.Close()\n\tif err != nil {\n\t\tfmt.Println(\"Error closing body\")\n\t}\n}(resp.Body)\n```","codeResolution":"The code can be streamlined by delegating response parsing and error handling to dedicated helper functions, reducing lines of code and improving clarity.\n\n```go\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n\tdefer resp.Body.Close()\n\tif err := validateStatus(resp.StatusCode); err != nil {\n\t\treturn nil, err\n\t}\n\treturn parseResponse(resp.Body)\n}\n```","severity":"Critical","rationale":"## Rationale\n\nThe code snippet contains several lines that could be consolidated to reduce overall lines of code (LoC) without sacrificing readability. Excessive LoC, as seen in the verbose error handling and repeated struct initialization, increases maintenance overhead and makes future changes more error-prone. For example, the explicit defer function for closing the body could be simplified, and error messages could be handled more concisely. Reducing LoC improves maintainability and readability, making it easier to test and refactor the code. Streamlining logic also helps prevent bugs that arise from duplicated or scattered code.","lineStart":13,"lineEnd":29,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode exhibits excessive nestingDepth by embedding multiple control structures within a single function, reducing readability and maintainability.\n\n```go\nif resp.StatusCode != http.StatusOK {\n    return nil, fmt.Errorf(\"received non-200 response code: %d\", resp.StatusCode)\n}\nvar response Response\nif err := json.NewDecoder(resp.Body).Decode(&response); err != nil {\n    return nil, fmt.Errorf(\"error decoding response: %v\", err)\n}\n```","codeResolution":"The ResponseProcessor's ProcessResponse method can be refactored to reduce nesting depth by using guard clauses for error handling and early returns.\n\n```go\n// Go\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"received non-200 response code: %d\", resp.StatusCode)\n\t}\n\t\n\tvar response Response\n\terr := json.NewDecoder(resp.Body).Decode(&response)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error decoding response: %v\", err)\n\t}\n\treturn &response, nil\n}\n```","severity":"Critical","rationale":"## Rationale\n\nDeep nesting in `ProcessResponse` (e.g., nested `if` statements and a deferred function) increases cognitive complexity and makes the code harder to follow and maintain. If additional error handling or logic is added, the nesting will grow, further reducing readability and increasing the risk of subtle bugs. Flattening the structure with guard clauses or extracting logic into helper functions would improve maintainability and testability, making future changes less error-prone.","lineStart":22,"lineEnd":34,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode only defines a single method for all response processing, failing to separate concerns and violating functionMethodCounts best practices.\n\n```go\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n\tdefer func(Body io.ReadCloser) {\n\t\terr := Body.Close()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error closing body\")\n\t\t}\n\t}(resp.Body)\n```","codeResolution":"The ResponseProcessor's ProcessResponse method should be refactored to delegate responsibilities to specialized helper functions, improving functionMethodCounts and separation of concerns.\n\n```go\n// Go\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n\tdefer closeBody(resp.Body)\n\tif err := validateStatus(resp.StatusCode); err != nil {\n\t\treturn nil, err\n\t}\n\treturn decodeResponse(resp.Body)\n}\n```","severity":"Critical","rationale":"### Rationale\n\nThe code defines only one main method for processing responses, violating functionMethodCounts best practices. This concentration of logic in a single function makes the code harder to maintain and test, as changes to one responsibility (e.g., error handling, decoding) risk affecting others. For example, error handling for closing the body and decoding JSON are both handled inside `ProcessResponse`, increasing complexity and the chance of bugs. Separating these concerns into dedicated functions would improve readability, facilitate unit testing, and reduce the risk of regressions.","lineStart":7,"lineEnd":28,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The ProcessResponse method introduces unnecessary branching and nested error handling, resulting in elevated cyclomatic complexity.\n\n```go\nif resp.StatusCode != http.StatusOK {\n    return nil, fmt.Errorf(\"received non-200 response code: %d\", resp.StatusCode)\n}\n```","codeResolution":"The solution for cyclomatic complexity refactors the main decision logic into a single, focused abstraction, reducing nested branching and improving maintainability. Replace the original block with the following streamlined code:\n\n```go\n// Go\noperation := getOperation(resp.StatusCode)\nresult, err := operation.Execute(resp.Body)\nif err != nil {\n    return nil, fmt.Errorf(\"error processing response: %v\", err)\n}\nreturn result, nil\n```","severity":"Critical","rationale":"## Rationale\n\nHigh cyclomatic complexity in `ProcessResponse` arises from multiple branching paths: error handling for closing the body, status code checks, and JSON decoding. This increases the risk of missed edge cases and makes the function harder to test and maintain. If more conditions are added, the complexity will grow, making future changes error-prone. Refactoring into smaller, single-responsibility functions (e.g., separate body closing, status validation, and decoding) would reduce complexity, improve readability, and enhance testability.","lineStart":22,"lineEnd":38,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code strictly adheres to dependenciesModules principles, importing only essential standard libraries without introducing unnecessary external dependencies.\n\n```go\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n```","codeResolution":"The code demonstrates a clear and minimal use of dependencies, relying only on standard library packages for HTTP handling, JSON parsing, and I/O operations. To further improve modularity and separation of concerns, the response processing logic can be abstracted to use a dedicated interface for parsing, assuming a `ResponseParser` interface is defined elsewhere.\n\n```go\n// Replace the decoding block with an abstraction:\nif err := parser.Parse(resp.Body, &response); err != nil {\n    return nil, fmt.Errorf(\"error parsing response: %v\", err)\n}\n```","severity":"Critical","rationale":"## Rationale\n\nThe code imports four standard packages: `encoding/json`, `fmt`, `io`, and `net/http`. While all are necessary for HTTP response handling and JSON decoding, excessive or unnecessary imports can lead to bloated binaries and increased attack surface. For example, if `fmt` is only used for error logging, consider using a more robust logging package or centralizing error handling. Keeping dependencies minimal improves maintainability, reduces potential for version conflicts, and makes the codebase easier to audit and test. Regularly reviewing imports ensures only essential modules are included, supporting better long-term project health.","lineStart":3,"lineEnd":7,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A+","readability":"A","testability":"A-"},"issues":{"cyclomaticComplexity":3,"dependenciesModules":4,"functionMethodCounts":3,"linesOfCode":38,"nestingDepth":2}},"hash":"5b18b197dc300f83f0aa0d6d7e3530ab0b54d442ea88e9661bc35e3fb5250ae6","id":"eJx1U0uP0zAQ/iuDpUXJKqQrjkG9UJCQkJaq9OiLN560Bncc2dOWUvW/Iztx9tFys+fxPTzjs1AhYAiGNmvnrGjEwu16i38Mn0QlWqdx4YiRWDSiV+1vtUForUFiSZLMrneeoZAkWQqk1mlDm9mv4EiKIdjtOB+NyydCnm2Z+3gvI9BsBisMvaOAS+9aDMF58EPEPFmEznnoh4yhDfAW4dt6vcw1KIlPPd4ACez3LZ8vI8sjHq9rDBk2ypq/GEAB4fEaR1K3p/Zme1HeoD1Hox557+k6G9VkQWMw12STGJLHbA8UaRjghkSvfEA9QY82R5WF7+H+irV8y1VEdLiPg6hzrIRi6qwAvY99yYzGDj1E/OKz0ycwrl6h0gvrAuYayeg9NHOIFXVKFeWQMF1Eg3dzIGNzteRux/XSG2JLhRRfIx+01qUhPzl9kmLsj+/FlyS5juhpbRJsCv1kxfuwcBojRbI0hH58z2TjNMjYCiJtIusKKTy2aA6ogRx9+Pjw8Pzqcf8buNNSVG9pkqzLIOKg/HPPatrIyXQzh/gl6kc8fsGI6V/4qIdQ8T4jlJ9uvNR/xacRgcbh600yGrg7RNXo/UulI8zEVUXEtIyiEp2xuFS8FY0Yvvisf70w9caJyz9tsow2"}
{"assessingTool":"SOLID","filePath":"client/processResponse.go","grade":"F","username":"HLamb","timestamp":"2025-10-12T17:10:04.001Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The ResponseProcessor type is tightly coupled to a specific implementation and does not use interface abstraction, violating Liskov Substitution Principle.\n\n```go\n// ResponseProcessor responsible for processing the HTTP response\ntype ResponseProcessor struct{}\n```","codeResolution":"The revised solution introduces an abstraction for response processing, enabling substitutability and adherence to the Liskov Substitution Principle.\n\n```go\n// Go\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n    operation := getOperation(resp)\n    return operation.Execute(resp)\n}\n```","severity":"Critical","rationale":"This implementation tightly couples response processing logic to the `ResponseProcessor` concrete type, violating Liskov Substitution Principle. Without an interface abstraction, alternative response processors cannot be substituted, making the code rigid and difficult to extend or test. This reduces maintainability, as any change requires modifying the core type rather than swapping implementations. It also impacts correctness: if specialized processing is needed (e.g., for different response formats), the lack of substitutability forces unsafe workarounds or code duplication. Introducing a `ResponseProcessor` interface would allow flexible, testable, and robust code that adheres to Liskov Substitution.","lineStart":17,"lineEnd":41,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The ResponseProcessor violates interface segregation by combining response parsing, error handling, and resource management into a single struct, forcing clients to depend on all responsibilities.\n\n```go\ntype ResponseProcessor struct{}\n\n// ProcessResponse processes the response and returns the parsed Response struct\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n\tdefer func(Body io.ReadCloser) {\n\t\terr := Body.Close()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error closing body\")\n\t\t}\n\t}(resp.Body)\n```","codeResolution":"The revised solution applies interface segregation by delegating response parsing to a dedicated abstraction, ensuring ResponseProcessor only depends on the minimal interface it requires.\n\n```go\n// Go\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"received non-200 response code: %d\", resp.StatusCode)\n\t}\n\n\tparser := getResponseParser() // Returns an implementation of ResponseParser\n\treturn parser.Parse(resp.Body)\n}\n```","severity":"Critical","rationale":"This implementation violates interface segregation by combining response parsing, error handling, and resource management into a single struct (ResponseProcessor). This monolithic design forces clients to depend on all processing logic, even if they only need a subset (e.g., just decoding JSON). Such coupling reduces maintainability, as changes to one responsibility can inadvertently affect others. It also complicates testing, since mocking or replacing only the decoding logic is not possible without inheriting unrelated concerns. Adhering to interface segregation would allow more focused, reusable components, improving correctness and flexibility.","lineStart":15,"lineEnd":27,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The ResponseProcessor violates openClosed principles by requiring modification of its core logic to support new response formats or processing behaviors.\n\n```go\nif err := json.NewDecoder(resp.Body).Decode(&response); err != nil {\n    return nil, fmt.Errorf(\"error decoding response: %v\", err)\n}\n```","codeResolution":"The revised solution introduces an abstraction layer for response processing, enabling extension without modifying existing code and thus adhering to the Open/Closed Principle.\n\n```go\n// Go\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n    operation := getOperation(resp.StatusCode)\n    return operation.Execute(resp.Body)\n}\n```","severity":"Critical","rationale":"This implementation violates the Open/Closed Principle because any change to the response format or addition of new response types requires modifying the `ProcessResponse` method directly (lines 15–29). This tightly couples parsing logic to a single struct, making the code harder to extend and maintain. As requirements evolve, such as supporting XML or custom error handling, developers must repeatedly alter core logic, increasing the risk of bugs and regressions. Refactoring to use interfaces or strategy patterns would allow new response types to be added without changing existing code, improving maintainability and correctness.","lineStart":23,"lineEnd":27,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The ResponseProcessor directly depends on concrete types and lacks abstraction, violating dependency inversion principles.\n\n```go\ntype ResponseProcessor struct{}\nfunc NewResponseProcessor() ResponseProcessor {\n\treturn ResponseProcessor{}\n}\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n```","codeResolution":"The revised solution introduces an abstraction layer for response processing, enabling flexible dependency injection and improved testability.\n\n```go\n// Go\ntype ResponseProcessor interface {\n    ProcessResponse(resp *http.Response) (*Response, error)\n}\n\n// Usage with injected abstraction\nfunc HandleResponse(rp ResponseProcessor, resp *http.Response) (*Response, error) {\n    return rp.ProcessResponse(resp)\n}\n```","severity":"Critical","rationale":"This code violates dependency inversion by directly depending on the concrete *http.Response* type within *ProcessResponse* (lines 13–32). This tight coupling makes the code harder to test, extend, or reuse, since any change to the response source or format requires modifying the processor itself. By not abstracting the response handling (e.g., via an interface), maintainability suffers and mocking for unit tests becomes difficult. Refactoring to depend on abstractions would improve flexibility and testability, aligning with dependency inversion principles.","lineStart":13,"lineEnd":41,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"F","liskovSubstitutionScore":"F","openClosedScore":"F","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package client\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n\n// ResponseProcessor responsible for processing the HTTP response\ntype ResponseProcessor struct{}\n\n// NewResponseProcessor initializes a new ResponseProcessor\nfunc NewResponseProcessor() ResponseProcessor {\n\treturn ResponseProcessor{}\n}\n\n// ProcessResponse processes the response and returns the parsed Response struct\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n\tdefer func(Body io.ReadCloser) {\n\t\terr := Body.Close()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error closing body\")\n\t\t}\n\t}(resp.Body)\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"received non-200 response code: %d\", resp.StatusCode)\n\t}\n\n\tvar response Response\n\tif err := json.NewDecoder(resp.Body).Decode(&response); err != nil {\n\t\treturn nil, fmt.Errorf(\"error decoding response: %v\", err)\n\t}\n\n\treturn &response, nil\n}\n","reason":"Modified","start":1,"end":38,"grade":"F"}]},"hash":"5084220b86fa051673fce7ba420d3e4965d0c14107a99df322da5c532f28b663","id":"eJx1U0tv2zAM/iucgA524TnFji5yWTpgw4Y2SHPUxbVoR5tDGRKTIAvy3wdJlts12U3i43uI1EnUzqFzmrq1Mb2oxPPTz+8PohCNUbgwxEgsKjHUze+6Q2h6jcSSJOntYCxDJkmyFEiNUZq62S9nSIoYbLecjtqkEyHPNsyDv+ceaDaDFbrBkMOlNQ06ZyzYGNEvPUJrLAwxo6kD3iB8W6+XqQYl8XHAKyCO7a7h03lkecTDZY0mzbru9R90UAPh4RJHUruj5mp7ll+hPXmjFnln6TLr1SRBYzDVJJPogsdkD2pSEOFiYqitQzVBjzZHlZkd4PaCNX/PlXl0uPWDKFMsh2zqLACt9X3BjMIWLXj87ItRR9CmXGGtFr1xmGoko7VQzcFXlCGV5TGhW48GH+ZAuk/Vktstl0uriXvKpPjq+aDpTRjyi1FHKcZ+/158DpJLjx7WJsCG0DPXvHMLo9BTBEsx9PQjkY3TIN0X4GkDWZtJYbFBvUcFZOjT57u711f3+1/BjZKieE8TZJ2jiH1tX3tW00ZOpqs5+C9RPuLhAT2mfeOjjKHsY0LI76+81H/FhxGBwvj1JhkV3Oy9arT2rdIRZuIqPGJYRlGIVve4rHkjKhG/+Gz4d2HKzojzXzDhiYM="}
{"assessingTool":"Complexity","filePath":"client/gzipRequestSender.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:09:58.829Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":5,"dependenciesModules":6,"functionMethodCounts":2,"linesOfCode":67,"nestingDepth":2}},"hash":"108e9c8181688efe13809e4c427ed98d5c41775deccbce6f99cea027e059369d","id":"eJydVVFP2zAQ/is3S0MJlPS9Eg+jINC0AaKdJk2RJje5pIbUDvaFrkz89+lsp7RrYRNPrS9393333fn8W0jn0Dml66kxjRiJsVm0Df5StBIDUZgSx0YTahIj0criXtYIRaNQU65zrRatsQRJrnPKxWxF6HIRDoVZtBadG9ZPqu2NqAtTKl0P75zRvbFaUP9XIw3nRN4/ZYDhEC5+qPYWHzp0NEFdogXlQIINJnDBRnNJ0GOiA5rj2mVmyhV0XCN4MppWLe7J68h2Bf1mKqFEOGQy2TjW+xwZXeFyDymtSMlGPSGz07jcBch11elib3iyBzCFw10Yz84idVbDwc5n/7VnP4qNGrDx+YU+u8aoU1aGFWTOrM3xWsISPk+ur9YaSl1CgA3iu9Zoh7GipLZuD9n0b6hkJh1+u/0yADL3qFlwpetBD+LZHG74p5AEQW4j3gDQWmPTIENnGxidQEwKR5CLoWzV0MzusKALDBOmc/JF29Cd3ckg40tlRx7LM0nS43BuNmRfpXVz2SQbNHk4SVXe7cMJaNVA1D72RqtmANWCsnMmXCW58MxhEXI1PIybLEbw8TEXHjeN/YrMx7EjnrjvSSlJbs1zTo/Svkx/ySWAv43ZaVdVPHk5set3qwh9YXzKrnAZLMnBdnAa0H8GHYJ38Mz8T9IL9boOGyHjxjhM0v/SZ2kVcWFkPKg/o31FnR1yG0jvaU7RmLWqbyNzXyxKQpAaLqfTm3Uzl4rmvlUbN4kbFu7tw3qy/Fxf4TKOe5KLm+vJlKE62wxgT0PeVxKz3Bi21+uZIMEcZYnWwTEoXTRduRajX9yxiuzSO2YTZOLxhTierlrk3LmQbduoQpIyOq769M3I8z69jw4vxv6ITx3NjVVPPndwP0Vp0UIujvxWSTcq0uXWdX9ZYtHcbzEGcu26N7V1Wdid2Znha/9u+Xm3/lv9mCRw0Krxu1oMRKUavJE0FyMR6PjHdGvHZrURz38ASFfPtQ=="}
{"assessingTool":"SOLID","filePath":"client/gzipRequestSender.go","grade":"C-","username":"HLamb","timestamp":"2025-10-12T17:09:42.583Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"openClosed","violatingCode":"The GZipRequestSender violates openClosed by requiring modification of its implementation to support new compression or serialization strategies.\n\n```go\n// Compress the JSON data using gzip\nvar compressedData bytes.Buffer\ngzipWriter := gzip.NewWriter(&compressedData)\n\n_, err = gzipWriter.Write(jsonData)\n```","codeResolution":"The current SendRequestBody implementation tightly couples gzip compression logic, making it difficult to extend for other compression algorithms. Refactoring to use an abstraction for compression resolves openClosed concerns:\n\n```go\ngo\n// Use the CompressionStrategy abstraction to compress data\ncompressedData, err := grs.compressor.Compress(jsonData)\nif err != nil {\n    return nil, fmt.Errorf(\"compression error: %v\", err)\n}\n\n// Create an HTTP request with the compressed data\nreq, err := http.NewRequest(\"POST\", url, bytes.NewReader(compressedData))\n```","severity":"High","rationale":"The current implementation tightly couples the GZipRequestSender to gzip compression and JSON serialization, violating the Open/Closed Principle. If a new compression algorithm or serialization format is needed, the SendRequestBody method (lines 17–56) must be modified directly, increasing the risk of introducing bugs and making future extensions harder. This approach reduces maintainability, as changes require editing core logic rather than adding new, isolated components. Adhering to openClosed would allow new behaviors to be added via interfaces or composition, improving flexibility and reducing the likelihood of regressions.","lineStart":31,"lineEnd":38,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The GZipRequestSender violates interface segregation by combining request compression, serialization, and HTTP transmission into a single struct, forcing clients to depend on all functionalities even if they only need one.\n\n```go\ntype GZipRequestSender struct{\n\tclient *http.Client\n}\n```","codeResolution":"The GZipRequestSender solution improves interface segregation by delegating compression and serialization to specialized abstractions, reducing class responsibility and enhancing maintainability.\n\n```go\n// Go\nfunc (grs *GZipRequestSender) SendRequestBody(baseURL, token string, requestBody *RequestBody) (*http.Response, error) {\n\turl := baseURL + \"/api/objectGen\"\n\tcompressedData, err := CompressAndSerialize(requestBody) // Uses abstraction\n\tif err != nil { return nil, err }\n\treq, err := http.NewRequest(\"POST\", url, compressedData)\n\tif err != nil { return nil, err }\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Content-Encoding\", \"gzip\")\n\treq.Header.Set(\"Authorization\", \"Bearer \"+token)\n\treturn grs.client.Do(req)\n}\n```","severity":"Critical","rationale":"This implementation violates the Interface Segregation Principle by combining request sending, JSON serialization, and gzip compression into a single GZipRequestSender struct and method (see lines 13–54). This tightly coupled design forces clients to depend on all behaviors, even if they only need one. Such coupling reduces maintainability, as changes to compression or serialization logic require modifying the same component. It also impairs testability, since mocking or substituting individual responsibilities is difficult. Separating concerns into focused interfaces (e.g., Compressor, Serializer, RequestSender) would improve modularity and allow clients to depend only on what they use.","lineStart":15,"lineEnd":44,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The GZipRequestSender directly depends on the concrete *http.Client type, violating dependency inversion by not relying on an abstraction.\n\n```go\ntype GZipRequestSender struct{\n\tclient *http.Client\n}\n```","codeResolution":"The revised solution introduces an abstraction for sending requests, allowing GZipRequestSender to depend on a generic RequestSender interface rather than directly on http.Client.\n\n```go\n// Go\ntype GZipRequestSender struct {\n\tsender RequestSender\n}\n\nfunc NewGZipRequestSender(sender RequestSender) *GZipRequestSender {\n\treturn &GZipRequestSender{sender: sender}\n}\n```","severity":"Critical","rationale":"This code violates dependency inversion by tightly coupling `GZipRequestSender` to the concrete `http.Client` type (see lines 8, 13, and 46). This direct dependency makes it difficult to substitute alternative HTTP clients (e.g., for testing or extending functionality), reducing maintainability and flexibility. Without an abstraction (such as an interface for the client), the code is harder to test in isolation and more prone to breaking if the underlying implementation changes. Introducing an interface for the HTTP client would improve testability and adherence to dependency inversion principles.","lineStart":8,"lineEnd":38,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"D-","liskovSubstitutionScore":"A","openClosedScore":"C-","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package client\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// GZipRequestSender is a request sender that compresses the request body using gzip\ntype GZipRequestSender struct{\n\tclient *http.Client\n}\n\n// NewGZipRequestSender initializes a new GZipRequestSender\nfunc NewGZipRequestSender(client *http.Client) *GZipRequestSender {\n\treturn &GZipRequestSender{\n\t\tclient: client,\n\t}\n}\n\n// SendRequestBody sends a gzip-compressed JSON request and returns a response\nfunc (grs *GZipRequestSender) SendRequestBody(baseURL, token string, requestBody *RequestBody) (*http.Response, error) {\n\turl := baseURL + \"/api/objectGen\"\n\n\t// Serialize the request body to JSON\n\tjsonData, err := json.Marshal(requestBody)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error marshalling request body: %v\", err)\n\t}\n\n\t// Compress the JSON data using gzip\n\tvar compressedData bytes.Buffer\n\tgzipWriter := gzip.NewWriter(&compressedData)\n\n\t_, err = gzipWriter.Write(jsonData)\n\tif err != nil {\n\t\tgzipWriter.Close()\n\t\treturn nil, fmt.Errorf(\"error writing to gzip writer: %v\", err)\n\t}\n\n\terr = gzipWriter.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error closing gzip writer: %v\", err)\n\t}\n\n\t// Create an HTTP request with the compressed data\n\treq, err := http.NewRequest(\"POST\", url, &compressedData)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating request: %v\", err)\n\t}\n\n\t// Set headers - including gzip encoding\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Content-Encoding\", \"gzip\")\n\treq.Header.Set(\"Authorization\", \"Bearer \"+token)\n\n\t// Send the request and return the response\n\tresp, err := grs.client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error sending request: %v\", err)\n\t}\n\n\treturn resp, nil\n}\n","reason":"Modified","start":1,"end":67,"grade":"C-"}]},"hash":"762e250541d7a09c2b74699a1b1b687084d296a21acafb5b6506a68bdb82437b","id":"eJydVVFP2zAQ/is3S0MJlPS9Eg+jINjECqKdJk2RJje5tobUDvaFqiD++3S2U9K1sImn1pe7+7777nx+FtI5dE7p+cSYSgzE+Prq65noicKUODSaUJMYiFoW93KOUFQKNeU612pZG0uQ5DqnXEzXhC4X4VCYZW3Ruf78SdWtEXVhSqXn/TtndGucLan9q5H6CyLvnzJAvw8Xv1R9iw8NOhqjLtGCciDBBhO4YKOFJGgx0QEtcOMyNeUaGi4PPBlN6xr35HVkm4KemUooEQ6ZTDaM9b5ERiNc7SGlFSlZqSdkdhpXuwC5njW62Bue7AFM4XAXxrOzSI3VcLDz2X9t2Q9io3psfHmlz64x6pSVYQWZM2tzvJGwhG/j69FGQ6lLCLBBfFcb7TBWlMyt20M2/RsqmUqHP26vekDmHjULrvS814J4Nocd/xSSIMhtxOsBWmtsGmRobAWDE4hJ4Qhy0Ze16pvpHRZ0gWHCdE6+aBu6szsZZHyp7MhjeSZJehzOzYbsu7RuIaukQ5OHk9TMu306Aa0qiNrH3mhV9WC2pOycCc+SXHjmsAy5Kh7GLosBfH7MhcdNY78i82HsiCfue1JKklvznNOjtK/TX3IJ4G9jdtrMZjx5ObHrT6sIfWF8yka4CpbkYDs4Dei/gw7BO3hm/idphXpbh07IsDIOk/S/9FlZRVwYGQ/qz2jfUGeHXAfpI80pKrNR9X1k7otFSQhSw+VkcrNp5krRwreqc5O4YeHePmwmy8/1CFdx3JNc3FyPJwzV2KoHexrysZKYZWfY3q5njAQLlCVaB8egdFE15UaMdnHHKrJL75iNkYnHF+J4sq6Rc+dC1nWlCknK6Ljq03cjz9v0Pjq8GPsjvjS0MFY9+dzB/RSlRQu5OPJbJe1UpMut6/66xKK53WIM5OpNb+bWZWF3ZmeGr/2H5efd+m/1Y5LAQavK72rREzNV4Y2khRiIQMc/pls7Npsb8fIHZSfNAg=="}
{"assessingTool":"Complexity","filePath":"client/extractValue.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:10:21.106Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"nestingDepth","violatingCode":"The extractValue function unnecessarily increases nesting depth by embedding error handling and logic within multiple if statements and a deferred closure.\n\n```go\nif resp.StatusCode != http.StatusOK {\n\treturn nil, fmt.Errorf(\"request failed with status: %s\", resp.Status)\n}\n\nbody, err := io.ReadAll(resp.Body)\nif err != nil {\n\treturn nil, fmt.Errorf(\"error reading response body: %w\", err)\n}\n```","codeResolution":"The extractValue function’s nesting depth can be reduced by using guard clauses for error handling, improving readability and maintainability.\n\n```go\nfunc extractValue(resp *http.Response) (*Res, error) {\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"request failed with status: %s\", resp.Status)\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading response body: %w\", err)\n\t}\n\n\tvar res Res\n\tif err := json.Unmarshal(body, &res); err != nil {\n\t\treturn nil, fmt.Errorf(\"error unmarshalling response body: %w\", err)\n\t}\n\n\treturn &res, nil\n}\n```","severity":"Critical","rationale":"### Rationale\n\nDeep nesting in `extractValue` (lines 15–36) increases cognitive complexity, making the code harder to read and maintain. Multiple layers of error handling and resource management are embedded within the main logic, which can obscure the function’s intent and complicate future changes or debugging. Excessive nesting also hinders unit testing, as tightly coupled branches are difficult to isolate. Refactoring with guard clauses or splitting responsibilities into helper functions would flatten the structure, improving maintainability and reducing the risk of subtle bugs.","lineStart":22,"lineEnd":28,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code adheres to dependenciesModules principles by only importing necessary standard library packages, resulting in a clean and maintainable dependency footprint.\n\n```go\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n```","codeResolution":"The solution for dependenciesModules demonstrates a minimal and focused use of standard library packages, ensuring clarity and maintainability.\n\n```go\npackage client\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n)\n\n// extractValue now delegates error handling and body closing to helper functions.\nfunc extractValue(resp *http.Response) (*Res, error) {\n\tif err := checkResponse(resp); err != nil {\n\t\treturn nil, err\n\t}\n\tbody, err := readBody(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn parseRes(body)\n}\n```","severity":"Critical","rationale":"The rationale for dependenciesModules is to ensure that only necessary packages are imported, minimizing bloat and reducing the attack surface. In the provided code, all imported packages (`encoding/json`, `fmt`, `io`, `net/http`) are standard and directly used, which is good practice. However, unnecessary imports or unused dependencies can lead to increased binary size, slower builds, and confusion for maintainers. Keeping dependencies minimal and relevant improves maintainability, reduces potential vulnerabilities, and makes the codebase easier to audit and update.","lineStart":3,"lineEnd":6,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The code violates functionMethodCounts principles by placing all logic—error handling, reading, and unmarshalling—inside a single function, reducing maintainability and clarity.\n\n```go\nfunc extractValue(resp *http.Response) (*Res, error) {\n\tdefer func(Body io.ReadCloser) {\n\t\terr := Body.Close()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"error closing response body:\", err)\n\t\t}\n\t}(resp.Body)\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"request failed with status: %s\", resp.Status)\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading response body: %w\", err)\n\t}\n\n\tvar res Res\n\tif err := json.Unmarshal(body, &res); err != nil {\n\t\treturn nil, fmt.Errorf(\"error unmarshalling response body: %w\", err)\n\t}\n\n\treturn &res, nil\n}\n```","codeResolution":"The extractValue function currently combines multiple responsibilities, making the code harder to maintain and test. To improve functionMethodCounts, delegate each responsibility to dedicated helper functions:\n\n```go\n// Go\nfunc extractValue(resp *http.Response) (*Res, error) {\n\tif err := validateResponse(resp); err != nil {\n\t\treturn nil, err\n\t}\n\tbody, err := readResponseBody(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn parseRes(body)\n}\n```","severity":"Critical","rationale":"The code defines only one function, `extractValue`, which handles multiple responsibilities: closing the response body, checking the status code, reading the body, and unmarshalling JSON. This violates functionMethodCounts principles by concentrating too much logic in a single function. Such design makes the code harder to maintain, test, and extend, as changes to one aspect (e.g., error handling or parsing) risk affecting others. Splitting these responsibilities into smaller, focused functions would improve readability, facilitate unit testing, and reduce the likelihood of bugs.","lineStart":13,"lineEnd":27,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The extractValue function contains multiple sequential error checks and nested logic, resulting in elevated cyclomatic complexity and reduced clarity.\n\n```go\nif resp.StatusCode != http.StatusOK {\n\treturn nil, fmt.Errorf(\"request failed with status: %s\", resp.Status)\n}\n```","codeResolution":"The extractValue function’s cyclomatic complexity can be reduced by delegating error handling and response parsing to helper abstractions, resulting in clearer and more maintainable code.\n\n```go\n// Go\nfunc extractValue(resp *http.Response) (*Res, error) {\n\tdefer closeBody(resp.Body)\n\tif err := checkResponse(resp); err != nil {\n\t\treturn nil, err\n\t}\n\treturn parseResponse(resp.Body)\n}\n```","severity":"Critical","rationale":"Cyclomatic complexity is important because it directly impacts code maintainability and testability. In the provided code, the function `extractValue` contains multiple branching paths: error handling for closing the response body (lines 11–15), status code checks (lines 17–19), reading the body (lines 21–24), and unmarshalling JSON (lines 26–29). Each conditional adds to the complexity, making the function harder to reason about and increasing the risk of missed edge cases or bugs. High cyclomatic complexity can slow down future development and complicate unit testing, as every branch must be covered. Refactoring into smaller, single-responsibility functions would reduce complexity and improve reliability.","lineStart":22,"lineEnd":27,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The extractValue function is overly verbose, with multiple nested error checks and resource management, resulting in unnecessary lines of code.\n\n```go\nbody, err := io.ReadAll(resp.Body)\nif err != nil {\n\treturn nil, fmt.Errorf(\"error reading response body: %w\", err)\n}\n```","codeResolution":"The extractValue function can be streamlined to reduce lines of code and improve clarity by delegating error handling and response parsing to helper abstractions.\n\n```go\n// Go\nfunc extractValue(resp *http.Response) (*Res, error) {\n\treturn parseResponse(resp)\n}\n```","severity":"Critical","rationale":"### Rationale\n\nThe code snippet contains 27 non-comment, non-blank lines, which is reasonable but could be further reduced by extracting error handling and resource cleanup into helper functions. Excess lines of code increase cognitive load and make future maintenance harder, especially when error handling is repeated or deeply nested. For example, the inline deferred closure for `resp.Body` (lines 11–15) and repeated error checks could be abstracted, improving readability and maintainability. Streamlining these patterns would make the codebase easier to test and less prone to subtle bugs, while also clarifying the main logic flow.","lineStart":17,"lineEnd":28,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A","readability":"A+","testability":"A-"},"issues":{"cyclomaticComplexity":3,"dependenciesModules":4,"functionMethodCounts":2,"linesOfCode":41,"nestingDepth":2}},"hash":"48867837ec72b831f5c44fd017a923646405fa7de26d2d0528a66de492cba02f","id":"eJyVU0uP0zAQ/iuDpUXpqkrvQT1AhYTEYatSuGCkNckkNTjjYE92t6r639HYyW6XhwQ52eP5HvPZOSkTI8Zoqdt771SlNr4fHD5YPqqlqn2DG0+MxKpSg6m/mw6hdhaJNWmy/eADQ6FJs1ZItW8sdatv0ZNWudj2PC+tn1eEvDowD7JfCNFqBTuM0GBrCSMYiBzGmseAcG/5IAVLnUOpW+qgtegaTXwcMAFzO5yE/pNx42Pjr9+teKu0upMmrW4FcMMHDNCb4XMGfbHEGFpT4+n8CEhNCXCeDOMDB1NPctMmAh8QEjm0wfdp+26/30LAOHiKCIYaCMhjIJnzybymdqT6GWshILiWpMrdhF9Acb3DuAQMwYdFHrnBFgMIvnjjmyNYX+7QNBvnI849mjEEqNYgHWU6Khb5wLbCBi/WQNbN3ZrbnsttsMSOCq2SHtTOy008jfPVN8dKq+RnopOA+JzMlyKWbjippNIHNjzGjW9QFNNwuXTzftbO+YibJYiLt6LdFloF/DFiZGiNddjktxETuIKrKDYuJJKdcxYXm8mjJDDF89q55yb/HMRfzeREAprm90Tg6v4ylMnFnZH+KLd+IVetQR5Z+ZF6E+LBuCK7fRkwLl79v6Nx5nH/6msiFMGl0KZHrpaqtQ63hg+qUvmnX10+z7Lz6vwTlM2F+w=="}
{"assessingTool":"SOLID","filePath":"client/extractValue.go","grade":"D-","username":"HLamb","timestamp":"2025-10-12T17:09:52.599Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependencyInversion","violatingCode":"The extractValue function directly depends on the concrete *http.Response type, violating dependency inversion by not relying on abstractions.\n\n```go\nfunc extractValue(resp *http.Response) (*Res, error) {\n\tdefer func(Body io.ReadCloser) {\n\t\terr := Body.Close()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"error closing response body:\", err)\n\t\t}\n\t}(resp.Body)\n```","codeResolution":"The extractValue function should be refactored to depend on an abstraction for reading and parsing HTTP responses, improving testability and flexibility. Replace the original block with a call to the new abstraction:\n\n```go\ngo\nfunc extractValue(resp *http.Response) (*Res, error) {\n    parser := getResponseParser() // returns an abstraction implementing ResponseParser\n    return parser.Parse(resp)\n}\n```","severity":"Critical","rationale":"This code tightly couples the extractValue function to the net/http and encoding/json packages, violating dependency inversion principles. By directly depending on concrete implementations, it becomes difficult to substitute alternative HTTP clients or JSON parsers for testing or future changes. This rigidity reduces maintainability and testability, as mocking or swapping dependencies requires significant refactoring. Adhering to dependency inversion by introducing interfaces for HTTP and JSON handling would make the codebase more flexible and robust against changes.","lineStart":15,"lineEnd":33,"status":""},{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The extractValue function violates Liskov Substitution Principle by tightly coupling its logic to the concrete *http.Response type, preventing substitution with other response implementations.\n\n```go\nfunc extractValue(resp *http.Response) (*Res, error) {\n    // ...\n}\n```","codeResolution":"The extractValue function is refactored to utilize an abstraction for response parsing, enabling substitutability and adherence to the Liskov Substitution Principle.\n\n```go\n// Go\nfunc extractValue(resp *http.Response) (*Res, error) {\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"request failed with status: %s\", resp.Status)\n\t}\n\tparser := getOperation(\"responseParser\") // returns an Operation interface\n\treturn parser.Parse(resp.Body)\n}\n```","severity":"Critical","rationale":"This code violates Liskov Substitution Principle because the extractValue function is tightly coupled to the http.Response type and the specific Res struct. There is no abstraction or interface that allows alternative response types or result structures to be substituted. This rigidity makes the code harder to maintain and extend, as any change in response handling or result format requires direct modification of extractValue. It also hinders testability, since mocking or substituting different response sources is not straightforward. Introducing interfaces for response reading and result parsing would improve substitutability, leading to more flexible and robust code.","lineStart":13,"lineEnd":38,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The extractValue function violates the Open/Closed Principle because any change to the response structure requires modifying the Res type and the unmarshalling logic.\n\n```go\ntype Res struct {\n    Value string                 `json:\"value\"`\n    Other map[string]interface{} `json:\"Other\"`\n}\n```","codeResolution":"The extractValue function can be refactored to delegate value extraction logic to an abstraction, improving adherence to the Open/Closed Principle and enabling easier extension for different response formats.\n\n```go\ngo\nfunc extractValue(resp *http.Response) (*Res, error) {\n    op := getOperation(resp)\n    return op.Extract(resp)\n}\n```","severity":"High","rationale":"The current implementation tightly couples the extraction logic to a specific response structure (`Res`). This violates the Open/Closed Principle because supporting new response formats or extracting additional fields would require modifying the `extractValue` function directly. Such changes increase the risk of introducing bugs and make the code harder to maintain as requirements evolve. Ideally, the extraction logic should be extensible—using interfaces or strategy patterns—so new formats can be supported without altering existing code. This would improve maintainability and correctness, allowing the codebase to adapt to future needs with minimal disruption.","lineStart":23,"lineEnd":44,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The code does not define any interfaces, forcing all clients to depend on a monolithic function rather than fine-grained abstractions, thus violating interface segregation.\n\n```go\nfunc extractValue(resp *http.Response) (*Res, error) {\n    // ...\n}\n```","codeResolution":"The extractValue function is refactored to utilize an abstraction for response extraction, promoting interface segregation and single responsibility.\n\n```go\n// Go\nfunc extractValue(resp *http.Response) (*Res, error) {\n    extractor := getOperation(\"responseExtractor\")\n    return extractor.Execute(resp)\n}\n```","severity":"Critical","rationale":"This code violates interface segregation by tightly coupling HTTP response handling, JSON parsing, and resource management within a single function (`extractValue`). This monolithic approach makes the code harder to maintain and test, as changes to one responsibility (e.g., parsing logic) could inadvertently affect others (e.g., error handling or resource cleanup). By not separating concerns into focused interfaces or functions, future extensions or substitutions (such as supporting different response formats or error strategies) become cumbersome and error-prone. Adhering to interface segregation would improve modularity, allowing each responsibility to evolve independently and enhancing overall maintainability.","lineStart":17,"lineEnd":34,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"F","liskovSubstitutionScore":"F","openClosedScore":"C-","singleResponsibilityScore":"A"},"codeDiff":{"changes":[{"newCode":"package client\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n\n// Res defines a structure with a single string field\ntype Res struct {\n\tValue string                 `json:\"value\"`\n\tOther map[string]interface{} `json:\"Other\"`\n}\n\n// extractValue extracts the value from the HTTP response and returns a Res struct\nfunc extractValue(resp *http.Response) (*Res, error) {\n\tdefer func(Body io.ReadCloser) {\n\t\terr := Body.Close()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"error closing response body:\", err)\n\t\t}\n\t}(resp.Body)\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"request failed with status: %s\", resp.Status)\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading response body: %w\", err)\n\t}\n\n\tvar res Res\n\tif err := json.Unmarshal(body, &res); err != nil {\n\t\treturn nil, fmt.Errorf(\"error unmarshalling response body: %w\", err)\n\t}\n\n\treturn &res, nil\n}\n","reason":"Modified","start":1,"end":41,"grade":"D-"}]},"hash":"544d15efea2280c3675258b68ecf15f6c33cbee06de8e1ae76debce2f1d09489","id":"eJyVU21v0zAQ/iuHpaF0qtLvQf0ABQkEUquu8AVPmkkuicE5B/uyUU397+icZOt4kSCf7PM9L/fYuVcmRozRUnPw3qlCXW0/vHutlqr0FW48MRKrQvWm/GYahNJZJNakyXa9DwyZJs1aIZW+stSsvkZPWo3FuuN5af28IuRVy9zLfiFEqxXsMUKFtSWMYCByGEoeAsKd5VYKlhqHUrfUQG3RVZr42GMCju1wL/SfjBseGn/9bsRbodWtNGl1I4AttxigM/3nEXRtiTHUpsT70wMgNSXAaTKMPziYcpKbNhG4RUjkUAffpe3bw2EHAWPvKSIYqiAgD4FkzkfzmuqByiesmYDgUpLK9xN+AdnlHuMSMAQfFuPIFdYYQPDZK18dwfp8j6baOB9x7tGMIUCxBunI01G2GA9sLWzwbA1k3dytue443wVL7CjTKulB6bzcxOM4X3x1LLRKfiY6CYhPyXwuYumGk0oqXbHhIW58haKYhhtL2/ez9piPuFmCuHgj2nWmVcDvA0aG2liH1fg2YgIXcBHFxplEsnMaxcVm8igJTPG8dO6pyT8H8VczYyIBTfV7InBxdx7K5OLWSH+UWz+TK9Ygjyz/SJ0JsTUuG90+DxgXL/7f0TDzuH/1NRGK4FJo0yNXS1VbhzvDrSrU+NOvzp9n3nh1+gkvf4NI"}
{"assessingTool":"Complexity","filePath":"jsonSchema/model.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:11:05.425Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode exhibits excessive nesting within its struct definitions, making the code harder to read and maintain.\n\n```go\ntype Definition struct {\n\tProperties map[string]Definition `json:\"properties\"`\n\tItems *Definition `json:\"items,omitempty\"`\n\tHashMap *HashMap\n}\n```","codeResolution":"To address excessive nesting depth, the solution refactors deeply nested logic into clear, single-responsibility function calls, improving readability and maintainability.\n\n```go\n// Original deeply nested block:\nif def.Choices != nil && len(def.Choices.Options) > 0 {\n    // ...complex selection logic...\n}\n\n// Replacement using abstraction:\nif def.Choices != nil {\n    processChoices(def.Choices, def.Properties)\n}\n```","severity":"Critical","rationale":"Deep nesting within the `Definition` struct and related types can lead to code that is difficult to maintain and understand. For example, fields like `Properties` (which is a map of `Definition`), `Items` (pointer to `Definition`), and nested structs such as `HashMap` and `Focus` introduce multiple layers of indirection. This increases cognitive load for developers, making it harder to trace logic, debug, or extend functionality. Excessive nesting also complicates unit testing and can obscure bugs, as changes in one deeply nested field may have unintended side effects elsewhere. Flattening the structure or refactoring responsibilities into smaller, focused types would improve readability and maintainability.","lineStart":1,"lineEnd":82,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode suffers from excessive lines of code due to the Definition struct containing a large number of fields, many of which are rarely used and could be grouped or modularized for clarity and maintainability.\n\n```go\ntype Definition struct {\n\t// ...over 20 fields, many optional and loosely related...\n}\n```","codeResolution":"The codeResolution solution streamlines the handling of schema operations by delegating logic to a pre-defined abstraction, significantly reducing lines of code and improving maintainability.\n\n```go\n// Instead of manually processing schema operations, delegate to the abstraction:\noperation := getOperation(def.Type)\nresult := operation.Execute(def)\n```","severity":"Critical","rationale":"### Rationale\n\nThe code snippet demonstrates excessive lines of code within the `Definition` struct, primarily due to the large number of fields and verbose comments. This high LoC count negatively impacts maintainability, as future changes require navigating and understanding a sprawling structure (see lines 6–61). It also increases the risk of errors, such as mismatched field tags or overlooked dependencies. Refactoring by grouping related fields into smaller structs or leveraging composition would reduce LoC, improve readability, and make unit testing more manageable. Streamlining comments and removing redundant fields further enhances maintainability and correctness.","lineStart":1,"lineEnd":94,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The Definition struct disregards cyclomaticComplexity principles by including numerous optional fields and nested types, resulting in a highly complex and difficult-to-maintain design.\n\n```go\ntype Definition struct {\n\tProperties map[string]Definition `json:\"properties\"`\n\tItems *Definition `json:\"items,omitempty\"`\n\tTextToSpeech *TextToSpeech `json:\"textToSpeech,omitempty\"`\n\tSpeechToText *SpeechToText `json:\"speechToText,omitempty\"`\n\t// ...many more fields...\n}\n```","codeResolution":"The solution for cyclomaticComplexity involves refactoring deeply nested conditional logic into clear, single-responsibility function calls, reducing branching and improving maintainability.\n\n```go\n// Instead of nested if/else blocks for processing choices:\nif def.Choices != nil {\n    processChoices(def.Choices, def.Properties)\n}\n```","severity":"Critical","rationale":"The cyclomatic complexity in the `Definition` struct is high due to the large number of fields and nested types (lines 5–61). This increases the number of possible code paths when constructing, validating, or processing instances, making the code harder to maintain and test. Complex nested structures like `Properties map[string]Definition` and multiple pointer fields (e.g., `Items`, `SystemPrompt`, `HashMap`) further complicate logic in downstream usage. High complexity can lead to bugs, reduce readability, and make future changes risky. Refactoring into smaller, focused structs or using composition could improve maintainability and reduce cyclomatic complexity.","lineStart":1,"lineEnd":87,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A+","readability":"A-","testability":"A-"},"issues":{"cyclomaticComplexity":1,"dependenciesModules":0,"functionMethodCounts":0,"linesOfCode":103,"nestingDepth":3}},"hash":"728a6a2f070e59c1d0347a4b641dc2588b2ed1cce8c4f428cc3f9fac8c2f1255","id":"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"}
{"assessingTool":"Complexity","filePath":"grpc/object-generation_grpc.pb.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:11:03.203Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The violatingCode exhibits elevated cyclomatic complexity due to deeply nested error handling and type assertions within handler functions.\n\n```go\nfunc _JSONSchemaService_GenerateObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(RequestBody)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(JSONSchemaServiceServer).GenerateObject(ctx, in)\n\t}\n\t// ...\n}\n```","codeResolution":"The solution for cyclomatic complexity in this context replaces nested logic with clear delegation to helper abstractions, making the code easier to test and maintain.\n\n```go\n// Instead of handling all logic inline, delegate to helper functions.\nfunc (s *serverImpl) GenerateObject(ctx context.Context, req *RequestBody) (*Response, error) {\n\tif !validateRequest(req) {\n\t\treturn nil, status.Error(codes.InvalidArgument, \"invalid request\")\n\t}\n\treturn generateFromSchema(req.Schema)\n}\n```","severity":"Critical","rationale":"Cyclomatic complexity is important because it directly impacts code maintainability and testability. In the provided code, most functions (e.g., `GenerateObject`, `StreamGeneratedObjects`, and their handlers) have low complexity, with minimal branching and straightforward control flow. This makes the code easier to understand, modify, and test. If complexity were higher—such as deeply nested conditionals or multiple decision points—future changes would risk introducing bugs and make unit testing more difficult. Keeping cyclomatic complexity low, as seen here, ensures the codebase remains robust and easier to extend.","lineStart":97,"lineEnd":143,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode exhibits excessive nestingDepth, particularly in handler functions where control flow is deeply layered and difficult to follow.\n\n```go\nif interceptor == nil {\n\treturn srv.(JSONSchemaServiceServer).GenerateObject(ctx, in)\n}\ninfo := &grpc.UnaryServerInfo{\n\tServer:     srv,\n\tFullMethod: JSONSchemaService_GenerateObject_FullMethodName,\n}\nhandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\treturn srv.(JSONSchemaServiceServer).GenerateObject(ctx, req.(*RequestBody))\n}\nreturn interceptor(ctx, in, info, handler)\n```","codeResolution":"The codeResolution for nestingDepth focuses on flattening the control flow in the handler by delegating logic to helper functions, reducing the maximum nesting level and improving readability.\n\n```go\nfunc (s *serverImpl) GenerateObject(ctx context.Context, req *RequestBody) (*Response, error) {\n\tif !validateRequest(req) {\n\t\treturn nil, status.Error(codes.InvalidArgument, \"invalid request\")\n\t}\n\treturn processGeneration(ctx, req)\n}\n```","severity":"Critical","rationale":"Deep nesting in several handler functions (e.g., `_JSONSchemaService_GenerateObject_Handler` and `_JSONSchemaService_StreamGeneratedObjects_Handler`) increases cognitive complexity and makes the code harder to maintain and test. For example, lines with multiple nested `if` statements and inline anonymous functions (see lines 97–110) bury core logic within several layers, which can obscure error handling and business logic. Excessive nesting also complicates future modifications and debugging, as developers must trace through multiple levels to understand the flow. Refactoring with guard clauses or splitting responsibilities into smaller functions would improve readability and maintainability.","lineStart":94,"lineEnd":129,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode contains a high number of function and method definitions, but most are thin wrappers or generated stubs, resulting in minimal separation of responsibilities and limited maintainability.\n\n```go\nfunc (UnimplementedJSONSchemaServiceServer) GenerateObject(context.Context, *RequestBody) (*Response, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method GenerateObject not implemented\")\n}\n```","codeResolution":"The code’s functionMethodCounts can be improved by refactoring monolithic handler logic into smaller, purpose-driven functions. Here’s how the main handler block should be replaced to delegate responsibilities:\n\n```go\nfunc (s *JSONSchemaServiceServerImpl) GenerateObject(ctx context.Context, req *RequestBody) (*Response, error) {\n\tif err := validateRequest(req); err != nil {\n\t\treturn nil, err\n\t}\n\treturn processGeneration(ctx, req)\n}\n```\nThis approach separates validation and processing, enhancing maintainability and clarity.","severity":"Critical","rationale":"This code adheres well to functionMethodCounts principles, with clear separation of responsibilities across multiple functions and methods (e.g., `GenerateObject`, `StreamGeneratedObjects`, handler functions, and registration logic). This modularity improves maintainability, as each function is focused and easier to test or update independently. If the code had fewer, monolithic functions, it would be harder to extend or debug, and changes could introduce subtle bugs. By distributing logic across well-named, single-purpose functions, the code remains robust and scalable, supporting future enhancements with minimal risk.","lineStart":41,"lineEnd":110,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode exhibits excessive lines of code due to repeated boilerplate and verbose handler implementations, making it difficult to maintain and refactor.\n\n```go\nfunc _JSONSchemaService_GenerateObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(RequestBody)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(JSONSchemaServiceServer).GenerateObject(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: JSONSchemaService_GenerateObject_FullMethodName,\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(JSONSchemaServiceServer).GenerateObject(ctx, req.(*RequestBody))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n```","codeResolution":"The codeResolution for linesOfCode focuses on reducing repetition and improving clarity by delegating object generation logic to a dedicated abstraction. Replace the original block with the following concise usage:\n\n```go\n// Go\nfunc (s *serverImpl) GenerateObject(ctx context.Context, req *RequestBody) (*Response, error) {\n\treturn getObjectGenerator().Generate(ctx, req)\n}\n```","severity":"Critical","rationale":"## Rationale\n\nThe code snippet contains a high number of lines of code due to repeated boilerplate, verbose type definitions, and duplicated handler logic (e.g., lines 41–56, 59–74, 77–94, 97–112). Excessive LoC increases cognitive load, making the code harder to maintain and review. It also raises the risk of introducing subtle bugs when updating similar blocks. Reducing LoC by consolidating repeated patterns and extracting shared logic into helper functions would improve maintainability and readability without sacrificing correctness or performance.","lineStart":22,"lineEnd":109,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The violatingCode tightly couples the implementation to several external gRPC dependencies, making future maintenance and portability challenging.\n\n```go\nimport (\n\tcontext \"context\"\n\tgrpc \"google.golang.org/grpc\"\n\tcodes \"google.golang.org/grpc/codes\"\n\tstatus \"google.golang.org/grpc/status\"\n)\n```","codeResolution":"The code demonstrates a solid approach to managing dependencies by only importing essential gRPC and context packages, keeping the module footprint minimal and focused.\n\n```go\n// Replacement for direct grpc imports and usage:\nimport (\n\tcontext \"context\"\n\tgrpc \"google.golang.org/grpc\"\n)\n\n// Use the Operation abstraction for service calls:\nresult, err := getOperation(\"GenerateObject\").Execute(ctx, requestBody)\n```","severity":"Critical","rationale":"The code imports several external dependencies (lines 7–11), specifically from the gRPC ecosystem. While these are necessary for generated gRPC code, excessive reliance on tightly coupled, version-specific packages (e.g., `grpc.SupportPackageIsVersion9` on line 16) can hinder maintainability and future upgrades. If any of these packages change APIs or are deprecated, the code may break or require significant refactoring. Additionally, using aliased imports (e.g., `context \"context\"`) can reduce clarity for new contributors. Streamlining imports and minimizing unnecessary dependencies would improve maintainability and reduce the risk of compatibility issues.","lineStart":6,"lineEnd":8,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A-","testability":"A"},"issues":{"cyclomaticComplexity":13,"dependenciesModules":4,"functionMethodCounts":16,"linesOfCode":172,"nestingDepth":2}},"hash":"aa52fe695b40be9ac14ee915b9d8db0b86dcf3ccd7b47f1cd7df87628a24fcfc","id":"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"}
{"assessingTool":"Complexity","filePath":"grpc/object-generation.pb.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:11:00.497Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependenciesModules","violatingCode":"The violatingCode demonstrates poor dependenciesModules discipline by importing more packages than necessary, including unused and redundant dependencies.\n\n```go\nimport (\n\tprotoreflect \"google.golang.org/protobuf/reflect/protoreflect\"\n\tprotoimpl \"google.golang.org/protobuf/runtime/protoimpl\"\n\t_ \"google.golang.org/protobuf/types/known/anypb\"\n\tstructpb \"google.golang.org/protobuf/types/known/structpb\"\n\treflect \"reflect\"\n\tsync \"sync\"\n)\n```","codeResolution":"The codeResolution for dependenciesModules focuses on simplifying and clarifying the import structure by removing unused or redundant dependencies, ensuring only necessary modules are included. This improves maintainability and reduces build complexity.\n\n```go\nimport (\n\tprotoreflect \"google.golang.org/protobuf/reflect/protoreflect\"\n\tprotoimpl \"google.golang.org/protobuf/runtime/protoimpl\"\n\tstructpb \"google.golang.org/protobuf/types/known/structpb\"\n)\n```","severity":"Critical","rationale":"The code imports a large number of external dependencies (lines 8–14), including several protobuf-related packages and standard library modules. While these are required for generated code, excessive or unnecessary imports can complicate dependency management, increase build times, and make the codebase harder to maintain. For example, importing unused packages (such as the blank import on line 12) adds clutter and may confuse future maintainers. Streamlining imports to only those strictly necessary improves clarity, reduces the risk of version conflicts, and enhances maintainability.","lineStart":9,"lineEnd":18,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode disregards linesOfCode principles by generating excessive boilerplate and repetitive getter methods for every field, resulting in unnecessary verbosity.\n\n```go\nfunc (x *Definition) GetType() string {\n\tif x != nil {\n\t\treturn x.Type\n\t}\n\treturn \"\"\n}\n```","codeResolution":"The codeResolution for linesOfCode focuses on reducing boilerplate and improving maintainability by replacing repetitive getter logic with a concise helper. For example, all the `GetX` methods in the `Definition` struct can be replaced with a generic accessor:\n\n```go\n// Go\nfunc (x *Definition) Get(field string) any {\n\tswitch field {\n\tcase \"Type\":\n\t\treturn x.Type\n\tcase \"Instruction\":\n\t\treturn x.Instruction\n\tcase \"Properties\":\n\t\treturn x.Properties\n\t// ...add cases for other fields as needed\n\tdefault:\n\t\treturn nil\n\t}\n}\n```\n\nThis approach eliminates dozens of nearly identical getter methods, streamlining the codebase and reducing lines of code.","severity":"Critical","rationale":"The code violates linesOfCode best practices by generating an extremely high number of non-comment, non-blank lines, much of which is boilerplate from protoc-gen-go. For example, each message type (e.g., `Definition`, `TextToSpeech`, `SpeechToText`) includes repetitive getter methods and reset logic (see lines defining `GetType`, `GetInstruction`, etc.), which inflates the codebase. Excessive LoC like this makes the code harder to maintain, increases cognitive load for future changes, and can slow down code reviews and refactoring. Reducing redundancy—such as consolidating similar getter logic or leveraging code generation options to minimize output—would improve maintainability and clarity.","lineStart":44,"lineEnd":678,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode exhibits excessive nestingDepth, especially in the repeated use of nested if statements within getter methods, which reduces readability and maintainability.\n\n```go\nfunc (x *Definition) GetType() string {\n\tif x != nil {\n\t\treturn x.Type\n\t}\n\treturn \"\"\n}\n```","codeResolution":"The codeResolution for nestingDepth focuses on flattening deep conditional logic by delegating responsibility to helper functions, resulting in clearer and more maintainable code.\n\n```go\n// Instead of deeply nested checks, use guard clauses and helper functions:\nif !isValidDefinition(def) {\n\treturn nil\n}\nif !isSupportedType(def.Type) {\n\treturn nil\n}\nprocessDefinition(def)\n```","severity":"Critical","rationale":"The code’s nesting depth is problematic, especially in the `Definition` struct and its related methods. For example, the recursive nature of `Properties map[string]*Definition` and `Items *Definition` (lines 22–24) means that any logic operating on these fields will likely require deeply nested loops or conditionals to traverse or manipulate the data. This increases cognitive load, makes the code harder to maintain, and complicates debugging and testing. Excessive nesting can also degrade performance due to stack growth in recursive calls. Refactoring to flatten data structures or using iterative traversal patterns would improve maintainability and reduce the risk of errors.","lineStart":81,"lineEnd":425,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The violatingCode exhibits excessive cyclomatic complexity due to deeply nested conditional logic and repetitive guard clauses across multiple getter methods.\n\n```go\nfunc (x *Definition) GetType() string {\n\tif x != nil {\n\t\treturn x.Type\n\t}\n\treturn \"\"\n}\n```","codeResolution":"Cyclomatic complexity is reduced by refactoring nested logic into dedicated helper functions, making the code easier to test and maintain. Here is the replacement code for the identified block:\n\n```go\nif d.TextToSpeech != nil {\n\tprocessTextToSpeech(d.TextToSpeech)\n}\nif d.SpeechToText != nil {\n\tprocessSpeechToText(d.SpeechToText)\n}\nif d.Image != nil {\n\tprocessImage(d.Image)\n}\n```","severity":"Critical","rationale":"Cyclomatic complexity is a concern in this code because the `Definition` struct (lines 18–49) contains a large number of fields, many of which are nested types or maps to other complex types. This design increases the number of possible code paths when interacting with or validating a `Definition` instance, making the logic harder to follow and test. High complexity here can lead to maintainability issues, as future changes may introduce subtle bugs or require extensive refactoring. Breaking down the structure into smaller, focused components or using composition would reduce complexity and improve code clarity.","lineStart":41,"lineEnd":383,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode disregards functionMethodCounts principles by defining an excessive number of getter methods for each field, resulting in unnecessary boilerplate and reduced maintainability.\n\n```go\nfunc (x *Definition) GetType() string {\n\tif x != nil {\n\t\treturn x.Type\n\t}\n\treturn \"\"\n}\n```","codeResolution":"The codeResolution for functionMethodCounts should refactor monolithic logic into smaller, purpose-driven functions to improve maintainability and clarity. Here is how the main block should be replaced to delegate responsibilities:\n\n```go\n// Instead of handling everything in one method:\nfunc (x *Definition) Process() {\n\tif !validateDefinition(x) {\n\t\treturn\n\t}\n\tprocessProperties(x.Properties)\n\tprocessItems(x.Items)\n}\n```\n\nThis approach separates validation and processing, allowing each function to focus on a single responsibility.","severity":"Critical","rationale":"The code violates functionMethodCounts principles by generating a large number of trivial getter methods (e.g., `GetType`, `GetInstruction`, `GetProperties`, etc.) for each field in every struct, rather than encapsulating logic or responsibilities. This leads to bloated code, making maintenance and navigation difficult. The lack of meaningful, responsibility-driven functions means future changes require edits across many repetitive methods, increasing the risk of errors and reducing testability. Refactoring to group related logic into cohesive methods would improve maintainability and correctness.","lineStart":37,"lineEnd":417,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A-","qualityDesign":"A+","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":7,"functionMethodCounts":21,"linesOfCode":1311,"nestingDepth":2}},"hash":"4136c2642dea364c20621e067baef2f5fce805c23037f2874091e5107d6dc5f0","id":"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"}
{"assessingTool":"SOLID","filePath":"jsonSchema/model.go","grade":"C","username":"HLamb","timestamp":"2025-10-12T17:10:53.586Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"openClosed","violatingCode":"The Definition struct directly embeds new features and fields, requiring modification for every extension and thus violating openClosed.\n\n```go\ntype Definition struct {\n\t// ... many fields added for new features ...\n\tTextToSpeech *TextToSpeech `json:\"textToSpeech,omitempty\"`\n\tSpeechToText *SpeechToText `json:\"speechToText,omitempty\"`\n\tImage        *Image        `json:\"image,omitempty\"`\n\t// ... more fields ...\n}\n```","codeResolution":"The revised solution for openClosed refactors the code to delegate resolution logic to an abstraction, allowing new resolution strategies to be added without modifying existing code. Replace the original block with the following:\n\n```go\ngo\n// Instead of hardcoding resolution logic, use the Operation abstraction:\nop := getOperation(def.Type)\nresult, err := op.Resolve(def)\nif err != nil {\n    // handle error\n}\nreturn result\n```","severity":"High","rationale":"The current implementation tightly couples the `Definition` struct to many specific features (e.g., `TextToSpeech`, `SpeechToText`, `Image`, `HashMap`, etc.), making it difficult to extend without modifying the core type. This violates the Open/Closed Principle, as adding new schema capabilities requires direct changes to the struct, increasing the risk of regressions and making maintenance harder. For example, every new feature (like a new media type or processing option) demands a new field in `Definition`, leading to bloated code and reduced clarity. Adhering to openClosed would allow new behaviors via composition or interfaces, improving scalability and reducing the likelihood of breaking existing functionality.","lineStart":1,"lineEnd":81,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The Definition struct directly depends on multiple concrete types rather than abstractions, violating dependency inversion principles.\n\n```go\ntype Definition struct {\n\tType DataType `json:\"type,omitempty\"`\n\tProperties map[string]Definition `json:\"properties\"`\n\tItems *Definition `json:\"items,omitempty\"`\n\tHashMap *HashMap\n}\n```","codeResolution":"The solution applies dependency inversion by replacing direct calls to concrete types with abstractions, allowing flexible operation selection via an injected factory.\n\n```go\n// Go\nfunc (d *Definition) ResolveCode(opType string, a, b float64) float64 {\n    operation := getOperation(opType) // returns Operation interface\n    return operation.Execute(a, b)\n}\n```","severity":"Critical","rationale":"This code violates dependency inversion by tightly coupling the `Definition` struct to many concrete types (e.g., `HashMap`, `TextToSpeech`, `SpeechToText`, `Image`, etc.) as direct fields. This approach makes the codebase rigid and difficult to extend or test, since any change to these types requires modifying the `Definition` struct itself. For example, lines like `HashMap *HashMap` and `TextToSpeech *TextToSpeech` embed concrete implementations rather than abstractions or interfaces. This reduces maintainability and flexibility, as new features or alternative implementations cannot be injected easily. Refactoring to depend on interfaces would improve testability and allow for easier future enhancements.","lineStart":1,"lineEnd":87,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The Definition struct violates interface segregation by combining many unrelated responsibilities into a single type, forcing clients to depend on fields they may not need.\n\n```go\ntype Definition struct {\n\tProperties map[string]Definition `json:\"properties\"`\n\tItems *Definition `json:\"items,omitempty\"`\n\tTextToSpeech *TextToSpeech `json:\"textToSpeech,omitempty\"`\n\tImage *Image `json:\"image,omitempty\"`\n}\n```","codeResolution":"The solution restructures the code to delegate operation logic to an abstraction, ensuring each operation is handled by its own interface implementation for better interface segregation.\n\n```go\n// Go\nop := getOperation(def.Type)\nresult, err := op.Execute(def)\nif err != nil {\n    return nil, err\n}\nreturn result, nil\n```","severity":"High","rationale":"The Definition struct violates the Interface Segregation Principle by combining many unrelated concerns—such as schema typing, AI model selection, prompt management, external requests, and multimedia processing—into a single type. This monolithic design makes the code harder to maintain and extend, as changes to one aspect (e.g., image handling) could inadvertently affect others (e.g., text-to-speech). For example, lines like `TextToSpeech *TextToSpeech`, `Image *Image`, and `Req *RequestFormat` introduce responsibilities that should be separated into focused interfaces or structs. Improving interface segregation here would allow clients to depend only on the features they need, reducing coupling and improving testability and correctness.","lineStart":7,"lineEnd":81,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"C-","liskovSubstitutionScore":"A+","openClosedScore":"C-","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package jsonSchema\n\n// Definition is a struct for describing a JSON Schema.\n// It is fairly limited, and you may have better luck using a third-party library.\ntype Definition struct {\n\t// Type specifies the data type of the schema.\n\tType DataType `json:\"type,omitempty\"`\n\t// Instruction is the instruction for what to generate.\n\tInstruction string `json:\"instruction,omitempty\"`\n\t// Properties describes the properties of an object, if the schema type is Object.\n\tProperties map[string]Definition `json:\"properties\"`\n\n\t// Items specifies which data type an array contains, if the schema type is Array.\n\tItems *Definition `json:\"items,omitempty\"`\n\t// Model this needs to match the exact name of the model that you will be sending to AI as a Service provider. Such as OpenAI or Google Gemini\n\tModel string `json:\"model,omitempty\"`\n\t// ProcessingOrder this is the order of strings ie the fields of the parent property keys that need to be processed first before this field is processed\n\tProcessingOrder []string `json:\"processingOrder,omitempty\"`\n\n\t// SystemPrompt allows the developer to spefificy their own system prompt so the processing. It operates current at the properties level.\n\tSystemPrompt *string `json:\"systemPrompt,omitempty\"`\n\t// Req allows a developer to send out a request at a given point to ensure that additional information can be extracted from external databases\n\n\t// ImprovementProcess --> so that the user can specify when a super high quality completion is needed and it can be improved upon\n\tImprovementProcess bool `json:\"improvementProcess,omitempty\"`\n\n\t//Map is used here as so that a map of values can be created and then returned -- useful in the instruction creation process -- not sure how useful it is otherwise\n\tHashMap *HashMap\n\n\t//the other data types that need to be filled for the object to be generated within GoR\n\tTextToSpeech *TextToSpeech `json:\"textToSpeech,omitempty\"`\n\tSpeechToText *SpeechToText `json:\"speechToText,omitempty\"`\n\tImage        *Image        `json:\"image,omitempty\"`\n\n\t//Utility fields:\n\tReq *RequestFormat `json:\"req,omitempty\"`\n\t// NarrowFocus\n\tNarrowFocus *Focus `json:\"narrowFocus,omitempty\"`\n\n\t// SelectFields has the aim of being able to select multiple pieice of information and when they are all present then continue with processing. Such that the selection of information can work like so:\n\t//The system works as an absolute path that has to be selected. So starting from the top most object then down to the selected field(s)\n\t//\"car.color\" --> this would fetch the information from the car field and then the color field.\n\t//\"cars.color\" --> Would return the entire list of colours that have been generated so far\n\tSelectFields []string `json:\"selectFields,omitempty\"`\n\n\t// Choices For determining which of the property fields should be generated\n\tChoices *Choices `json:\"choices,omitempty\"`\n\n\t// Voters this is used for determining whether you want to have voters determine the qulaity of completions. Increases costs but improves quality. If avialible to your tier then turned on automatically.\n\tVoters bool `json:\"voters,omitempty\"`\n\n\t//Image URL --> if the LLM supports reading an image due to it being multi-model then the image URL will be passed in here\n\tSendImage *SendImage `json:\"sendImage,omitempty\"`\n\n\t//Stream - used for instructing when the information should be streamed. Please visit the documentation for more information for which types are supported.\n\tStream bool `json:\"stream,omitempty\"`\n\n\t//Temp - used for passing in a temperature value for the prompt request\n\tTemp float64 `json:\"temp,omitempty\"`\n\n\t//OverridePrompt - used for overriding the prompt that is passed in\n\tOverridePrompt *string `json:\"overridePrompt,omitempty\"`\n}\n\ntype Choices struct {\n\tNumber  int      `json:\"number,omitempty\"`  //this denotes the number of choices that should be selected\n\tOptions []string `json:\"options,omitempty\"` //this is the list of fields that will be chosen from\n\t/*\n\t\tHow this works is that it needs to be in a of definitions which match with the properties field. From the properties fields the choice of those keys will be selected\n\t\tthe information of what the overall object, the properties being selected along with the instruction and their type and the types that they contain if the object goes down further.\n\t\tthe prompt will also be pass in so that the agent can make the best decesion possible\n\n\t\tOnce the choices have been selected the choices that haven't been selected will be deleted from the remaining keys avialible in both the ordered and unordered keys.\n\t*/\n}\n\n// HashMap this can output a map of values and so whilst it may take up a single field it could output many fields\ntype HashMap struct {\n\tKeyInstruction  string      `json:\"keyInstruction,omitempty\"`\n\tFieldDefinition *Definition `json:\"fieldDefinition,omitempty\"`\n}\n\n// Focus the idea for this is so that when a narrow focus request needs to be sent out to an LLM without needing all the additional information. From prior generation.\ntype Focus struct {\n\tPrompt string `json:\"prompt\"`\n\t//the fields value denotes the properties that will be extracted from the properties fields. These will only operate at a single level of generation.\n\t//the order in which the fields that are listed will be the order for which the currently generated information will be presented below the prompt value.\n\tFields []string `json:\"fields\"`\n\n\t//KeepOriginal -- for keeping the original prompt in cases for lists where it would otherwise be removed from the context\n\tKeepOriginal bool `json:\"keepOriginal,omitempty\"`\n}\n\n// RequestFormat defines the structure of the request\ntype RequestFormat struct {\n\tURL           string                 `json:\"url\"`\n\tMethod        HTTPMethod             `json:\"method\"`\n\tHeaders       map[string]string      `json:\"headers,omitempty\"`\n\tBody          map[string]interface{} `json:\"body,omitempty\"`\n\tAuthorization string                 `json:\"authorization,omitempty\"`\n\tRequireFields []string               `json:\"requirFields,omitempty\"`\n}\n","reason":"Modified","start":1,"end":103,"grade":"C"}]},"hash":"62595fb0bdc420c81792b39fd4c6f2c7930034548a065f2cb654185cff7d10fc","id":"eJx1WU2T27gR/StduiSZ8mguqRx8SJWzW15P1t5xeWaTw2qrFiKbInZANA00R1Zc/u+pbgAkKMk62BIB9Bde9+vmfN2YGDFG6w9PRG7zevP48P7+x82rTUMt/kCe0fPm9WY0zbM5IPwZyT82PQ5m53f+7g5+xM56y5Y82AgGIoepYegoQIuxCXZv/QEM/Pvx4RdIJ7d68J7lQGdscCdwdrCM7SswvoUTTTCYE/TmBWGPzBjATc0zTDHJ4t6G9nY0geXkPphw2u48n0aszcmWfN35Hd/dwZMsxxEb21mMwD1Ca9iAHqNOH8Ri3451+4+GjX75Q/x+vdvI5lcktg4jn3abP7Lwe5+05TCILFs9kmgce8PABAf0GAyjaqnPRQ7iXlFVnb+m8WOgEQOLKznO2alxWaAOjAfa/4kNvwJb+5jcthEedFWNqUQOZvwt2fN7FdFi2qIi2ZNjwDjEKsLH3jZ9FWPjwYRgTtCQZ2N9/J5Jb2RXCo+KvLligsQjXovLB2rRCUIieMQ2SsgHw02vmvCLaRi8GeYrH/J+w4q7o3UO9ggRfSu3wQRv7sEIsh8xvNhGA/xiWwxbeJyaXtYeRvRv7oEC/ER0cAg/4WC9FYuSOWdXqzq/c6lNSsaH0GJIbmQ8kT6hLguLYFGfdxZdG4s7ownouYDgBM94isk7iYa4s1cPRA220NkQGfbYUcCkTcWJznlThsbKsN9+P3NpXG84dy6593iKjMPHQMPIYJyjY85DfEEnBot9ccTOdrY5yZINQEcPUQ+KSXIyUgF6VrmVYiLnDWOEZgoaA0m3dT440aPAWllyc+ZLrBav3dIn/FysN2e2o2+BJgYDAT9PGNUKAwf7gh5Gsl5LAPo4abxlsW0V2caB9R2FwSjOG+PlpvALB9Ow3FSgQX5ikK2SVXsTMS7ZNwgucUBfLgtub/+ZYpUjMUUMKjjl6AmOPXop2ZOY39tDD58n4yxLig6jw1LOBDrYam22XEyzSWEL00hqxBUL9kRuSdmL9aso+WBG0TkJPHsMKAlWvDBSmATqL8ZNctXJlCag4Wwgi08BeQoeW7i9FUHdJMG9qMp6TL6Mc8DAE4NeTk/H+agyFXGP4WgjipnvTOzF0Jv8pRiviSobl7p3mX6ddU5ulEJKbK3Aea2wQwtHy7318BN9UjrCL/xEjyNi08PN6tfMTdXDC9imx08kJ+Fm9WuGffXw4vz9IOyfPzerX8v9msMFOWpUfmWrqEql6rU8lBy6+ZRy5K2ifpYT8PO1rPvFhEDHt9RMAnqufsJN+q8I8MvSd+oQOmz4bSqcvUlFyNhBkLVH7TH2DlNCy04YJsd2dAijRaEA6lbJKrjTXOIeT2AEs87BGDBKHVJECudZP6Fe66p0KYnMOZoUitAzHQL1I4VncPYZIdLr5MuTnEnVUVajUpUHs4/kJhY+4Cxd/aTEbaID2y08EkQ2gcVlLTBiAtMIA0WegSn2t1KGmSoblT3QtX+Nf0um7DaNCduGHIXdRouPEsqRJtdCh4WCa6dmnY0JmXnmHNbHIiwtbCslcaXlv6ogpXwiec82IDgrPnQqZAqxREF7SvRVpkWCzgTNkhoYFxwXq9XrwPqhJ9tghLfa/TIGaQP8IbdChaILN2fmjr06UCe/iCuybsqXYkaTfl+34D/EqL6mxkGraHdhDWqJ0n7HJErSuLykw2Vv6i8+T85I8mokCyvELdx7qZ9RqjBFjrCfuHBCLDyyhfsOzIs1zuaEOtEUgK32NnLJqUxLDk1MgorGOJeav+zKikOShVddTzXp10/vFRS5s3z//oPQ20iBIwQ02tMZD1qroJ3UJss56zXNb0tHmDFoZ7mlNxyN9k7WKz8l3Pg26b9Zvi6wyU+umv3IAc0At8tVzRSVrspfZM0CmKiHJZM/OrkLeLHRpkLSUjMJ1Zp5ABmkx1tln04lgszEU1K4crAw5Vs2bnUFSedVX55wGGtPJFDihZUuQ3YLuoVclb5nAsxtXe6YEtsNI3SODP/j7xW/DeNVtQ8vGIJtMbdzlQGUVrSRXxRpIZAOt9yjiDkTct4T0mr5zIxvYolOLyVX69nzl2nYYwCQ5m9FmF4XVrIApIewkoOeOE90aZ8mYBavHlQwyAVZ/Rg1Py+rF6WFtbqsLY8YpWLmwqRaCuibniKmiq1Rv5F/d/yOjqXMC/vYfMryMn1JrygAoA7aeZAr42EazZQUz5r1VPXhbaGI86VkcopIKq0UMc07yxC3xGXH52lEXZ7JpQd7wSCcXWblM4WpPMy8ZxxJbhaj654y05cNZeZtE6cujaD2CHkELmUqM+2BZJoXpu2mICV6u1iesauuGRepFCKJbd3km4P0HNItDOY5VfC9zCEtNhi12aUYpRqn7Nnxg2+wCmWsKHJ2uF6eadT/hc+2lbi36HCeWeRswMEk7tH7WRjBethTDqMOuLmLn3z5JQc0DDd3OdHu7qC034o88ZUmHqfL+UBERRKouaiglNdKLHGZRhl8rJdpPY+8DI0mVJY1GF8oOid30Von9894qt/hlEl/lefPqz0Xva02FNUrjmuvO7r1nmv15+4OUhuskGzR5Pqa0rtAJI98qUWGTg+UUbXOWO1cZZJlEr4UHhW8yxPZpjTqXELc1Qk2Z+4YLIXS2MjjHMtkah3JXHgv3ysMI89TQPXCI3FIXSerhF2VrrMh+mox2cJTjxHTGfLuVN4npAE+I0VfIAi+Vg7Ng5++GrG+kOpiaxpec09aJcpyquJiybX0CsOdqi61Ll1zJ5JGDBQWcFqJ50Kh4dnO+LpCCBnbC4/+jDg+BHuwcpW3t2rTM+JY6JPKWlZhZSqRBlA2imdS1GVit5y7/nlmFmMDDvq+YGn65e3yF05pVKletRvP1cp3YL8eI5VjMiISvqTjyL333GMoCNcHazBKu7d86qSuPsXEKbgM0A/IPbVl/d3T08f1k9WxQZfyyXdoWul206d6/XqtoPRp80Ul+Re1p0VPJcR6xtCZBr9+m4XsqT1dSHgzcU/B/s/Ub6S/57epN1+IkuDagOfouy4q6Oaro9W3nd+82nTW4UfD/eb1ZvkTxJ226tsDbb79H6lpAvY="}
{"assessingTool":"Complexity","filePath":"converison/requestFormat.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:10:48.691Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The ConvertProtoToRequestFormat and ConvertModelToProtoRequestFormat functions ignore cyclomatic complexity best practices by embedding multiple conditional branches and conversions within single functions.\n\n```go\nif protoReq == nil {\n\treturn nil\n}\nbody, _ := ConvertStructToMap(protoReq.Body)\nreturn &jsonSchema.RequestFormat{ ... }\n```","codeResolution":"The solution for cyclomatic complexity in this context involves refactoring conditional logic into dedicated helper functions, reducing branching and improving readability.\n\n```go\n// Replace the body conversion logic with a helper function call.\nbody := convertBody(protoReq.Body)\n```","severity":"Critical","rationale":"High cyclomatic complexity in these conversion functions increases the risk of errors and makes future changes difficult. For example, both `ConvertProtoToRequestFormat` and `ConvertModelToProtoRequestFormat` contain multiple conditional branches and implicit error handling (lines 10, 23), which can obscure logic flow and complicate testing. Excessive branching also makes it harder to reason about correctness and can degrade performance if the code grows. Refactoring into smaller, single-responsibility functions would improve maintainability and testability, reducing the likelihood of bugs and simplifying future enhancements.","lineStart":13,"lineEnd":28,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode exhibits unnecessary nesting by placing the main conversion logic inside an if-statement, reducing readability and maintainability.\n\n```go\nif protoReq == nil {\n\treturn nil\n}\n```","codeResolution":"The solution for nestingDepth in this code focuses on flattening control structures by using guard clauses, which improves readability and maintainability.\n\n```go\n// Replace the main conversion logic with guard clauses to reduce nesting depth.\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\tif protoReq == nil {\n\t\treturn nil\n\t}\n\tbody, _ := ConvertStructToMap(protoReq.Body)\n\treturn &jsonSchema.RequestFormat{\n\t\tURL:           protoReq.Url,\n\t\tMethod:        jsonSchema.HTTPMethod(protoReq.Method),\n\t\tHeaders:       protoReq.Headers,\n\t\tBody:          body,\n\t\tAuthorization: protoReq.Authorization,\n\t\tRequireFields: protoReq.RequireFields,\n\t}\n}\n```","severity":"Critical","rationale":"The code demonstrates minimal nesting, with only a single level of 'if' statements in both conversion functions. This shallow nesting depth is beneficial because it keeps the logic straightforward and easy to follow, reducing cognitive load for future maintainers. Deeply nested code can obscure the main logic, making bugs harder to spot and increasing the risk of errors during modifications. By limiting nesting, the code remains readable, testable, and less prone to mistakes, supporting maintainability and correctness.","lineStart":13,"lineEnd":27,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code tightly couples the conversion logic to specific external packages, making future maintenance and testing more difficult.\n\n```go\nimport (\n\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n)\n```","codeResolution":"The code demonstrates a direct mapping between protobuf and Go model types for request formats, relying on two external packages for type definitions and conversion helpers.\n\n```go\n// codeResolution\n\nreturn &jsonSchema.RequestFormat{\n\tURL:           protoReq.Url,\n\tMethod:        jsonSchema.HTTPMethod(protoReq.Method),\n\tHeaders:       protoReq.Headers,\n\tBody:          body,\n\tAuthorization: protoReq.Authorization,\n\tRequireFields: protoReq.RequireFields,\n}\n```","severity":"Critical","rationale":"The code imports two external packages: `pb` from `github.com/objectweaver/go-sdk/grpc` and `jsonSchema` from `github.com/objectweaver/go-sdk/jsonSchema`. While these dependencies are necessary for type conversions, tightly coupling the conversion logic to specific external modules can hinder maintainability. If either package changes its API, all dependent conversion functions must be updated, increasing the risk of breaking changes. Additionally, excessive reliance on external packages may complicate testing and reduce portability. Abstracting conversion logic or using interfaces could improve flexibility and future-proof the code against upstream changes.","lineStart":3,"lineEnd":5,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode unnecessarily duplicates logic across two functions, inflating the lines of code and reducing maintainability.\n\n```go\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\t// ...\n}\n\nfunc ConvertModelToProtoRequestFormat(modelReq *jsonSchema.RequestFormat) *pb.RequestFormat {\n\t// ...\n}\n```","codeResolution":"The solution streamlines lines of code by abstracting conversion logic into reusable functions, reducing duplication and improving maintainability.\n\n```go\n// Replace the conversion blocks with calls to the new abstraction.\nreturn ConvertRequestFormat(protoReq)\n```\n\n```go\nreturn ConvertRequestFormat(modelReq)\n```","severity":"Critical","rationale":"### Rationale\n\nThe code currently has duplicated logic across `ConvertProtoToRequestFormat` and `ConvertModelToProtoRequestFormat`, increasing lines of code unnecessarily. Excessive LoC can hinder maintainability, making future updates error-prone and harder to test. For example, both functions manually map fields between types; extracting shared logic into helper functions would reduce repetition and improve clarity. Streamlining LoC also helps performance by minimizing redundant operations and makes correctness easier to verify, as less code means fewer places for bugs to hide.","lineStart":8,"lineEnd":28,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode fails functionMethodCounts by combining multiple responsibilities into just two functions, making the code less modular and harder to maintain.\n\n```go\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\tif protoReq == nil {\n\t\treturn nil\n\t}\n\n\tbody, _ := ConvertStructToMap(protoReq.Body)\n\n\treturn &jsonSchema.RequestFormat{\n\t\tURL:           protoReq.Url,\n\t\tMethod:        jsonSchema.HTTPMethod(protoReq.Method),\n\t\tHeaders:       protoReq.Headers,\n\t\tBody:          body,\n\t\tAuthorization: protoReq.Authorization,\n\t\tRequireFields: protoReq.RequireFields,\n\t}\n}\n```","codeResolution":"The conversion logic is currently duplicated across two functions, which violates functionMethodCounts best practices. Refactor by introducing a shared abstraction for conversion, reducing redundancy and improving maintainability:\n\n```go\n// Use a unified conversion handler for both directions.\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\treturn convertRequestFormat(protoReq)\n}\n\nfunc ConvertModelToProtoRequestFormat(modelReq *jsonSchema.RequestFormat) *pb.RequestFormat {\n\treturn convertRequestFormat(modelReq)\n}\n```","severity":"Critical","rationale":"The code defines only two functions, each handling both conversion logic and error handling. This low function count means responsibilities are not well separated, making the code harder to maintain and extend. For example, lines handling nil checks and body conversions are embedded directly in the conversion functions (lines 8–11, 22–25), rather than being delegated to dedicated helpers. This approach increases the risk of bugs if conversion logic changes, and makes unit testing more difficult since each function does too much. Increasing the function count by extracting body conversion and validation into separate functions would improve clarity, testability, and future scalability.","lineStart":7,"lineEnd":22,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A","readability":"A","testability":"A-"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":2,"functionMethodCounts":2,"linesOfCode":43,"nestingDepth":2}},"hash":"2263e1ff66e289c0e6ff36b18520255438d1cbb557eec0b97c0382e2f8ba9861","id":"eJydlFFvmzAQx7+K5YcpVDS8I+Vhi9T1oZGilLwhTQYO8Ao+1z6mZVW++2SgJrShm8qb7/539z/7J164sBaslapKEBse8y22uoHfkk485DkWsEVFoIjHXIv8SVTAclS/wEiLKlWpkq1GQ2yVqpR0xlJeSaq7bJ1jG5XSQF7LVt+iqaIKb23xFFVG5yl38n9rf1pUj3kNrXAVgZsXRWzbG6C9QcIED/DcgaU7NK2g0RxZJph2+awr2VxByKgG9h1ZiwU082yqyk7lH01Y9W0P8MxudLaepQJ2Mxmep9iLW1iWzFdvNkzJZoinZIA6o1zEnc9u0ZQyLE4h+8HizauhRzJdTgnuhPY+1t+wOAVDxdjmy5KNcdrx8BCz6fOdjqYJB8UOqMbCiy763SfJfshODoZzMNbegyjA2Pht9zE+qpzrCxP9rkPma0c1GvlHkEQVT/Wz+Kh120kDdxKawl5oZ/FwvNPznJ+de/4E92PNdYiuY+IgWgJsjtDikFXftudo6bWC94h5jnz1pzjaCZ3gAJP3cY2jt+Nf+THNJT++w/HwcJ0fS0aqahr1ITBe9UlgfP1/AOO1S8DwkJeygb2gmsd8+vVF5vJe1hXy81+2Ju2V"}
{"assessingTool":"Complexity","filePath":"client/grpcGenerateObject.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:10:42.321Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code unnecessarily imports five external packages, including two from the same organization, which increases complexity and potential maintenance overhead.\n\n```go\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/objectweaver/go-sdk/converison\"\n\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"time\"\n)\n```","codeResolution":"The solution for dependenciesModules streamlines external package usage by focusing only on essential imports for gRPC communication and data conversion.\n\n```go\npackage client\n\nimport (\n\t\"context\"\n\t\"github.com/objectweaver/go-sdk/grpc\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\n// Only core dependencies for gRPC and context are imported.\n```","severity":"Critical","rationale":"The code imports four external packages, including two from the same organization and two from Google. While these dependencies are necessary for gRPC functionality, the use of the custom \"converison\" package (line 4) raises maintainability concerns, especially if it is not well-documented or widely used. Excessive or poorly managed dependencies can complicate upgrades, introduce compatibility issues, and increase the risk of bugs. Streamlining imports and relying on well-supported libraries improves reliability and makes future maintenance easier. Redundant or unnecessary dependencies should be removed to reduce complexity and potential security risks.","lineStart":3,"lineEnd":8,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The GrpcGenerateObject function exhibits excessive nestingDepth, making error handling and resource management convoluted and difficult to follow.\n\n```go\ndefer func(conn *grpc.ClientConn) {\n\terr = conn.Close()\n\tif err != nil {\n\n\t}\n}(conn)\n```","codeResolution":"The solution for nestingDepth in GrpcGenerateObject focuses on flattening control flow and delegating responsibilities to helper abstractions, improving readability and maintainability.\n\n```go\n// Replacement for the main logic block in GrpcGenerateObject\nconn, err := grpc.NewClient(c.BaseURL, grpc.WithInsecure(), grpc.WithBlock())\nif err != nil {\n\treturn nil, fmt.Errorf(\"failed to connect to server: %v\", err)\n}\ndefer closeConnection(conn)\n\nctx := createAuthorizedContext(c.Password)\nresponse, err := callGenerateObject(ctx, client, prompt, definition)\nif err != nil {\n\treturn nil, fmt.Errorf(\"failed to call GenerateObject: %v\", err)\n}\nreturn buildResponse(response)\n```","severity":"Critical","rationale":"The code demonstrates excessive nesting, particularly in the error handling and resource cleanup sections (lines 13–22). Deeply nested defer functions and error checks make the logic harder to follow and maintain. High nesting depth increases cognitive load, making future modifications and debugging more error-prone. It also complicates unit testing, as tightly coupled logic is harder to isolate. Refactoring with guard clauses and extracting resource management into helper functions would flatten the structure, improving readability and maintainability.","lineStart":19,"lineEnd":38,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The GrpcGenerateObject function contains excessive lines of code due to deeply nested resource management and setup logic, making it difficult to maintain and refactor.\n\n```go\nconn, err := grpc.NewClient(c.BaseURL, grpc.WithInsecure(), grpc.WithBlock())\nif err != nil {\n\treturn nil, fmt.Errorf(\"failed to connect to server: %v\", err)\n}\ndefer func(conn *grpc.ClientConn) {\n\terr = conn.Close()\n\tif err != nil {\n\n\t}\n}(conn)\n```","codeResolution":"The current implementation for linesOfCode in GrpcGenerateObject is verbose due to manual setup and teardown of connections, context, and metadata. This can be streamlined by delegating these responsibilities to helper abstractions, reducing boilerplate and improving clarity.\n\n```go\n// Replacement code using abstractions for connection, context, and metadata\nconn := getGrpcConnection(c.BaseURL)\ndefer closeGrpcConnection(conn)\n\nctx := getAuthorizedContext(c.Password)\nclient := pb.NewJSONSchemaServiceClient(conn)\n\nresponse, err := client.GenerateObject(ctx, buildRequest(prompt, definition))\nif err != nil {\n\treturn nil, fmt.Errorf(\"failed to call GenerateObject: %v\", err)\n}\n\nreturn buildResponse(response)\n```","severity":"Critical","rationale":"The code violates linesOfCode best practices by including excessive setup and teardown logic directly within the main function, resulting in 38 non-comment, non-blank lines. This verbosity makes the function harder to maintain and test, as responsibilities like connection management, context creation, and error handling are tightly coupled. For example, lines 9–36 could be refactored into helper functions (e.g., `setupConnection`, `createContext`, `handleResponse`) to reduce duplication and improve clarity. Excessive LoC increases cognitive load, raises the risk of bugs, and complicates future modifications. Reducing LoC through modularization would enhance maintainability and correctness.","lineStart":17,"lineEnd":49,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The GrpcGenerateObject function exhibits excessive cyclomatic complexity due to deeply nested error handling and resource management logic.\n\n```go\nconn, err := grpc.NewClient(c.BaseURL, grpc.WithInsecure(), grpc.WithBlock())\nif err != nil {\n\treturn nil, fmt.Errorf(\"failed to connect to server: %v\", err)\n}\ndefer func(conn *grpc.ClientConn) {\n\terr = conn.Close()\n\tif err != nil {\n\n\t}\n}(conn)\n```","codeResolution":"The solution for cyclomatic complexity in this context involves refactoring the monolithic request logic into smaller, focused abstractions, reducing branching and improving maintainability.\n\n```go\n// Replace the direct gRPC call with an abstracted operation\noperation := getOperation(\"GenerateObject\")\nresponse, err := operation.Execute(ctx, request)\n```","severity":"Critical","rationale":"The function’s cyclomatic complexity is elevated due to multiple error checks, nested resource management (connection and context), and sequential logic all packed into a single method. This increases the risk of hidden bugs, makes unit testing difficult, and complicates future changes. For example, lines handling connection setup, error handling, and response processing are tightly coupled, reducing readability and maintainability. Refactoring into smaller, focused helper functions would reduce complexity, making the code easier to test and less error-prone.","lineStart":22,"lineEnd":41,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The code violates functionMethodCounts by placing all logic—connection setup, context creation, metadata handling, request construction, and response processing—into a single monolithic function.\n\n```go\nfunc (c *Client) GrpcGenerateObject(prompt string, definition *pb.Definition) (*Response, error) {\n\t// Set up a connection to the gRPC server\n\tconn, err := grpc.NewClient(c.BaseURL, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect to server: %v\", err)\n\t}\n\tdefer func(conn *grpc.ClientConn) {\n\t\terr = conn.Close()\n\t\tif err != nil {\n\n\t\t}\n\t}(conn)\n```","codeResolution":"The GrpcGenerateObject function can be refactored to delegate connection setup, context creation, and response conversion to dedicated helper functions, improving separation of concerns and maintainability.\n\n```go\n// SendRequestToServer sends a request to the gRPC server with authorization headers\nfunc (c *Client) GrpcGenerateObject(prompt string, definition *pb.Definition) (*Response, error) {\n\tconn, err := setupConnection(c.BaseURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tctx := createAuthorizedContext(c.Password)\n\tclient := pb.NewJSONSchemaServiceClient(conn)\n\trequest := &pb.RequestBody{Prompt: prompt, Definition: definition}\n\n\tresponse, err := client.GenerateObject(ctx, request)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to call GenerateObject: %v\", err)\n\t}\n\treturn convertResponse(response)\n}\n```","severity":"Critical","rationale":"The functionMethodCounts issue here is significant because all logic is packed into a single method, `GrpcGenerateObject`. This violates separation of concerns, making the code harder to maintain and test. For example, connection setup, context creation, metadata handling, request construction, and response processing are all handled in one place (lines 10–54). If any part needs to change, the whole function risks breaking. Splitting these responsibilities into dedicated helper functions would improve readability, facilitate unit testing, and reduce the chance of introducing bugs during future modifications.","lineStart":16,"lineEnd":44,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A+","readability":"A-","testability":"A-"},"issues":{"cyclomaticComplexity":3,"dependenciesModules":6,"functionMethodCounts":1,"linesOfCode":59,"nestingDepth":2}},"hash":"4002a0ad8341fedb770cd4e9001e90ae7fb5088ce187c2faa1ded5913057009f","id":"eJylVE2P4zYM/SusgXbtwOO0VwO5jLdYtGh3Bskseqj3oMi0rcYWVYmejw7y3xeS7HzsLLCH5pAoJEW+90jqNRHOoXNKdw9EQ1ImFY1mwGfFL0meSGqwIs2oOSkTI+RBdAhyUKi51rVWoyHLkNa65jqRPvKZ6yT+bcfTsVPcT/tC0rhulUXZq9HckO3WHd245rCWpB/RKkc63jB7+P6lzhp5KkDUDVh0NAjdFSHou971iCwawWIJYzWiP2ee2noNO9TNFv+d0PED7dA+ogWHunEgwEY7MAH3CN32vgIXQ54U9yAm7smq/wQr0tCjaNC6WreTlpBKWFVBwww+WCM/oEYrGO/2/6Dk1FgaDYNjq3SXQ4Ot0iqkWZl98f70N4N0tUVnSDvMAa0lm8GrpxKwM0wGBEjSGmW4/harD/YB4TqUG/C6FB/xKcJLZXErHH7a/pFHz1+K+9+0QzlZTLML4+1A8pBmXjlWbcj2wwa0GiKgmi3yZLW35NCOXPzq4bZpnbRCDdh4bDNSf4zoSvjxsU4CtpD46L8abNGC1zH1F2AVMES8FWmdLRU9hk1IWlQDOUyzaH8LL5hD8mPImUXbeg2VRcEIAjQ+zWMPraXxWkclMQgZ/eUGzN5r+Pvu7uNO9jiKXQxaRP12iXl75vEBP4w0cUjMzzlIoSUOPvscGHR/iFHpYrsV8tBZmnTj2+NzFDuUpJvVLz9nZ/lisvSMYh6XZSMiCE/yeo6ZDhiujI1HsoR7tukozN9xZj/Hn9c6eb4RRt0c8KVOSpDFvXDuiWxzzGZacJ3jbuKOlO6qyCYNxMfmjVge2LKAFJbG+xdLuYGfzL6YN/eWmpd5Iu7DYpXgP3HJ8ug471R5sW75MnNzbTEM576PyD014DXpL15EtpcLGboVXMVXOx6YzYAzWK9hi2YQEuHddeC7i05InsQAF8W1GPF/LZxndF3vWyvnp0awODM6PdZFFY68YztJNvsH+lOYdJGgeC9YzL2z6EJflvdqBukjQj9CgWj75JqKHJdwyjNbLvsxs7Pock+x1sdaJ3nSqgHvBfdJmUTdw0N/TbHoKDl+AZnHggs="}
{"assessingTool":"Complexity","filePath":"converison/grpcConverison.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:10:38.288Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode disregards functionMethodCounts principles by embedding excessive logic within single functions, leading to poor separation of concerns.\n\n```go\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n\t// ... dozens of fields and nested conversions handled here ...\n}\n```","codeResolution":"The conversion logic currently mixes mapping, validation, and nested struct handling within single functions, which can be improved by delegating responsibilities to specialized helpers for better maintainability and clarity.\n\n```go\n// Go\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n\tif protoDef == nil {\n\t\treturn nil\n\t}\n\treturn convertDefinitionFromProto(protoDef)\n}\n```","severity":"Critical","rationale":"The code defines many helper functions, but the two main conversion functions—`ConvertProtoToModel` and `ConvertModelToProto`—are large and handle multiple responsibilities, such as field mapping, nil checks, and recursive property conversion. This violates functionMethodCounts principles by concentrating too much logic in single functions (see lines 7–44 and 52–89). Such monolithic functions hinder maintainability and make unit testing difficult, as changes in one part can have unintended side effects elsewhere. Breaking these into smaller, focused functions would improve readability, testability, and future extensibility.","lineStart":7,"lineEnd":77,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code violates dependenciesModules principles by tightly coupling the conversion logic to two specific external packages, making future maintenance and testing difficult.\n\n```go\nimport (\n\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n)\n```","codeResolution":"The solution for dependenciesModules demonstrates a clean separation between protobuf and Go model dependencies, using only the required packages for conversion logic. Here is the replacement code for the block identified in `violatingCode`:\n\n```go\n// Use the Operation abstraction for conversion\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n\treturn getOperation(\"protoToModel\").Execute(protoDef)\n}\n\nfunc ConvertModelToProto(modelDef *jsonSchema.Definition) *pb.Definition {\n\treturn getOperation(\"modelToProto\").Execute(modelDef)\n}\n```","severity":"Critical","rationale":"The code imports two external packages: `pb \"github.com/objectweaver/go-sdk/grpc\"` and `\"github.com/objectweaver/go-sdk/jsonSchema\"`. This is appropriate for the conversion logic, but tightly coupling the conversion functions to these specific packages can hinder maintainability and testability. If either package changes its API, all conversion functions must be updated, increasing technical debt. Abstracting dependencies behind interfaces or using dependency injection would allow easier mocking for unit tests and future-proof the code against upstream changes. This approach would also improve modularity and reduce the risk of breaking changes propagating throughout the codebase.","lineStart":3,"lineEnd":5,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The ConvertProtoToModel function exhibits excessive nestingDepth, particularly in its handling of the Properties map, which complicates readability and maintainability.\n\n```go\nif protoDef.Properties != nil {\n\tfor key, protoProperty := range protoDef.Properties {\n\t\tmodelDef.Properties[key] = *ConvertProtoToModel(protoProperty)\n\t}\n}\n```","codeResolution":"The solution for nestingDepth in this code focuses on flattening the handling of the Properties map to reduce cognitive complexity and improve maintainability. Replace the deeply nested block with a direct map transformation using a helper function:\n\n```go\n// Go\nmodelDef.Properties = convertPropertiesMap(protoDef.Properties)\n```\n\nThis approach eliminates manual iteration and nested assignments, delegating the transformation to a dedicated abstraction.","severity":"Critical","rationale":"The code demonstrates moderate nesting depth, especially in the `ConvertProtoToModel` and `ConvertModelToProto` functions (lines 8–44 and 47–83). Both use nested `if` statements and loops, particularly when handling the `Properties` map. Excessive nesting can make the code harder to read, maintain, and test, increasing the risk of logical errors and making future changes more error-prone. Flattening the structure—such as by using guard clauses or extracting deeply nested logic into helper functions—would improve maintainability and reduce cognitive load for future contributors.","lineStart":19,"lineEnd":37,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode suffers from excessive lines of code due to deeply nested struct field assignments and repetitive nil checks, making it harder to maintain and refactor.\n\n```go\nmodelDef := &jsonSchema.Definition{\n\tType:               jsonSchema.DataType(protoDef.Type),\n\tInstruction:        protoDef.Instruction,\n\tProperties:         make(map[string]jsonSchema.Definition),\n\tItems:              ConvertProtoToModel(protoDef.GetItems()), // Use Getters to handle nil cases\n\tModel:              protoDef.Model,\n\tProcessingOrder:    protoDef.ProcessingOrder,\n\tSystemPrompt:       getStringPointer(protoDef.GetSystemPrompt()), // Safe getter for pointers\n\tImprovementProcess: protoDef.ImprovementProcess,\n\tSelectFields:       protoDef.SelectFields,\n\tVoters:             protoDef.Voters,\n\tHashMap:            ConvertProtoToHashMap(protoDef.GetHashMap()),   // Check with Getters\n\tNarrowFocus:        ConvertProtoToFocus(protoDef.GetNarrowFocus()), // Handle nil safely\n\tReq:                ConvertProtoToRequestFormat(protoDef.GetReq()),\n\tChoices:            ConvertProtoToChoices(protoDef.GetChoices()),\n\tSpeechToText:       convertProtoSpeechToText(protoDef.GetSpeechToText()), // Safely handle nested structs\n\tTextToSpeech:       convertProtoTextToSpeech(protoDef.GetTextToSpeech()),\n\tSendImage:          convertProtoSendImage(protoDef.GetSendImage()), // Handle nil structs\n\tStream:             protoDef.Stream,\n}\n```","codeResolution":"The code currently handles conversion logic directly within the main functions, resulting in high lines of code and reduced clarity. To improve linesOfCode, delegate conversion responsibilities to dedicated abstraction functions and minimize inline logic.\n\n```go\n// Go\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n    return ProtoToModelConverter(protoDef)\n}\n\nfunc ConvertModelToProto(modelDef *jsonSchema.Definition) *pb.Definition {\n    return ModelToProtoConverter(modelDef)\n}\n```","severity":"Critical","rationale":"The code violates linesOfCode best practices by being overly verbose and repetitive, especially in the conversion functions (e.g., `ConvertProtoToModel`, `ConvertModelToProto`). Many lines are spent manually mapping fields and handling nil checks, which inflates the LoC and makes the code harder to maintain. For example, the repeated pattern of checking for nil and then assigning fields (lines 8–41, 49–82) could be abstracted into helper functions or generic mappers. Excessive LoC increases the risk of bugs, complicates future changes, and reduces readability. Refactoring to reduce duplication and improve abstraction would enhance maintainability and correctness.","lineStart":1,"lineEnd":87,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The ConvertProtoToModel function exhibits excessive cyclomatic complexity due to deep nesting and multiple conditional branches, making the code harder to maintain and test.\n\n```go\nif protoDef.Properties != nil {\n\tfor key, protoProperty := range protoDef.Properties {\n\t\tmodelDef.Properties[key] = *ConvertProtoToModel(protoProperty)\n\t}\n}\n```","codeResolution":"The solution for cyclomatic complexity refactors the property conversion logic to use a dedicated abstraction, reducing nested branching and improving maintainability.\n\n```go\n// Replace the Properties map conversion block with:\nmodelDef.Properties = convertPropertiesMap(protoDef.Properties)\n```","severity":"Critical","rationale":"The cyclomatic complexity in both `ConvertProtoToModel` and `ConvertModelToProto` is elevated due to numerous conditional branches and deep nesting, especially when handling properties and nested conversions (lines 8–41, 51–84). This matters because high complexity makes the code harder to maintain, increases the risk of bugs, and complicates unit testing. Each additional branch or nested structure adds a new path that must be tested and understood, which can slow down future development and debugging. Refactoring these functions into smaller, single-responsibility helpers would reduce complexity, improve readability, and make the codebase more robust.","lineStart":13,"lineEnd":87,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":15,"dependenciesModules":2,"functionMethodCounts":11,"linesOfCode":177,"nestingDepth":2}},"hash":"7ee0ba479b3f38bd7b0a818dec1f97bd7eb920d7e88b6335decaee3b25ca5158","id":"eJzlWU1v4zYQ/SusDkEceO27AB8KL/IBdNsgdvey3gMjj2U1EqmQdHbdIP+94KeGMuU4yd6aU8SZeZzhDN8jkueMSglSVqxccl5neTbnTVvDz0rts3FW8DXMOVPAVJZnLS0eaAmk4OwJRCU5W7EVq5qWC0XOV2yl2nuyyspKbXf3k4I3000loNhWTfuJi3Ja8k9y/TAtRVusMu3+uu8/krNFsYWG6oiR3m86JXOTgLoVXPEl/8LXULuklCSUtHr9frchn2FTsUpVnBHFyZ7vBLnipDH+nW3FNjtWpEDPDdJn2JCL9n7SRYzIRZcYWifPuqpqQ0LcbEZYVdv1lRKgdoLpFf39oqtZKZOO9s1n5CwJ66KX+xZyEv9gf6qodglJT/TXaGyDb5hUYldouIARHJHRud8K3oJQFchux4Y+wHlD229SiYqV35O5hv0UNLKX7bETnlyBjTkfjcZkOiV/SyBXoBQIqZu3pWxdgznMgkqQdheD0dslIBpjV09hx/wvsQaRR449owtZ7KWC5lbwplV+ixLUwhR/yyumQETp4wBfxYJuQEcpEGTDBWltnEv/pmkFf4IGmE8wR005MPrEoIZCXVZQr8MJhyhsdP5fud4xTx+SNTrPayq3X2gbucZNcx5R3X5Nl0x00fMtFA/kR6W2voMW/k8qBP9xyYtdl00Mb2wROIrxZ3rdjYKkG6j3Fv0OHvu3o4d+B487kOqSi4aqaJc7eNToFmi+5VUB8sgpOI8Iwq8FmEULUGyXfAk/w/wUCAbb4znCBjRH9T7cApAK1sReWne42nvpQFPbYXu0XWTosge2vmloiRknyt7b49TDaqJXONuFEkCbgZm0xjHiyA6pIybS0LZHtxNk/S1iXn33HmA/tq7Oba8pV1BWQhLBhXYMjYzfHmD/nczIxSCn+T1GFuUFVeNkwMOu2IvTtWuoW00UO1Z40bITrimEWNpFFGJk64CSnmjtXEfkwsV4XdK22YysslU2rEl+6eyJ1l1urlBT4ZKbejvNHZJWXUFSj2PNxaDnQQ/TGjvqaXGoLcSdoLkSUbUeAn0gPZgJpvPeNEXhM3KRjEHbheeAlvgo+yPSblsXjuNVNQ+O71Pz3gvndRlPNm1iAnx0Sp6D52vyjG/difKM++ILSEhsl+xbJLZr8mkSG/xPlVh8oF5TA4hb8Cd7REoxjNXNAIKiPNAR1cRAsXQGwDt4PEE1MZCXyQDhFsLA9TQH6Y6BseqCOkhLOEFxTWwkrF070apHOiKmthismd0NRasn6KjNKSgmmi+3FDASYtl5v1UsE2o2JJbG9VAsUwhBLBNK6sUyRRxn0R7DYulhB8VSmvc1buaY4IaMCWVrwtUWxOH7yarR4OtMog8jP9HMREKFLUGaovjX5CnI7wDq8yC3DgTYRwnOwXKvH6/fd+uKL/lSUCYLUd1DHiU8ObC7uD8oK3fxZEdx3u7vFLfvlCF3bw/uc9qaxuYD7t7uAiw35QMHYopw9BXh2LWRv0AvyWmI7rtCH2YaonsfTQO2hGmI4t8zDRg1PQ0DznYS8P7xJHzVVJxEMZY40iwhijJ/QjLHnEclTiJbulkDjYpgTmpUR6fS/2YvbODU+LYGp3BVw8q77qmPfkZqJvVfZvIOedKtDhZzqFcxBw1c9dEBO32Qg3pow9zjXqv/R5ZJlf7asB6+ImJWGbjAowO++SCr9NDS/XUFnswbKf9fyRYp/JMOPMkOqes7iknjI+yAcX4JK9gCqoPkUeJx0tWbE8bJullwZ26w4uYvqn917yMHvYZ7kY2zTVXDLVXbLM+6/x+Y/wXMw+ek5NnLfyWvvN4="}
{"assessingTool":"Complexity","filePath":"converison/hashmap.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:10:35.033Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode unnecessarily duplicates logic across two functions, inflating the linesOfCode count without abstraction.\n\n```go\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\tif protoHashMap == nil {\n\t\treturn nil\n\t}\n```","codeResolution":"The codeResolution streamlines the conversion logic by delegating field transformation to a reusable abstraction, reducing repetition and improving maintainability.\n\n```go\n// Replace the conversion block with a call to the abstraction.\nreturn &jsonSchema.HashMap{\n    KeyInstruction:  protoHashMap.KeyInstruction,\n    FieldDefinition: ConvertFieldDefinition(protoHashMap.FieldDefinition),\n}\n```","severity":"Critical","rationale":"### Rationale\n\nThe code snippet demonstrates good linesOfCode practices by keeping each function concise and focused on a single responsibility. This approach improves maintainability, as future changes or debugging efforts are simplified due to the clear separation of concerns. For example, `ConvertProtoToHashMap` and `ConvertModelToProtoHashMap` each handle only one conversion direction, reducing cognitive load. However, if the codebase grows and similar conversion patterns emerge, duplicating logic across multiple functions could increase LoC unnecessarily. Refactoring shared logic into helper functions would further reduce redundancy and enhance maintainability, making the codebase easier to test and less prone to errors.","lineStart":1,"lineEnd":20,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode only defines two functions, failing to separate responsibilities and thus violating functionMethodCounts best practices.\n\n```go\n// ConvertProtoToHashMap converts a protobuf HashMap to the Go model HashMap\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n    // ...\n}\n\n// ConvertModelToProtoHashMap converts a Go model HashMap to a protobuf HashMap\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n    // ...\n}\n```","codeResolution":"The conversion logic currently mixes data transformation and validation, which can be separated for better maintainability and testability. Here’s how the main conversion functions should be refactored to delegate responsibilities to specialized helpers:\n\n```go\n// Go\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\treturn convertProtoHashMap(protoHashMap)\n}\n\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n\treturn convertModelHashMap(modelHashMap)\n}\n```","severity":"Critical","rationale":"The code defines only two functions, each handling both validation and conversion logic. This low function count means responsibilities are not well separated, making the code harder to maintain and extend. For example, if validation rules or conversion logic change, both functions must be updated, increasing the risk of errors. Additionally, testing individual concerns (like validation or conversion) becomes difficult, reducing code reliability. Splitting responsibilities into smaller, focused functions would improve maintainability and correctness, aligning better with functionMethodCounts principles.","lineStart":7,"lineEnd":22,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The ConvertProtoToHashMap and ConvertModelToProtoHashMap functions do not present cyclomatic complexity concerns, as their logic is linear and contains only a single conditional branch.\n\n```go\nif protoHashMap == nil {\n\treturn nil\n}\n```","codeResolution":"The solution for cyclomatic complexity in this context focuses on reducing nested conditionals and flattening logic by delegating conversion responsibilities to specialized helper functions. This approach improves readability and maintainability.\n\n```go\n// Improved conversion using abstraction\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\treturn convertHashMapFromProto(protoHashMap)\n}\n\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n\treturn convertHashMapToProto(modelHashMap)\n}\n```","severity":"Critical","rationale":"## Rationale\n\nThe cyclomatic complexity in this code is low, with each function containing only a single conditional branch (`if ... == nil`). This simplicity improves maintainability and testability, as there are minimal paths to reason about and fewer opportunities for logic errors. However, if future requirements introduce more branching (e.g., additional validation or transformation logic), complexity could quickly increase. Keeping functions focused and limiting decision points ensures the code remains easy to understand and less error-prone. This approach aligns well with cyclomatic complexity principles, supporting correctness and maintainability.","lineStart":13,"lineEnd":22,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode unnecessarily nests return statements inside if-blocks, resulting in a nesting depth that could be avoided with guard clauses.\n\n```go\nif protoHashMap == nil {\n\treturn nil\n}\n```","codeResolution":"The codeResolution for nestingDepth focuses on flattening the control flow in the conversion functions by using guard clauses and delegating nested logic to helper abstractions. Replace the original block with the following streamlined code:\n\n```go\n// Go\n\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\tif protoHashMap == nil {\n\t\treturn nil\n\t}\n\treturn getHashMapFromProto(protoHashMap)\n}\n\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n\tif modelHashMap == nil {\n\t\treturn nil\n\t}\n\treturn getProtoHashMapFromModel(modelHashMap)\n}\n```","severity":"Critical","rationale":"The code demonstrates good adherence to nesting depth principles, with a maximum depth of 2 (function scope and a single 'if' statement). This shallow nesting makes the logic easy to follow and reduces cognitive load for future maintainers. Minimal nesting also lowers the risk of introducing bugs related to deeply nested conditions and simplifies unit testing. Keeping nesting depth low improves maintainability and readability, ensuring that future changes or extensions to the conversion logic can be made safely and efficiently.","lineStart":9,"lineEnd":13,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code tightly couples the conversion logic to two external packages, making future maintenance and testing more difficult.\n\n```go\nimport (\n\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n)\n```","codeResolution":"The codeResolution for dependenciesModules demonstrates a clean separation between protobuf and Go model conversions, relying only on two direct imports. Here is the improved replacement code, assuming all conversion helpers are abstracted:\n\n```go\n// Go\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\treturn convertHashMap(protoHashMap)\n}\n\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n\treturn convertHashMap(modelHashMap)\n}\n```\nThis approach delegates conversion logic to a shared abstraction, reducing duplication and improving maintainability.","severity":"Critical","rationale":"The code imports two external packages: `pb` and `jsonSchema` from the same organization. While this is acceptable for the conversion logic, tightly coupling the conversion functions to these specific dependencies can hinder maintainability. If either package changes its API or is replaced, all dependent code must be updated. Additionally, importing entire packages when only a few types are needed may increase build times and binary size. To improve, consider using interfaces or type aliases to decouple the conversion logic from direct package dependencies, making future refactoring and testing easier.","lineStart":1,"lineEnd":9,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":2,"functionMethodCounts":2,"linesOfCode":31,"nestingDepth":2}},"hash":"6f4ee198c5ee1648be167a3cf4511b5d1e3599367a81a668dc0dfd38e3ac62eb","id":"eJyVk0uLwyAUhf+KuBiakib7QFcd5sFQKEyXbowxidPkXlEzTCn974Np0sZ2HnSn93qO93zigXJrpbUKqi1iQzO6wlY38ku5PY2pwEKuEJwERzOqudjxShKB8CmNsggMGKhWo3FkxoA5nRNGK+XqLk8EtmmpjBS1avUCTZVWuLDFLq2MFoz64/+f/bAI76KWLfeKyN+XpmTVD+A2Bh1u8YXbes31MJazhBPtO3lXkrHnkLhakmckLRayGesMyg7Ez36z3mQ0mOs8GdYRmV/GGovk4AOpkgSq5ZKAak495ox0nQFf8fujD3MuPtxaDqo3uX8F60wnnELISHBDEnbjk+RJyaZ4lKUCddKEAdceQRAvuVJE8TDhMSTeK7e4mWacYL/G67HfPkYI/QfLWW9yJn9LJpo+x5l8oLqD/MXqN+JT5/uIT9MFsf4iTmNaqkZuuKtpRi+/La25rVuukwrp8RsIr2Ly"}
{"assessingTool":"Complexity","filePath":"client/req.go","grade":"B","username":"HLamb","timestamp":"2025-10-12T17:10:28.922Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"testability","violatingCode":"The SendRequest function has poor testability due to direct logging and returning nil on error, making it hard to assert error handling in tests.\n\n```go\nif err != nil {\n    log.Println(\"failed to execute request\", err)\n    return nil\n}\n```","codeResolution":"The current SendRequest implementation tightly couples logging and error handling, making unit testing difficult. Refactor to return errors and results separately, improving testability and separation of concerns:\n\n```go\n// Go\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) (*Res, error) {\n\trequest, err := ExecuteRequest(currentGen, def)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to execute request: %w\", err)\n\t}\n\tvalue, err := extractValue(request)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to extract value: %w\", err)\n\t}\n\treturn value, nil\n}\n```","severity":"Medium","rationale":"The use of direct logging (`log.Println`) and returning `nil` in `SendRequest` makes the code difficult to test, as error handling is tightly coupled with side effects and not exposed to the caller. This prevents unit tests from verifying error scenarios or capturing error details, reducing maintainability and correctness. For example, lines where errors are logged and `nil` is returned (`log.Println(\"failed to execute request\", err); return nil`) obscure the root cause and make debugging harder. Refactoring to return errors instead of logging them would improve testability, allowing tests to assert specific error conditions and making the codebase easier to maintain and extend.","lineStart":44,"lineEnd":54,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode suffers from excessive nesting within the ExecuteRequest function, making the logic harder to follow and maintain.\n\n```go\nif d.Req.Body == nil {\n\td.Req.Body = make(map[string]interface{})\n}\nfor key, value := range currentGen {\n\td.Req.Body[key] = value\n}\n```","codeResolution":"The solution for nestingDepth refactors the SendRequest function to use guard clauses, reducing unnecessary nesting and improving readability.\n\n```go\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\trequest, err := ExecuteRequest(currentGen, def)\n\tif err != nil {\n\t\tlog.Println(\"failed to execute request\", err)\n\t\treturn nil\n\t}\n\tvalue, err := extractValue(request)\n\tif err != nil {\n\t\tlog.Println(\"failed to extract value\", err)\n\t\treturn nil\n\t}\n\treturn value\n}\n```","severity":"Critical","rationale":"The code demonstrates moderate nesting depth, particularly in the `ExecuteRequest` function, where multiple layers of logic (body merging, marshaling, request creation, header setting, and execution) are handled sequentially within a single function scope. This approach can hinder maintainability, as future changes or debugging efforts require navigating through tightly coupled steps. Deep nesting also increases cognitive load and the risk of introducing subtle bugs, especially if error handling or branching logic expands. Refactoring into smaller, single-responsibility functions (e.g., separate body preparation, request creation, and execution) would flatten the structure, making the code easier to test, extend, and reason about.","lineStart":17,"lineEnd":38,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode suffers from excessive lines of code due to deeply nested logic and repeated procedural steps within the ExecuteRequest function.\n\n```go\nfor key, value := range currentGen {\n    d.Req.Body[key] = value\n}\nbody, err := json.Marshal(d.Req.Body)\nreq, err := http.NewRequest(string(d.Req.Method), d.Req.URL, bytes.NewBuffer(body))\n```","codeResolution":"The solution streamlines the code by replacing verbose request execution logic with a concise abstraction, reducing lines of code and improving maintainability.\n\n```go\n// Go\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\trequest, err := ExecuteRequest(currentGen, def)\n\tif err != nil {\n\t\tlog.Println(\"failed to execute request\", err)\n\t\treturn nil\n\t}\n\tvalue, err := extractValue(request)\n\tif err != nil {\n\t\tlog.Println(\"failed to extract value\", err)\n\t\treturn nil\n\t}\n\treturn value\n}\n```\nReplace the above block with:\n\n```go\n// Go\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\treturn RequestHandler(def, currentGen)\n}\n```","severity":"Critical","rationale":"## Rationale\n\nThe code snippet demonstrates excessive lines of code within single functions, notably in `ExecuteRequest`, which handles multiple responsibilities—merging data, marshaling JSON, building requests, setting headers, and executing HTTP calls. This violates linesOfCode principles by making the code harder to maintain and test. Long, monolithic functions increase cognitive load, obscure bugs, and complicate future changes. Refactoring into smaller, purpose-driven functions (e.g., separate header-setting, body-merging, and request-execution) would improve readability, facilitate unit testing, and reduce the risk of errors. Reducing LoC per function directly enhances maintainability and correctness.","lineStart":22,"lineEnd":54,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The code violates functionMethodCounts principles by combining multiple responsibilities into just two functions, resulting in a monolithic and less maintainable design.\n\n```go\nfunc ExecuteRequest(currentGen map[string]any, d *jsonSchema.Definition) (*http.Response, error) {\n\t// Merge currentGen into the existing body\n\t// Marshal the body to JSON\n\t// Create the HTTP request\n\t// Set headers and authorization\n\t// Execute the request\n}\n```","codeResolution":"The solution for functionMethodCounts involves refactoring monolithic logic into smaller, purpose-driven functions to improve maintainability and clarity.\n\n```go\n// Go\n\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\trequest, err := ExecuteRequest(currentGen, def)\n\tif err != nil {\n\t\tlog.Println(\"failed to execute request\", err)\n\t\treturn nil\n\t}\n\n\tvalue, err := extractValue(request)\n\tif err != nil {\n\t\tlog.Println(\"failed to extract value\", err)\n\t\treturn nil\n\t}\n\n\treturn value\n}\n```\nReplace the above with:\n\n```go\n// Go\n\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\trequest, err := buildAndDispatchRequest(def, currentGen)\n\tif err != nil {\n\t\tlog.Println(\"failed to execute request\", err)\n\t\treturn nil\n\t}\n\treturn handleResponse(request)\n}\n```","severity":"Critical","rationale":"## Rationale\n\nThe code defines only two functions—`ExecuteRequest` and `SendRequest`—each handling multiple responsibilities such as request construction, header management, error handling, and response extraction. This low function/method count leads to tightly coupled logic, making the code harder to maintain, test, and extend. For example, lines 10–38 in `ExecuteRequest` mix body merging, JSON marshaling, HTTP request creation, and header setting. Such monolithic functions hinder readability and increase the risk of bugs when requirements change. Breaking these responsibilities into smaller, focused functions would improve maintainability and correctness, and make unit testing more effective.","lineStart":18,"lineEnd":38,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The ExecuteRequest function disregards cyclomatic complexity principles by combining multiple responsibilities and branching logic into a single, monolithic block.\n\n```go\nfor key, value := range currentGen {\n    d.Req.Body[key] = value\n}\n```","codeResolution":"The solution for cyclomatic complexity refactors the original request execution logic by delegating each major step to specialized helper functions, reducing branching and improving readability.\n\n```go\n// Go\nfunc ExecuteRequest(currentGen map[string]any, d *jsonSchema.Definition) (*http.Response, error) {\n\tmergeBody(currentGen, d)\n\tbody, err := marshalBody(d)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq, err := buildRequest(d, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn sendRequest(req)\n}\n```","severity":"Critical","rationale":"High cyclomatic complexity in `ExecuteRequest` arises from multiple responsibilities—merging maps, marshaling JSON, building requests, setting headers, and handling errors—all within a single function. This increases the number of decision points (e.g., multiple `if err != nil` checks and loops), making the code harder to maintain and test. If any part fails, debugging becomes difficult due to tightly coupled logic. Refactoring into smaller, focused functions (e.g., separate body merging, request creation, and error handling) would reduce complexity, improve readability, and make future changes safer and easier.","lineStart":22,"lineEnd":44,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code unnecessarily imports six packages, including both standard and third-party libraries, which increases complexity and potential maintenance overhead.\n\n```go\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n\t\"log\"\n\t\"net/http\"\n)\n```","codeResolution":"The code demonstrates solid dependency management by relying only on standard libraries and a single external package, keeping the module footprint minimal. To further improve modularity and separation of concerns, the request execution logic can be abstracted using an `Operation` interface. Here’s how the core block can be replaced:\n\n```go\n// Go\n\nop := getOperation(d.Req.Method)\nresp, err := op.Execute(d.Req.URL, d.Req.Headers, d.Req.Authorization, d.Req.Body)\nif err != nil {\n\tlog.Println(\"failed to execute request\", err)\n\treturn nil\n}\n```","severity":"Critical","rationale":"This code imports six packages, including a third-party dependency (`github.com/objectweaver/go-sdk/jsonSchema`). While the use of standard libraries is justified for HTTP requests and JSON handling, the direct coupling to the external `jsonSchema` package on multiple lines (e.g., lines 7, 13, 34) increases the risk of breaking changes if the dependency updates. Excessive dependencies can hinder maintainability, complicate upgrades, and introduce hidden bugs. To improve, consider abstracting interactions with `jsonSchema` behind interfaces or limiting its usage to dedicated modules, reducing the impact of future changes and making unit testing easier.","lineStart":6,"lineEnd":38,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A-","qualityDesign":"A","readability":"A-","testability":"C+"},"issues":{"cyclomaticComplexity":6,"dependenciesModules":6,"functionMethodCounts":2,"linesOfCode":69,"nestingDepth":2}},"hash":"b3b7aa075e2ccf03262a5580bbb9703d2d488905316e76a7b776f7bf8b154bb5","id":"eJyllFFv00AMx7+KOQmUTFnyXmkPMAYIsTG1gxfCwzVxkqOJr7tz6MrU747ucmlTUDcJXqqez2f/7L/jRyGtRWsV1Xdat2ImLnW3bvFB8VYkotAlXmpiJBYzsZbFStYIRauQOKecVLfWhiHKKedcLLeMNhfDAanQpaI6+2E1jcaq4/Fvrbjpl2mhu6xSBotGdetzbeqs1ue2XPlni6LBTo4vWl2Pfwk5a5jX7hw7kCyDqwcsesY53vdoGXA4WpAEH+7ubsGEi6W0WIIm4AYheL/TppOcU9VT8UegqOiNQeL3SNDJ9TfLRlH9XdI2gRLODpjpW6wUKVaaYojOHF46R7vWZDEBNEabGB4df5bBNRrXyENoRaw9ET4oy4pqWOpy67xVBWU6x/v0jS63cHEBpNohTs7TC+jkCqMJoiJGU8kCH3euR7xzP5U2sMJtAj9l2yPMLsBIOkb5K/a3FW6/w8XwZIwU6pDGNrL15A4YWMPHxecbd+3OvnCXxfUpDd7RIXQcKnReL45KM8i9IWdJoOo4vXINrKJcVFK1WLpEXUjuEs3g5SYXPl18jHhpUDJ6wukcuFuD93tAr9cNbkbZhyYG1GvkRpdxEpT4Mv+UgJ929+JNX1VoIkcR/1c9xUAaAE9XtECGBmWJxj4l6cD6YXA8YIymdIEcHd4dRiRkkD032qhf0k106Nb0aS5eH3mIsTtH5nhPHT4rL8REg2GZOOpXXoJLf37cDRntei/Q4Ji+1ZHB+//qc1gNzzQ6BBoYSLU57cKm8cOOrd6ALoreWNgobtSwUPxHR7KFjTYrRbWFSIG7XcVhvSyQynHISqxOrJAETu6dGM7maMdVMmkncCMZlAXrOqp7BkIsrSvZIpXeIse4LijoykPXSGgku7W4/IEFp2MHfNi9AicXYwIlVqclaXWd3hpF3NJTOkw1mOo40cRP6p4HH9jIgr86YxSC/AuFjxK22/MMwRiW4S4nkYhKtXgruREzMYxp5j6WWovdb8iNqRE="}
{"assessingTool":"SOLID","filePath":"converison/requestFormat.go","grade":"C","username":"HLamb","timestamp":"2025-10-12T17:10:23.580Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"openClosed","violatingCode":"The conversion functions tightly couple the logic to specific struct fields, making it hard to extend for new fields or types without modifying existing code.\n\n```go\nreturn &jsonSchema.RequestFormat{\n\tURL:           protoReq.Url,\n\tMethod:        jsonSchema.HTTPMethod(protoReq.Method),\n\tHeaders:       protoReq.Headers,\n\tBody:          body,\n\tAuthorization: protoReq.Authorization,\n\tRequireFields: protoReq.RequireFields,\n}\n```","codeResolution":"The current ConvertProtoToRequestFormat and ConvertModelToProtoRequestFormat functions can be improved for openClosed compliance by delegating conversion logic to an Operation abstraction. Here is the replacement code for the violating block:\n\n```go\ngo\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\treturn getOperation(\"ProtoToModel\").Convert(protoReq)\n}\n\nfunc ConvertModelToProtoRequestFormat(modelReq *jsonSchema.RequestFormat) *pb.RequestFormat {\n\treturn getOperation(\"ModelToProto\").Convert(modelReq)\n}\n```","severity":"High","rationale":"The current implementation violates the Open/Closed Principle because any changes to the structure of `RequestFormat` in either the protobuf or Go model require direct modification of both conversion functions. This tightly couples the conversion logic to the data models, making future extensions or new fields error-prone and harder to maintain. As a result, adding or updating fields increases the risk of bugs and reduces scalability, since developers must update multiple places and manually ensure consistency. Refactoring to use reflection or generic mapping would allow the code to adapt to changes without requiring direct edits, improving maintainability and adherence to open/closed.","lineStart":13,"lineEnd":22,"status":""},{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The code lacks interface abstraction, preventing substitutability and violating the Liskov Substitution Principle.\n\n```go\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\tif protoReq == nil {\n\t\treturn nil\n\t}\n\t// ...\n}\n```","codeResolution":"The current conversion functions can be improved for Liskov Substitution Principle by abstracting the conversion logic through an Operation interface, allowing interchangeable conversion strategies.\n\n```go\n// Golang\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n    return getOperation(\"ProtoToModel\").Convert(protoReq)\n}\n\nfunc ConvertModelToProtoRequestFormat(modelReq *jsonSchema.RequestFormat) *pb.RequestFormat {\n    return getOperation(\"ModelToProto\").Convert(modelReq)\n}\n```","severity":"High","rationale":"The lack of interface abstraction in the conversion functions directly violates the Liskov Substitution Principle. By tightly coupling the conversion logic to specific types (`pb.RequestFormat` and `jsonSchema.RequestFormat`), the code cannot easily accommodate alternative implementations or extended types. This rigidity reduces maintainability, as any future changes or new formats require modifying existing functions rather than substituting new implementations. It also impacts correctness, since substitutability is limited and polymorphic behavior is not supported, increasing the risk of errors if requirements evolve. Introducing interfaces for request formats would allow for more flexible, testable, and extensible code.","lineStart":1,"lineEnd":28,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code tightly couples conversion logic directly to concrete types from external packages, violating dependency inversion by not abstracting dependencies.\n\n```go\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\tif protoReq == nil {\n\t\treturn nil\n\t}\n```","codeResolution":"To address dependency inversion, the conversion logic should delegate to an injected abstraction rather than directly calling conversion helpers. Here is the replacement for the violating code block:\n\n```go\n// Golang\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat, op Operation) *jsonSchema.RequestFormat {\n\tif protoReq == nil {\n\t\treturn nil\n\t}\n\n\tbody, _ := op.Convert(protoReq.Body)\n\n\treturn &jsonSchema.RequestFormat{\n\t\tURL:           protoReq.Url,\n\t\tMethod:        jsonSchema.HTTPMethod(protoReq.Method),\n\t\tHeaders:       protoReq.Headers,\n\t\tBody:          body,\n\t\tAuthorization: protoReq.Authorization,\n\t\tRequireFields: protoReq.RequireFields,\n\t}\n}\n```","severity":"Critical","rationale":"This code tightly couples conversion logic to specific protobuf and Go model types, violating dependency inversion principles. By directly referencing concrete types (e.g., `pb.RequestFormat`, `jsonSchema.RequestFormat`) in conversion functions, it becomes difficult to extend or test the code without modifying these functions. This reduces maintainability and flexibility, as any change in the underlying types or conversion requirements would require direct updates to the conversion logic. Introducing interfaces or abstraction layers would decouple the conversion process, making the codebase easier to maintain and adapt to future changes.","lineStart":7,"lineEnd":24,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"C-","openClosedScore":"C-","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package converison\n\nimport (\n\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n)\n\n// ConvertProtoToRequestFormat converts a protobuf RequestFormat to the Go model RequestFormat\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\tif protoReq == nil {\n\t\treturn nil\n\t}\n\n\tbody, _ := ConvertStructToMap(protoReq.Body)\n\n\treturn &jsonSchema.RequestFormat{\n\t\tURL:           protoReq.Url,\n\t\tMethod:        jsonSchema.HTTPMethod(protoReq.Method),\n\t\tHeaders:       protoReq.Headers,\n\t\tBody:          body,\n\t\tAuthorization: protoReq.Authorization,\n\t\tRequireFields: protoReq.RequireFields,\n\t}\n}\n\n// ConvertModelToProtoRequestFormat converts a Go model RequestFormat to a protobuf RequestFormat\nfunc ConvertModelToProtoRequestFormat(modelReq *jsonSchema.RequestFormat) *pb.RequestFormat {\n\tif modelReq == nil {\n\t\treturn nil\n\t}\n\n\tbody, _ := ConvertMapToStruct(modelReq.Body)\n\n\treturn &pb.RequestFormat{\n\t\tUrl:           modelReq.URL,\n\t\tMethod:        string(modelReq.Method),\n\t\tHeaders:       modelReq.Headers,\n\t\tBody:          body,\n\t\tAuthorization: modelReq.Authorization,\n\t\tRequireFields: modelReq.RequireFields,\n\t}\n}\n","reason":"Modified","start":1,"end":43,"grade":"C"}]},"hash":"121ba767a241f9db617493c6b60a8fe8d4b7fd92081fd53809d40e42bc082a12","id":"eJydlFFvmzAQx7+K5YcpVDS8I+Vha9V2UqJFCXlDmgwc4BV81D4mdVW++2SgBrrQVeXNd/+7+5/9Ey9cGAPGSFVEiBUP+fHH9vst93mKGdygIlDEQ96I9FEUwFJUv0FLgypWsZJ1g5rYKlYxNQmLeSGpbJN1inWQSw1pKevmGnURFHhtsseg0E0acyv/v/aXQXVMS6iFrfDsvCBgN50B2mskjPAATy0YukNdCxrMkWGCNTaftDmbKwgZlcDukdWYQTXPxipvVfrehFXX9gBP7KpJ1rOUx65Gw/MUe7ELy5y56s2GKVn18Zg0UKuVjdjz2S4aU4LZs89+snDzauhIuk0pwp1onI/1N8yevb5iaPNlycYw7XTYhmz8XKeTrvxesQMqMXOiSb+HKNr32dFBf/aG2gcQGWgTvu0+xAeVdT0x0e3aZ762VKKWfwRJVOFYP4sPWrud1HAnocrMRDuL+8Odnuf87OzzR7gfai5DdBkTC9ESYHOEFoesurYdR0uv5f2LmOPIVX+Ko51oIuxhcj4ucfR2/Cs/upry4zqcDtvL/BjSUhXjqHeBcapPAuPqPwCM0y4Bw32eywr2gkoe8vHXF+jpvawL5Oe/f/rq4g=="}
{"assessingTool":"SOLID","filePath":"grpc/object-generation_grpc.pb.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:10:15.257Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"dependencyInversionScore":"C-","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"A+","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"// Code generated by protoc-gen-go-grpc. DO NOT EDIT.\n// versions:\n// - protoc-gen-go-grpc v1.5.1\n// - protoc             v3.20.3\n// source: object-generation.proto\n\npackage grpc\n\nimport (\n\tcontext \"context\"\n\tgrpc \"google.golang.org/grpc\"\n\tcodes \"google.golang.org/grpc/codes\"\n\tstatus \"google.golang.org/grpc/status\"\n)\n\n// This is a compile-time assertion to ensure that this generated file\n// is compatible with the grpc package it is being compiled against.\n// Requires gRPC-Go v1.64.0 or later.\nconst _ = grpc.SupportPackageIsVersion9\n\nconst (\n\tJSONSchemaService_GenerateObject_FullMethodName         = \"/jsonSchema.JSONSchemaService/GenerateObject\"\n\tJSONSchemaService_StreamGeneratedObjects_FullMethodName = \"/jsonSchema.JSONSchemaService/StreamGeneratedObjects\"\n)\n\n// JSONSchemaServiceClient is the client API for JSONSchemaService service.\n//\n// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.\n//\n// The JSONSchemaService defines a service for generating JSON objects based on a schema definition.\ntype JSONSchemaServiceClient interface {\n\t// Standard request-response RPC\n\tGenerateObject(ctx context.Context, in *RequestBody, opts ...grpc.CallOption) (*Response, error)\n\t// New method: Server-side streaming RPC\n\tStreamGeneratedObjects(ctx context.Context, in *RequestBody, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamingResponse], error)\n}\n\ntype jSONSchemaServiceClient struct {\n\tcc grpc.ClientConnInterface\n}\n\nfunc NewJSONSchemaServiceClient(cc grpc.ClientConnInterface) JSONSchemaServiceClient {\n\treturn &jSONSchemaServiceClient{cc}\n}\n\nfunc (c *jSONSchemaServiceClient) GenerateObject(ctx context.Context, in *RequestBody, opts ...grpc.CallOption) (*Response, error) {\n\tcOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)\n\tout := new(Response)\n\terr := c.cc.Invoke(ctx, JSONSchemaService_GenerateObject_FullMethodName, in, out, cOpts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\nfunc (c *jSONSchemaServiceClient) StreamGeneratedObjects(ctx context.Context, in *RequestBody, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamingResponse], error) {\n\tcOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)\n\tstream, err := c.cc.NewStream(ctx, &JSONSchemaService_ServiceDesc.Streams[0], JSONSchemaService_StreamGeneratedObjects_FullMethodName, cOpts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tx := &grpc.GenericClientStream[RequestBody, StreamingResponse]{ClientStream: stream}\n\tif err := x.ClientStream.SendMsg(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := x.ClientStream.CloseSend(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn x, nil\n}\n\n// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.\ntype JSONSchemaService_StreamGeneratedObjectsClient = grpc.ServerStreamingClient[StreamingResponse]\n\n// JSONSchemaServiceServer is the server API for JSONSchemaService service.\n// All implementations must embed UnimplementedJSONSchemaServiceServer\n// for forward compatibility.\n//\n// The JSONSchemaService defines a service for generating JSON objects based on a schema definition.\ntype JSONSchemaServiceServer interface {\n\t// Standard request-response RPC\n\tGenerateObject(context.Context, *RequestBody) (*Response, error)\n\t// New method: Server-side streaming RPC\n\tStreamGeneratedObjects(*RequestBody, grpc.ServerStreamingServer[StreamingResponse]) error\n\tmustEmbedUnimplementedJSONSchemaServiceServer()\n}\n\n// UnimplementedJSONSchemaServiceServer must be embedded to have\n// forward compatible implementations.\n//\n// NOTE: this should be embedded by value instead of pointer to avoid a nil\n// pointer dereference when methods are called.\ntype UnimplementedJSONSchemaServiceServer struct{}\n\nfunc (UnimplementedJSONSchemaServiceServer) GenerateObject(context.Context, *RequestBody) (*Response, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method GenerateObject not implemented\")\n}\nfunc (UnimplementedJSONSchemaServiceServer) StreamGeneratedObjects(*RequestBody, grpc.ServerStreamingServer[StreamingResponse]) error {\n\treturn status.Errorf(codes.Unimplemented, \"method StreamGeneratedObjects not implemented\")\n}\nfunc (UnimplementedJSONSchemaServiceServer) mustEmbedUnimplementedJSONSchemaServiceServer() {}\nfunc (UnimplementedJSONSchemaServiceServer) testEmbeddedByValue()                           {}\n\n// UnsafeJSONSchemaServiceServer may be embedded to opt out of forward compatibility for this service.\n// Use of this interface is not recommended, as added methods to JSONSchemaServiceServer will\n// result in compilation errors.\ntype UnsafeJSONSchemaServiceServer interface {\n\tmustEmbedUnimplementedJSONSchemaServiceServer()\n}\n\nfunc RegisterJSONSchemaServiceServer(s grpc.ServiceRegistrar, srv JSONSchemaServiceServer) {\n\t// If the following call pancis, it indicates UnimplementedJSONSchemaServiceServer was\n\t// embedded by pointer and is nil.  This will cause panics if an\n\t// unimplemented method is ever invoked, so we test this at initialization\n\t// time to prevent it from happening at runtime later due to I/O.\n\tif t, ok := srv.(interface{ testEmbeddedByValue() }); ok {\n\t\tt.testEmbeddedByValue()\n\t}\n\ts.RegisterService(&JSONSchemaService_ServiceDesc, srv)\n}\n\nfunc _JSONSchemaService_GenerateObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(RequestBody)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(JSONSchemaServiceServer).GenerateObject(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: JSONSchemaService_GenerateObject_FullMethodName,\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(JSONSchemaServiceServer).GenerateObject(ctx, req.(*RequestBody))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n\nfunc _JSONSchemaService_StreamGeneratedObjects_Handler(srv interface{}, stream grpc.ServerStream) error {\n\tm := new(RequestBody)\n\tif err := stream.RecvMsg(m); err != nil {\n\t\treturn err\n\t}\n\treturn srv.(JSONSchemaServiceServer).StreamGeneratedObjects(m, &grpc.GenericServerStream[RequestBody, StreamingResponse]{ServerStream: stream})\n}\n\n// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.\ntype JSONSchemaService_StreamGeneratedObjectsServer = grpc.ServerStreamingServer[StreamingResponse]\n\n// JSONSchemaService_ServiceDesc is the grpc.ServiceDesc for JSONSchemaService service.\n// It's only intended for direct use with grpc.RegisterService,\n// and not to be introspected or modified (even as a copy)\nvar JSONSchemaService_ServiceDesc = grpc.ServiceDesc{\n\tServiceName: \"jsonSchema.JSONSchemaService\",\n\tHandlerType: (*JSONSchemaServiceServer)(nil),\n\tMethods: []grpc.MethodDesc{\n\t\t{\n\t\t\tMethodName: \"GenerateObject\",\n\t\t\tHandler:    _JSONSchemaService_GenerateObject_Handler,\n\t\t},\n\t},\n\tStreams: []grpc.StreamDesc{\n\t\t{\n\t\t\tStreamName:    \"StreamGeneratedObjects\",\n\t\t\tHandler:       _JSONSchemaService_StreamGeneratedObjects_Handler,\n\t\t\tServerStreams: true,\n\t\t},\n\t},\n\tMetadata: \"object-generation.proto\",\n}\n","reason":"Modified","start":1,"end":172,"grade":"A-"}]},"hash":"43e73f3ff0c6e91902d3a9de8ab36b07bac563e355698998451e402ee9d1a655","id":"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"}
{"assessingTool":"SOLID","filePath":"grpc/object-generation.pb.go","grade":"A","username":"HLamb","timestamp":"2025-10-12T17:10:10.122Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"dependencyInversionScore":"A+","interfaceSegregationScore":"A-","liskovSubstitutionScore":"A+","openClosedScore":"A+","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"// Code generated by protoc-gen-go. DO NOT EDIT.\n// versions:\n// \tprotoc-gen-go v1.34.2\n// \tprotoc        v3.20.3\n// source: object-generation.proto\n\npackage grpc\n\nimport (\n\tprotoreflect \"google.golang.org/protobuf/reflect/protoreflect\"\n\tprotoimpl \"google.golang.org/protobuf/runtime/protoimpl\"\n\t_ \"google.golang.org/protobuf/types/known/anypb\"\n\tstructpb \"google.golang.org/protobuf/types/known/structpb\"\n\treflect \"reflect\"\n\tsync \"sync\"\n)\n\nconst (\n\t// Verify that this generated code is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)\n\t// Verify that runtime/protoimpl is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)\n)\n\n// Definition message\ntype Definition struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tType               string                 `protobuf:\"bytes,1,opt,name=type,proto3\" json:\"type,omitempty\"`                                                                                                     // Corresponds to Go's DataType field (as a string)\n\tInstruction        string                 `protobuf:\"bytes,2,opt,name=instruction,proto3\" json:\"instruction,omitempty\"`                                                                                       // Corresponds to Go's Instruction field\n\tProperties         map[string]*Definition `protobuf:\"bytes,3,rep,name=properties,proto3\" json:\"properties,omitempty\" protobuf_key:\"bytes,1,opt,name=key,proto3\" protobuf_val:\"bytes,2,opt,name=value,proto3\"` // Corresponds to Go's Properties field\n\tItems              *Definition            `protobuf:\"bytes,4,opt,name=items,proto3\" json:\"items,omitempty\"`                                                                                                   // Corresponds to Go's Items field\n\tModel              string                 `protobuf:\"bytes,5,opt,name=model,proto3\" json:\"model,omitempty\"`                                                                                                   // Corresponds to Go's ModelType field (as a string)\n\tProcessingOrder    []string               `protobuf:\"bytes,6,rep,name=processingOrder,proto3\" json:\"processingOrder,omitempty\"`                                                                               // Corresponds to Go's ProcessingOrder field\n\tSystemPrompt       string                 `protobuf:\"bytes,7,opt,name=systemPrompt,proto3\" json:\"systemPrompt,omitempty\"`                                                                                     // Corresponds to Go's SystemPrompt field\n\tReq                *RequestFormat         `protobuf:\"bytes,8,opt,name=req,proto3\" json:\"req,omitempty\"`                                                                                                       // Corresponds to Go's Req field\n\tNarrowFocus        *Focus                 `protobuf:\"bytes,9,opt,name=narrowFocus,proto3\" json:\"narrowFocus,omitempty\"`                                                                                       // Corresponds to Go's NarrowFocus field\n\tImprovementProcess bool                   `protobuf:\"varint,10,opt,name=improvementProcess,proto3\" json:\"improvementProcess,omitempty\"`                                                                       // Corresponds to Go's ImprovementProcess field\n\tSelectFields       []string               `protobuf:\"bytes,11,rep,name=selectFields,proto3\" json:\"selectFields,omitempty\"`                                                                                    // Corresponds to Go's SelectFields field\n\tChoices            *Choices               `protobuf:\"bytes,12,opt,name=choices,proto3\" json:\"choices,omitempty\"`                                                                                              // Corresponds to Go's Choices field\n\tVoters             bool                   `protobuf:\"varint,13,opt,name=voters,proto3\" json:\"voters,omitempty\"`                                                                                               // Corresponds to Go's Voters field\n\tHashMap            *HashMap               `protobuf:\"bytes,14,opt,name=hashMap,proto3\" json:\"hashMap,omitempty\"`                                                                                              // Corresponds to Go's HashMap field\n\tTextToSpeech       *TextToSpeech          `protobuf:\"bytes,15,opt,name=textToSpeech,proto3\" json:\"textToSpeech,omitempty\"`                                                                                    // Corresponds to Go's Audio field\n\tSpeechToText       *SpeechToText          `protobuf:\"bytes,16,opt,name=speechToText,proto3\" json:\"speechToText,omitempty\"`                                                                                    // Corresponds to Go's Speech field\n\tImage              *Image                 `protobuf:\"bytes,17,opt,name=image,proto3\" json:\"image,omitempty\"`                                                                                                  // Corresponds to Go's Image field\n\tSendImage          *SendImage             `protobuf:\"bytes,18,opt,name=sendImage,proto3\" json:\"sendImage,omitempty\"`                                                                                          // Corresponds to Go's SendImage field\n\tStream             bool                   `protobuf:\"varint,19,opt,name=stream,proto3\" json:\"stream,omitempty\"`\n}\n\nfunc (x *Definition) Reset() {\n\t*x = Definition{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[0]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *Definition) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*Definition) ProtoMessage() {}\n\nfunc (x *Definition) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[0]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use Definition.ProtoReflect.Descriptor instead.\nfunc (*Definition) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{0}\n}\n\nfunc (x *Definition) GetType() string {\n\tif x != nil {\n\t\treturn x.Type\n\t}\n\treturn \"\"\n}\n\nfunc (x *Definition) GetInstruction() string {\n\tif x != nil {\n\t\treturn x.Instruction\n\t}\n\treturn \"\"\n}\n\nfunc (x *Definition) GetProperties() map[string]*Definition {\n\tif x != nil {\n\t\treturn x.Properties\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetItems() *Definition {\n\tif x != nil {\n\t\treturn x.Items\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetModel() string {\n\tif x != nil {\n\t\treturn x.Model\n\t}\n\treturn \"\"\n}\n\nfunc (x *Definition) GetProcessingOrder() []string {\n\tif x != nil {\n\t\treturn x.ProcessingOrder\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetSystemPrompt() string {\n\tif x != nil {\n\t\treturn x.SystemPrompt\n\t}\n\treturn \"\"\n}\n\nfunc (x *Definition) GetReq() *RequestFormat {\n\tif x != nil {\n\t\treturn x.Req\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetNarrowFocus() *Focus {\n\tif x != nil {\n\t\treturn x.NarrowFocus\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetImprovementProcess() bool {\n\tif x != nil {\n\t\treturn x.ImprovementProcess\n\t}\n\treturn false\n}\n\nfunc (x *Definition) GetSelectFields() []string {\n\tif x != nil {\n\t\treturn x.SelectFields\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetChoices() *Choices {\n\tif x != nil {\n\t\treturn x.Choices\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetVoters() bool {\n\tif x != nil {\n\t\treturn x.Voters\n\t}\n\treturn false\n}\n\nfunc (x *Definition) GetHashMap() *HashMap {\n\tif x != nil {\n\t\treturn x.HashMap\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetTextToSpeech() *TextToSpeech {\n\tif x != nil {\n\t\treturn x.TextToSpeech\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetSpeechToText() *SpeechToText {\n\tif x != nil {\n\t\treturn x.SpeechToText\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetImage() *Image {\n\tif x != nil {\n\t\treturn x.Image\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetSendImage() *SendImage {\n\tif x != nil {\n\t\treturn x.SendImage\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetStream() bool {\n\tif x != nil {\n\t\treturn x.Stream\n\t}\n\treturn false\n}\n\n// Audio message\ntype TextToSpeech struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tModel         string `protobuf:\"bytes,1,opt,name=model,proto3\" json:\"model,omitempty\"`                 // Corresponds to Go's TextToSpeechModel field\n\tStringToAudio string `protobuf:\"bytes,2,opt,name=stringToAudio,proto3\" json:\"stringToAudio,omitempty\"` // Corresponds to Go's StringToAudio field\n\tFormat        string `protobuf:\"bytes,3,opt,name=format,proto3\" json:\"format,omitempty\"`               // Corresponds to Go's Format field\n\tVoice         string `protobuf:\"bytes,4,opt,name=voice,proto3\" json:\"voice,omitempty\"`                 // Corresponds to Go's Voice field\n}\n\nfunc (x *TextToSpeech) Reset() {\n\t*x = TextToSpeech{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[1]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *TextToSpeech) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*TextToSpeech) ProtoMessage() {}\n\nfunc (x *TextToSpeech) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[1]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use TextToSpeech.ProtoReflect.Descriptor instead.\nfunc (*TextToSpeech) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{1}\n}\n\nfunc (x *TextToSpeech) GetModel() string {\n\tif x != nil {\n\t\treturn x.Model\n\t}\n\treturn \"\"\n}\n\nfunc (x *TextToSpeech) GetStringToAudio() string {\n\tif x != nil {\n\t\treturn x.StringToAudio\n\t}\n\treturn \"\"\n}\n\nfunc (x *TextToSpeech) GetFormat() string {\n\tif x != nil {\n\t\treturn x.Format\n\t}\n\treturn \"\"\n}\n\nfunc (x *TextToSpeech) GetVoice() string {\n\tif x != nil {\n\t\treturn x.Voice\n\t}\n\treturn \"\"\n}\n\n// SpeechToText message\ntype SpeechToText struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tModel             string `protobuf:\"bytes,1,opt,name=model,proto3\" json:\"model,omitempty\"`                         // Corresponds to Go's SpeechToTextModel field\n\tAudioToTranscribe []byte `protobuf:\"bytes,2,opt,name=audioToTranscribe,proto3\" json:\"audioToTranscribe,omitempty\"` // Corresponds to Go's AudioToTranscribe field\n\tLanguage          string `protobuf:\"bytes,3,opt,name=language,proto3\" json:\"language,omitempty\"`                   // Corresponds to Go's Language field\n\tFormat            string `protobuf:\"bytes,4,opt,name=format,proto3\" json:\"format,omitempty\"`                       // Corresponds to Go's Format field\n\tToString          bool   `protobuf:\"varint,5,opt,name=toString,proto3\" json:\"toString,omitempty\"`                  // Corresponds to Go's ToString field\n\tToCaptions        bool   `protobuf:\"varint,6,opt,name=toCaptions,proto3\" json:\"toCaptions,omitempty\"`              // Corresponds to Go's ToCaptions field\n}\n\nfunc (x *SpeechToText) Reset() {\n\t*x = SpeechToText{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[2]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SpeechToText) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SpeechToText) ProtoMessage() {}\n\nfunc (x *SpeechToText) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[2]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SpeechToText.ProtoReflect.Descriptor instead.\nfunc (*SpeechToText) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{2}\n}\n\nfunc (x *SpeechToText) GetModel() string {\n\tif x != nil {\n\t\treturn x.Model\n\t}\n\treturn \"\"\n}\n\nfunc (x *SpeechToText) GetAudioToTranscribe() []byte {\n\tif x != nil {\n\t\treturn x.AudioToTranscribe\n\t}\n\treturn nil\n}\n\nfunc (x *SpeechToText) GetLanguage() string {\n\tif x != nil {\n\t\treturn x.Language\n\t}\n\treturn \"\"\n}\n\nfunc (x *SpeechToText) GetFormat() string {\n\tif x != nil {\n\t\treturn x.Format\n\t}\n\treturn \"\"\n}\n\nfunc (x *SpeechToText) GetToString() bool {\n\tif x != nil {\n\t\treturn x.ToString\n\t}\n\treturn false\n}\n\nfunc (x *SpeechToText) GetToCaptions() bool {\n\tif x != nil {\n\t\treturn x.ToCaptions\n\t}\n\treturn false\n}\n\n// Image message\ntype Image struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tModel string `protobuf:\"bytes,1,opt,name=model,proto3\" json:\"model,omitempty\"` // Corresponds to Go's ImageModel field\n\tSize  string `protobuf:\"bytes,2,opt,name=size,proto3\" json:\"size,omitempty\"`   // Corresponds to Go's ImageSize field\n}\n\nfunc (x *Image) Reset() {\n\t*x = Image{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[3]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *Image) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*Image) ProtoMessage() {}\n\nfunc (x *Image) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[3]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use Image.ProtoReflect.Descriptor instead.\nfunc (*Image) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{3}\n}\n\nfunc (x *Image) GetModel() string {\n\tif x != nil {\n\t\treturn x.Model\n\t}\n\treturn \"\"\n}\n\nfunc (x *Image) GetSize() string {\n\tif x != nil {\n\t\treturn x.Size\n\t}\n\treturn \"\"\n}\n\n// Choices message\ntype Choices struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tNumber  int32    `protobuf:\"varint,1,opt,name=number,proto3\" json:\"number,omitempty\"`  // Corresponds to Go's Number field\n\tOptions []string `protobuf:\"bytes,2,rep,name=options,proto3\" json:\"options,omitempty\"` // Corresponds to Go's Options field\n}\n\nfunc (x *Choices) Reset() {\n\t*x = Choices{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[4]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *Choices) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*Choices) ProtoMessage() {}\n\nfunc (x *Choices) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[4]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use Choices.ProtoReflect.Descriptor instead.\nfunc (*Choices) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{4}\n}\n\nfunc (x *Choices) GetNumber() int32 {\n\tif x != nil {\n\t\treturn x.Number\n\t}\n\treturn 0\n}\n\nfunc (x *Choices) GetOptions() []string {\n\tif x != nil {\n\t\treturn x.Options\n\t}\n\treturn nil\n}\n\n// HashMap message\ntype HashMap struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tKeyInstruction  string      `protobuf:\"bytes,1,opt,name=keyInstruction,proto3\" json:\"keyInstruction,omitempty\"`   // Corresponds to Go's KeyInstruction field\n\tFieldDefinition *Definition `protobuf:\"bytes,2,opt,name=fieldDefinition,proto3\" json:\"fieldDefinition,omitempty\"` // Corresponds to Go's FieldDefinition field\n}\n\nfunc (x *HashMap) Reset() {\n\t*x = HashMap{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[5]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *HashMap) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*HashMap) ProtoMessage() {}\n\nfunc (x *HashMap) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[5]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use HashMap.ProtoReflect.Descriptor instead.\nfunc (*HashMap) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{5}\n}\n\nfunc (x *HashMap) GetKeyInstruction() string {\n\tif x != nil {\n\t\treturn x.KeyInstruction\n\t}\n\treturn \"\"\n}\n\nfunc (x *HashMap) GetFieldDefinition() *Definition {\n\tif x != nil {\n\t\treturn x.FieldDefinition\n\t}\n\treturn nil\n}\n\n// Focus message\ntype Focus struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tPrompt       string   `protobuf:\"bytes,1,opt,name=prompt,proto3\" json:\"prompt,omitempty\"`              // Corresponds to Go's Prompt field\n\tFields       []string `protobuf:\"bytes,2,rep,name=fields,proto3\" json:\"fields,omitempty\"`              // Corresponds to Go's Fields field\n\tKeepOriginal bool     `protobuf:\"varint,3,opt,name=keepOriginal,proto3\" json:\"keepOriginal,omitempty\"` // Corresponds to Go's KeepOriginal field\n}\n\nfunc (x *Focus) Reset() {\n\t*x = Focus{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[6]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *Focus) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*Focus) ProtoMessage() {}\n\nfunc (x *Focus) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[6]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use Focus.ProtoReflect.Descriptor instead.\nfunc (*Focus) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{6}\n}\n\nfunc (x *Focus) GetPrompt() string {\n\tif x != nil {\n\t\treturn x.Prompt\n\t}\n\treturn \"\"\n}\n\nfunc (x *Focus) GetFields() []string {\n\tif x != nil {\n\t\treturn x.Fields\n\t}\n\treturn nil\n}\n\nfunc (x *Focus) GetKeepOriginal() bool {\n\tif x != nil {\n\t\treturn x.KeepOriginal\n\t}\n\treturn false\n}\n\n// SendImage message\ntype SendImage struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tImagesData [][]byte `protobuf:\"bytes,1,rep,name=imagesData,proto3\" json:\"imagesData,omitempty\"`\n}\n\nfunc (x *SendImage) Reset() {\n\t*x = SendImage{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[7]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SendImage) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SendImage) ProtoMessage() {}\n\nfunc (x *SendImage) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[7]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SendImage.ProtoReflect.Descriptor instead.\nfunc (*SendImage) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{7}\n}\n\nfunc (x *SendImage) GetImagesData() [][]byte {\n\tif x != nil {\n\t\treturn x.ImagesData\n\t}\n\treturn nil\n}\n\n// RequestFormat message\ntype RequestFormat struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tUrl           string            `protobuf:\"bytes,1,opt,name=url,proto3\" json:\"url,omitempty\"`\n\tMethod        string            `protobuf:\"bytes,2,opt,name=method,proto3\" json:\"method,omitempty\"`\n\tHeaders       map[string]string `protobuf:\"bytes,3,rep,name=headers,proto3\" json:\"headers,omitempty\" protobuf_key:\"bytes,1,opt,name=key,proto3\" protobuf_val:\"bytes,2,opt,name=value,proto3\"`\n\tBody          *structpb.Struct  `protobuf:\"bytes,4,opt,name=body,proto3\" json:\"body,omitempty\"` // This corresponds to Go's Body field as map[string]interface{}\n\tAuthorization string            `protobuf:\"bytes,5,opt,name=authorization,proto3\" json:\"authorization,omitempty\"`\n\tRequireFields []string          `protobuf:\"bytes,6,rep,name=requireFields,proto3\" json:\"requireFields,omitempty\"`\n}\n\nfunc (x *RequestFormat) Reset() {\n\t*x = RequestFormat{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[8]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *RequestFormat) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*RequestFormat) ProtoMessage() {}\n\nfunc (x *RequestFormat) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[8]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use RequestFormat.ProtoReflect.Descriptor instead.\nfunc (*RequestFormat) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{8}\n}\n\nfunc (x *RequestFormat) GetUrl() string {\n\tif x != nil {\n\t\treturn x.Url\n\t}\n\treturn \"\"\n}\n\nfunc (x *RequestFormat) GetMethod() string {\n\tif x != nil {\n\t\treturn x.Method\n\t}\n\treturn \"\"\n}\n\nfunc (x *RequestFormat) GetHeaders() map[string]string {\n\tif x != nil {\n\t\treturn x.Headers\n\t}\n\treturn nil\n}\n\nfunc (x *RequestFormat) GetBody() *structpb.Struct {\n\tif x != nil {\n\t\treturn x.Body\n\t}\n\treturn nil\n}\n\nfunc (x *RequestFormat) GetAuthorization() string {\n\tif x != nil {\n\t\treturn x.Authorization\n\t}\n\treturn \"\"\n}\n\nfunc (x *RequestFormat) GetRequireFields() []string {\n\tif x != nil {\n\t\treturn x.RequireFields\n\t}\n\treturn nil\n}\n\n// RequestBody message for the GenerateObject RPC\ntype RequestBody struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tPrompt     string      `protobuf:\"bytes,1,opt,name=prompt,proto3\" json:\"prompt,omitempty\"`         // Corresponds to Go's Prompt field\n\tDefinition *Definition `protobuf:\"bytes,2,opt,name=definition,proto3\" json:\"definition,omitempty\"` // Corresponds to Go's Definition field\n}\n\nfunc (x *RequestBody) Reset() {\n\t*x = RequestBody{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[9]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *RequestBody) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*RequestBody) ProtoMessage() {}\n\nfunc (x *RequestBody) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[9]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use RequestBody.ProtoReflect.Descriptor instead.\nfunc (*RequestBody) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{9}\n}\n\nfunc (x *RequestBody) GetPrompt() string {\n\tif x != nil {\n\t\treturn x.Prompt\n\t}\n\treturn \"\"\n}\n\nfunc (x *RequestBody) GetDefinition() *Definition {\n\tif x != nil {\n\t\treturn x.Definition\n\t}\n\treturn nil\n}\n\n// Updated Response message for the GenerateObject RPC\ntype Response struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tData    *structpb.Struct `protobuf:\"bytes,1,opt,name=data,proto3\" json:\"data,omitempty\"` // Use Struct to hold a dynamic map<string, any>\n\tUsdCost float64          `protobuf:\"fixed64,2,opt,name=usdCost,proto3\" json:\"usdCost,omitempty\"`\n}\n\nfunc (x *Response) Reset() {\n\t*x = Response{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[10]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *Response) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*Response) ProtoMessage() {}\n\nfunc (x *Response) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[10]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use Response.ProtoReflect.Descriptor instead.\nfunc (*Response) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{10}\n}\n\nfunc (x *Response) GetData() *structpb.Struct {\n\tif x != nil {\n\t\treturn x.Data\n\t}\n\treturn nil\n}\n\nfunc (x *Response) GetUsdCost() float64 {\n\tif x != nil {\n\t\treturn x.UsdCost\n\t}\n\treturn 0\n}\n\n// StreamingResponse message for the stream method\ntype StreamingResponse struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tData    *structpb.Struct `protobuf:\"bytes,1,opt,name=data,proto3\" json:\"data,omitempty\"` // Same as above, using Struct for map<string, any>\n\tUsdCost float64          `protobuf:\"fixed64,2,opt,name=usdCost,proto3\" json:\"usdCost,omitempty\"`\n\tStatus  string           `protobuf:\"bytes,3,opt,name=status,proto3\" json:\"status,omitempty\"` // A status message for each streamed response\n}\n\nfunc (x *StreamingResponse) Reset() {\n\t*x = StreamingResponse{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[11]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *StreamingResponse) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*StreamingResponse) ProtoMessage() {}\n\nfunc (x *StreamingResponse) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[11]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use StreamingResponse.ProtoReflect.Descriptor instead.\nfunc (*StreamingResponse) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{11}\n}\n\nfunc (x *StreamingResponse) GetData() *structpb.Struct {\n\tif x != nil {\n\t\treturn x.Data\n\t}\n\treturn nil\n}\n\nfunc (x *StreamingResponse) GetUsdCost() float64 {\n\tif x != nil {\n\t\treturn x.UsdCost\n\t}\n\treturn 0\n}\n\nfunc (x *StreamingResponse) GetStatus() string {\n\tif x != nil {\n\t\treturn x.Status\n\t}\n\treturn \"\"\n}\n\nvar File_object_generation_proto protoreflect.FileDescriptor\n\nvar file_object_generation_proto_rawDesc = []byte{\n\t0x0a, 0x17, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x2d, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74,\n\t0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x6a, 0x73, 0x6f, 0x6e, 0x53,\n\t0x63, 0x68, 0x65, 0x6d, 0x61, 0x1a, 0x19, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72,\n\t0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x61, 0x6e, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,\n\t0x1a, 0x1c, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,\n\t0x66, 0x2f, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x91,\n\t0x07, 0x0a, 0x0a, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a,\n\t0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x79, 0x70,\n\t0x65, 0x12, 0x20, 0x0a, 0x0b, 0x69, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e,\n\t0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x69, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74,\n\t0x69, 0x6f, 0x6e, 0x12, 0x46, 0x0a, 0x0a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65,\n\t0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63,\n\t0x68, 0x65, 0x6d, 0x61, 0x2e, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e,\n\t0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52,\n\t0x0a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x12, 0x2c, 0x0a, 0x05, 0x69,\n\t0x74, 0x65, 0x6d, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6a, 0x73, 0x6f,\n\t0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69,\n\t0x6f, 0x6e, 0x52, 0x05, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x6d, 0x6f, 0x64,\n\t0x65, 0x6c, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x12,\n\t0x28, 0x0a, 0x0f, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x69, 0x6e, 0x67, 0x4f, 0x72, 0x64,\n\t0x65, 0x72, 0x18, 0x06, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0f, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73,\n\t0x73, 0x69, 0x6e, 0x67, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x12, 0x22, 0x0a, 0x0c, 0x73, 0x79, 0x73,\n\t0x74, 0x65, 0x6d, 0x50, 0x72, 0x6f, 0x6d, 0x70, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52,\n\t0x0c, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x50, 0x72, 0x6f, 0x6d, 0x70, 0x74, 0x12, 0x2b, 0x0a,\n\t0x03, 0x72, 0x65, 0x71, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x6a, 0x73, 0x6f,\n\t0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x46,\n\t0x6f, 0x72, 0x6d, 0x61, 0x74, 0x52, 0x03, 0x72, 0x65, 0x71, 0x12, 0x33, 0x0a, 0x0b, 0x6e, 0x61,\n\t0x72, 0x72, 0x6f, 0x77, 0x46, 0x6f, 0x63, 0x75, 0x73, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32,\n\t0x11, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x46, 0x6f, 0x63,\n\t0x75, 0x73, 0x52, 0x0b, 0x6e, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x46, 0x6f, 0x63, 0x75, 0x73, 0x12,\n\t0x2e, 0x0a, 0x12, 0x69, 0x6d, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72,\n\t0x6f, 0x63, 0x65, 0x73, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x12, 0x69, 0x6d, 0x70,\n\t0x72, 0x6f, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x12,\n\t0x22, 0x0a, 0x0c, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x18,\n\t0x0b, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x46, 0x69, 0x65,\n\t0x6c, 0x64, 0x73, 0x12, 0x2d, 0x0a, 0x07, 0x63, 0x68, 0x6f, 0x69, 0x63, 0x65, 0x73, 0x18, 0x0c,\n\t0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d,\n\t0x61, 0x2e, 0x43, 0x68, 0x6f, 0x69, 0x63, 0x65, 0x73, 0x52, 0x07, 0x63, 0x68, 0x6f, 0x69, 0x63,\n\t0x65, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x76, 0x6f, 0x74, 0x65, 0x72, 0x73, 0x18, 0x0d, 0x20, 0x01,\n\t0x28, 0x08, 0x52, 0x06, 0x76, 0x6f, 0x74, 0x65, 0x72, 0x73, 0x12, 0x2d, 0x0a, 0x07, 0x68, 0x61,\n\t0x73, 0x68, 0x4d, 0x61, 0x70, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x6a, 0x73,\n\t0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x48, 0x61, 0x73, 0x68, 0x4d, 0x61, 0x70,\n\t0x52, 0x07, 0x68, 0x61, 0x73, 0x68, 0x4d, 0x61, 0x70, 0x12, 0x3c, 0x0a, 0x0c, 0x74, 0x65, 0x78,\n\t0x74, 0x54, 0x6f, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0b, 0x32,\n\t0x18, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x54, 0x65, 0x78,\n\t0x74, 0x54, 0x6f, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x52, 0x0c, 0x74, 0x65, 0x78, 0x74, 0x54,\n\t0x6f, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x12, 0x3c, 0x0a, 0x0c, 0x73, 0x70, 0x65, 0x65, 0x63,\n\t0x68, 0x54, 0x6f, 0x54, 0x65, 0x78, 0x74, 0x18, 0x10, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e,\n\t0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x53, 0x70, 0x65, 0x65, 0x63,\n\t0x68, 0x54, 0x6f, 0x54, 0x65, 0x78, 0x74, 0x52, 0x0c, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x54,\n\t0x6f, 0x54, 0x65, 0x78, 0x74, 0x12, 0x27, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x11,\n\t0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d,\n\t0x61, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x33,\n\t0x0a, 0x09, 0x73, 0x65, 0x6e, 0x64, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x12, 0x20, 0x01, 0x28,\n\t0x0b, 0x32, 0x15, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x53,\n\t0x65, 0x6e, 0x64, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x09, 0x73, 0x65, 0x6e, 0x64, 0x49, 0x6d,\n\t0x61, 0x67, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x18, 0x13, 0x20,\n\t0x01, 0x28, 0x08, 0x52, 0x06, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x1a, 0x55, 0x0a, 0x0f, 0x50,\n\t0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10,\n\t0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,\n\t0x12, 0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,\n\t0x16, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x44, 0x65, 0x66,\n\t0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02,\n\t0x38, 0x01, 0x22, 0x78, 0x0a, 0x0c, 0x54, 0x65, 0x78, 0x74, 0x54, 0x6f, 0x53, 0x70, 0x65, 0x65,\n\t0x63, 0x68, 0x12, 0x14, 0x0a, 0x05, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28,\n\t0x09, 0x52, 0x05, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x12, 0x24, 0x0a, 0x0d, 0x73, 0x74, 0x72, 0x69,\n\t0x6e, 0x67, 0x54, 0x6f, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,\n\t0x0d, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x54, 0x6f, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x12, 0x16,\n\t0x0a, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06,\n\t0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x6f, 0x69, 0x63, 0x65, 0x18,\n\t0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x6f, 0x69, 0x63, 0x65, 0x22, 0xc2, 0x01, 0x0a,\n\t0x0c, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x54, 0x6f, 0x54, 0x65, 0x78, 0x74, 0x12, 0x14, 0x0a,\n\t0x05, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6d, 0x6f,\n\t0x64, 0x65, 0x6c, 0x12, 0x2c, 0x0a, 0x11, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x54, 0x6f, 0x54, 0x72,\n\t0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x11,\n\t0x61, 0x75, 0x64, 0x69, 0x6f, 0x54, 0x6f, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x62,\n\t0x65, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x18, 0x03, 0x20,\n\t0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x12, 0x16, 0x0a,\n\t0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x66,\n\t0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x74, 0x6f, 0x53, 0x74, 0x72, 0x69, 0x6e,\n\t0x67, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x74, 0x6f, 0x53, 0x74, 0x72, 0x69, 0x6e,\n\t0x67, 0x12, 0x1e, 0x0a, 0x0a, 0x74, 0x6f, 0x43, 0x61, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18,\n\t0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x74, 0x6f, 0x43, 0x61, 0x70, 0x74, 0x69, 0x6f, 0x6e,\n\t0x73, 0x22, 0x31, 0x0a, 0x05, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x6d, 0x6f,\n\t0x64, 0x65, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6d, 0x6f, 0x64, 0x65, 0x6c,\n\t0x12, 0x12, 0x0a, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,\n\t0x73, 0x69, 0x7a, 0x65, 0x22, 0x3b, 0x0a, 0x07, 0x43, 0x68, 0x6f, 0x69, 0x63, 0x65, 0x73, 0x12,\n\t0x16, 0x0a, 0x06, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52,\n\t0x06, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x12, 0x18, 0x0a, 0x07, 0x6f, 0x70, 0x74, 0x69, 0x6f,\n\t0x6e, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e,\n\t0x73, 0x22, 0x73, 0x0a, 0x07, 0x48, 0x61, 0x73, 0x68, 0x4d, 0x61, 0x70, 0x12, 0x26, 0x0a, 0x0e,\n\t0x6b, 0x65, 0x79, 0x49, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01,\n\t0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x6b, 0x65, 0x79, 0x49, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63,\n\t0x74, 0x69, 0x6f, 0x6e, 0x12, 0x40, 0x0a, 0x0f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x44, 0x65, 0x66,\n\t0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e,\n\t0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x44, 0x65, 0x66, 0x69, 0x6e,\n\t0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x44, 0x65, 0x66, 0x69,\n\t0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x5b, 0x0a, 0x05, 0x46, 0x6f, 0x63, 0x75, 0x73, 0x12,\n\t0x16, 0x0a, 0x06, 0x70, 0x72, 0x6f, 0x6d, 0x70, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,\n\t0x06, 0x70, 0x72, 0x6f, 0x6d, 0x70, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x69, 0x65, 0x6c, 0x64,\n\t0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x06, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x12,\n\t0x22, 0x0a, 0x0c, 0x6b, 0x65, 0x65, 0x70, 0x4f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x18,\n\t0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x6b, 0x65, 0x65, 0x70, 0x4f, 0x72, 0x69, 0x67, 0x69,\n\t0x6e, 0x61, 0x6c, 0x22, 0x2b, 0x0a, 0x09, 0x53, 0x65, 0x6e, 0x64, 0x49, 0x6d, 0x61, 0x67, 0x65,\n\t0x12, 0x1e, 0x0a, 0x0a, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x73, 0x44, 0x61, 0x74, 0x61, 0x18, 0x01,\n\t0x20, 0x03, 0x28, 0x0c, 0x52, 0x0a, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x73, 0x44, 0x61, 0x74, 0x61,\n\t0x22, 0xb0, 0x02, 0x0a, 0x0d, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x46, 0x6f, 0x72, 0x6d,\n\t0x61, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,\n\t0x03, 0x75, 0x72, 0x6c, 0x12, 0x16, 0x0a, 0x06, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x18, 0x02,\n\t0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x12, 0x40, 0x0a, 0x07,\n\t0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e,\n\t0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x65,\n\t0x73, 0x74, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x2e, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73,\n\t0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x07, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x12, 0x2b,\n\t0x0a, 0x04, 0x62, 0x6f, 0x64, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x67,\n\t0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53,\n\t0x74, 0x72, 0x75, 0x63, 0x74, 0x52, 0x04, 0x62, 0x6f, 0x64, 0x79, 0x12, 0x24, 0x0a, 0x0d, 0x61,\n\t0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01,\n\t0x28, 0x09, 0x52, 0x0d, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f,\n\t0x6e, 0x12, 0x24, 0x0a, 0x0d, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x46, 0x69, 0x65, 0x6c,\n\t0x64, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0d, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72,\n\t0x65, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x1a, 0x3a, 0x0a, 0x0c, 0x48, 0x65, 0x61, 0x64, 0x65,\n\t0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,\n\t0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c,\n\t0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a,\n\t0x02, 0x38, 0x01, 0x22, 0x5d, 0x0a, 0x0b, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x42, 0x6f,\n\t0x64, 0x79, 0x12, 0x16, 0x0a, 0x06, 0x70, 0x72, 0x6f, 0x6d, 0x70, 0x74, 0x18, 0x01, 0x20, 0x01,\n\t0x28, 0x09, 0x52, 0x06, 0x70, 0x72, 0x6f, 0x6d, 0x70, 0x74, 0x12, 0x36, 0x0a, 0x0a, 0x64, 0x65,\n\t0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16,\n\t0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x44, 0x65, 0x66, 0x69,\n\t0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0a, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69,\n\t0x6f, 0x6e, 0x22, 0x51, 0x0a, 0x08, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2b,\n\t0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x67,\n\t0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53,\n\t0x74, 0x72, 0x75, 0x63, 0x74, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x12, 0x18, 0x0a, 0x07, 0x75,\n\t0x73, 0x64, 0x43, 0x6f, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x07, 0x75, 0x73,\n\t0x64, 0x43, 0x6f, 0x73, 0x74, 0x22, 0x72, 0x0a, 0x11, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69,\n\t0x6e, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2b, 0x0a, 0x04, 0x64, 0x61,\n\t0x74, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,\n\t0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x74, 0x72, 0x75, 0x63,\n\t0x74, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x12, 0x18, 0x0a, 0x07, 0x75, 0x73, 0x64, 0x43, 0x6f,\n\t0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x07, 0x75, 0x73, 0x64, 0x43, 0x6f, 0x73,\n\t0x74, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28,\n\t0x09, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x32, 0xa8, 0x01, 0x0a, 0x11, 0x4a, 0x53,\n\t0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12,\n\t0x3f, 0x0a, 0x0e, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x4f, 0x62, 0x6a, 0x65, 0x63,\n\t0x74, 0x12, 0x17, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x52,\n\t0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x42, 0x6f, 0x64, 0x79, 0x1a, 0x14, 0x2e, 0x6a, 0x73, 0x6f,\n\t0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,\n\t0x12, 0x52, 0x0a, 0x16, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61,\n\t0x74, 0x65, 0x64, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x12, 0x17, 0x2e, 0x6a, 0x73, 0x6f,\n\t0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x42,\n\t0x6f, 0x64, 0x79, 0x1a, 0x1d, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61,\n\t0x2e, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,\n\t0x73, 0x65, 0x30, 0x01, 0x42, 0x08, 0x5a, 0x06, 0x2e, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x62, 0x06,\n\t0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,\n}\n\nvar (\n\tfile_object_generation_proto_rawDescOnce sync.Once\n\tfile_object_generation_proto_rawDescData = file_object_generation_proto_rawDesc\n)\n\nfunc file_object_generation_proto_rawDescGZIP() []byte {\n\tfile_object_generation_proto_rawDescOnce.Do(func() {\n\t\tfile_object_generation_proto_rawDescData = protoimpl.X.CompressGZIP(file_object_generation_proto_rawDescData)\n\t})\n\treturn file_object_generation_proto_rawDescData\n}\n\nvar file_object_generation_proto_msgTypes = make([]protoimpl.MessageInfo, 14)\nvar file_object_generation_proto_goTypes = []any{\n\t(*Definition)(nil),        // 0: jsonSchema.Definition\n\t(*TextToSpeech)(nil),      // 1: jsonSchema.TextToSpeech\n\t(*SpeechToText)(nil),      // 2: jsonSchema.SpeechToText\n\t(*Image)(nil),             // 3: jsonSchema.Image\n\t(*Choices)(nil),           // 4: jsonSchema.Choices\n\t(*HashMap)(nil),           // 5: jsonSchema.HashMap\n\t(*Focus)(nil),             // 6: jsonSchema.Focus\n\t(*SendImage)(nil),         // 7: jsonSchema.SendImage\n\t(*RequestFormat)(nil),     // 8: jsonSchema.RequestFormat\n\t(*RequestBody)(nil),       // 9: jsonSchema.RequestBody\n\t(*Response)(nil),          // 10: jsonSchema.Response\n\t(*StreamingResponse)(nil), // 11: jsonSchema.StreamingResponse\n\tnil,                       // 12: jsonSchema.Definition.PropertiesEntry\n\tnil,                       // 13: jsonSchema.RequestFormat.HeadersEntry\n\t(*structpb.Struct)(nil),   // 14: google.protobuf.Struct\n}\nvar file_object_generation_proto_depIdxs = []int32{\n\t12, // 0: jsonSchema.Definition.properties:type_name -> jsonSchema.Definition.PropertiesEntry\n\t0,  // 1: jsonSchema.Definition.items:type_name -> jsonSchema.Definition\n\t8,  // 2: jsonSchema.Definition.req:type_name -> jsonSchema.RequestFormat\n\t6,  // 3: jsonSchema.Definition.narrowFocus:type_name -> jsonSchema.Focus\n\t4,  // 4: jsonSchema.Definition.choices:type_name -> jsonSchema.Choices\n\t5,  // 5: jsonSchema.Definition.hashMap:type_name -> jsonSchema.HashMap\n\t1,  // 6: jsonSchema.Definition.textToSpeech:type_name -> jsonSchema.TextToSpeech\n\t2,  // 7: jsonSchema.Definition.speechToText:type_name -> jsonSchema.SpeechToText\n\t3,  // 8: jsonSchema.Definition.image:type_name -> jsonSchema.Image\n\t7,  // 9: jsonSchema.Definition.sendImage:type_name -> jsonSchema.SendImage\n\t0,  // 10: jsonSchema.HashMap.fieldDefinition:type_name -> jsonSchema.Definition\n\t13, // 11: jsonSchema.RequestFormat.headers:type_name -> jsonSchema.RequestFormat.HeadersEntry\n\t14, // 12: jsonSchema.RequestFormat.body:type_name -> google.protobuf.Struct\n\t0,  // 13: jsonSchema.RequestBody.definition:type_name -> jsonSchema.Definition\n\t14, // 14: jsonSchema.Response.data:type_name -> google.protobuf.Struct\n\t14, // 15: jsonSchema.StreamingResponse.data:type_name -> google.protobuf.Struct\n\t0,  // 16: jsonSchema.Definition.PropertiesEntry.value:type_name -> jsonSchema.Definition\n\t9,  // 17: jsonSchema.JSONSchemaService.GenerateObject:input_type -> jsonSchema.RequestBody\n\t9,  // 18: jsonSchema.JSONSchemaService.StreamGeneratedObjects:input_type -> jsonSchema.RequestBody\n\t10, // 19: jsonSchema.JSONSchemaService.GenerateObject:output_type -> jsonSchema.Response\n\t11, // 20: jsonSchema.JSONSchemaService.StreamGeneratedObjects:output_type -> jsonSchema.StreamingResponse\n\t19, // [19:21] is the sub-list for method output_type\n\t17, // [17:19] is the sub-list for method input_type\n\t17, // [17:17] is the sub-list for extension type_name\n\t17, // [17:17] is the sub-list for extension extendee\n\t0,  // [0:17] is the sub-list for field type_name\n}\n\nfunc init() { file_object_generation_proto_init() }\nfunc file_object_generation_proto_init() {\n\tif File_object_generation_proto != nil {\n\t\treturn\n\t}\n\tif !protoimpl.UnsafeEnabled {\n\t\tfile_object_generation_proto_msgTypes[0].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*Definition); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[1].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*TextToSpeech); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[2].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*SpeechToText); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[3].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*Image); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[4].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*Choices); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[5].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*HashMap); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[6].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*Focus); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[7].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*SendImage); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[8].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*RequestFormat); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[9].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*RequestBody); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[10].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*Response); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[11].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*StreamingResponse); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\ttype x struct{}\n\tout := protoimpl.TypeBuilder{\n\t\tFile: protoimpl.DescBuilder{\n\t\t\tGoPackagePath: reflect.TypeOf(x{}).PkgPath(),\n\t\t\tRawDescriptor: file_object_generation_proto_rawDesc,\n\t\t\tNumEnums:      0,\n\t\t\tNumMessages:   14,\n\t\t\tNumExtensions: 0,\n\t\t\tNumServices:   1,\n\t\t},\n\t\tGoTypes:           file_object_generation_proto_goTypes,\n\t\tDependencyIndexes: file_object_generation_proto_depIdxs,\n\t\tMessageInfos:      file_object_generation_proto_msgTypes,\n\t}.Build()\n\tFile_object_generation_proto = out.File\n\tfile_object_generation_proto_rawDesc = nil\n\tfile_object_generation_proto_goTypes = nil\n\tfile_object_generation_proto_depIdxs = nil\n}\n","reason":"Modified","start":1,"end":1311,"grade":"A"}]},"hash":"e0529a17a679f14a084e8b06b30e7c32c0c709aa5551c83e9ababa81ef8932d0","id":"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"}
{"assessingTool":"Complexity","filePath":"converison/choices.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:10:09.707Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The ConvertProtoToChoices and ConvertModelToProtoChoices functions have minimal branching, so cyclomatic complexity is not a concern in this code.\n\n```go\nif protoChoices == nil {\n\treturn nil\n}\n```","codeResolution":"The codeResolution addresses cyclomatic complexity by refactoring the conversion logic into a single, unified abstraction, reducing branching and improving maintainability. Replace the original conversion block with the following streamlined approach:\n\n```go\n// Use the Operation abstraction to handle conversion\nfunc ConvertChoices(src interface{}) interface{} {\n\top := getOperation(src)\n\treturn op.Convert(src)\n}\n```","severity":"Critical","rationale":"## Rationale\n\nThe cyclomatic complexity in this code is low, with each function containing only a single conditional branch. This simplicity enhances maintainability and testability, as there are minimal paths to cover and fewer opportunities for logic errors. By avoiding nested conditionals and keeping each function focused, the code remains easy to understand and modify. If complexity were to increase (e.g., by adding more branches or nested logic), it could lead to harder-to-maintain code and increased risk of bugs. Keeping cyclomatic complexity low is crucial for correctness and long-term maintainability.","lineStart":9,"lineEnd":22,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode does not exhibit excessive nesting, but the use of guard clauses in both conversion functions could be further streamlined for clarity.\n\n```go\nif protoChoices == nil {\n\treturn nil\n}\n```","codeResolution":"The codeResolution for nestingDepth focuses on flattening the control flow in the conversion functions by using early returns and removing unnecessary nesting.\n\n```go\n// Go\n\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\tif protoChoices == nil {\n\t\treturn nil\n\t}\n\treturn &jsonSchema.Choices{\n\t\tNumber:  int(protoChoices.Number),\n\t\tOptions: protoChoices.Options,\n\t}\n}\n\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n\tif modelChoices == nil {\n\t\treturn nil\n\t}\n\treturn &pb.Choices{\n\t\tNumber:  int32(modelChoices.Number),\n\t\tOptions: modelChoices.Options,\n\t}\n}\n```","severity":"Critical","rationale":"### Rationale\n\nThe code adheres well to nesting depth principles, maintaining a maximum depth of 2 (function scope and a single 'if' statement per function). This flat structure improves readability and maintainability, making it easy to follow the logic and reducing the risk of errors introduced by deeply nested conditions. Shallow nesting also facilitates unit testing and future modifications, as each function’s logic is clear and isolated. No excessive nesting is present, so performance and correctness are not negatively impacted.","lineStart":9,"lineEnd":18,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode only defines two functions, failing to separate responsibilities and limiting extensibility.\n\n```go\n// ConvertProtoToChoices converts a protobuf Choices to the Go model Choices\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\n// ConvertModelToProtoChoices converts a Go model Choices to a protobuf Choices\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n```","codeResolution":"The conversion logic should be refactored to delegate the transformation to dedicated helper functions, improving separation of concerns and maintainability.\n\n```go\n// Go\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\treturn convertProtoChoicesToModel(protoChoices)\n}\n\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n\treturn convertModelChoicesToProto(modelChoices)\n}\n```","severity":"Critical","rationale":"The code defines only two functions, each handling a distinct conversion between types. While this meets basic separation of concerns, it lacks extensibility and fails to anticipate future changes or additional conversion logic. If either function grows in complexity, the absence of further decomposition will hinder maintainability and testability. For example, validation or error handling is not modularized, so any new requirements would bloat these functions. Increasing the function count by extracting responsibilities (e.g., option validation) would improve clarity and scalability.","lineStart":5,"lineEnd":22,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode unnecessarily duplicates logic across two functions, inflating the linesOfCode count without abstraction.\n\n```go\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\tif protoChoices == nil {\n\t\treturn nil\n\t}\n\n\treturn &jsonSchema.Choices{\n\t\tNumber:  int(protoChoices.Number),\n\t\tOptions: protoChoices.Options,\n\t}\n}\n```","codeResolution":"The codeResolution for linesOfCode focuses on reducing redundancy and improving maintainability by abstracting the conversion logic into a reusable function. This approach streamlines the code and minimizes repetition.\n\n```go\n// Use a generic convertChoices function for both conversions\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\treturn convertChoices(protoChoices)\n}\n\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n\treturn convertChoices(modelChoices)\n}\n```","severity":"Critical","rationale":"The code snippet adheres well to linesOfCode principles, with concise, single-responsibility functions and minimal logic per function. This brevity improves maintainability, making it easier to review and update each conversion function. For example, both `ConvertProtoToChoices` and `ConvertModelToProtoChoices` are under 10 lines, reducing cognitive load and the risk of introducing errors. Keeping LoC low also enhances testability and performance, as there is less code to execute and fewer branches to cover. However, if additional validation or error handling is needed, care should be taken not to bloat these functions, preserving their clarity and maintainability.","lineStart":6,"lineEnd":22,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code violates dependenciesModules principles by tightly coupling the conversion logic to specific external packages, reducing flexibility and maintainability.\n\n```go\nimport (\n\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n)\n```","codeResolution":"The codeResolution for dependenciesModules demonstrates a clean approach by directly mapping between protobuf and Go model types without introducing unnecessary dependencies. Here is the replacement code for the identified block, assuming all required abstractions are defined elsewhere:\n\n```go\n// Use the generic conversion operation abstraction\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\treturn getOperation(\"ProtoToModelChoices\").Convert(protoChoices)\n}\n\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n\treturn getOperation(\"ModelToProtoChoices\").Convert(modelChoices)\n}\n```","severity":"Critical","rationale":"The code imports two external packages: `pb \"github.com/objectweaver/go-sdk/grpc\"` and `\"github.com/objectweaver/go-sdk/jsonSchema\"`. This is appropriate for the conversion logic, as both types are needed. However, tightly coupling the conversion functions to these specific packages can hinder maintainability if the underlying libraries change or if you want to swap implementations. Using interfaces or abstraction layers could reduce dependency rigidity and make future refactoring easier. Over-reliance on external packages also increases the risk of breaking changes and complicates testing, as mocks or stubs may be needed for both dependencies.","lineStart":3,"lineEnd":5,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A+","readability":"A+","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":2,"functionMethodCounts":2,"linesOfCode":31,"nestingDepth":2}},"hash":"85843e8a10d90b82568eddc81e7c0d31aee323d542caae20b362041f7c9551ce","id":"eJyVkzFPwzAQhf/KyQNqqjSRYIvElIEJqERHL4nrJKaxz7IvCFT1vyO3SVuTIsRmv7t7fvdJ3rPKe+m9Mu0GsWcFK1HbXn4q+mIpE7iVJRqShljBbCV2VStBoPmQTnk03HCjtEVHsOCGk62Bs1ZRN9SZQJ03yknRKW1X6Nq8xZXf7vLWWcFZaP+7992jeROd1FWYSMJ7eQ7lMQCtHRJusOxQCenHWOShAhsq9dDAVCME6iQ8IWjcyn7SuWkGI277LY4mk8HS1tl4TmB5iTWJsA8LqQaiqcdHMKo/1Tg5SYMzQQn3Q1jmLN7NLcepl0HX0hUAylCUKTtVkvTU92pJofFFlCAb1XR88RATfA4wNri+znyF8SeugHEON4Z4w3JxNDmTnG+aXOM9k4ym/kHyYnWD4MN9lOY3hlHPnCFLWaN6ua6oYwW7/IdcjCMtssM33io/cw=="}
{"assessingTool":"SOLID","filePath":"converison/choices.go","grade":"C-","username":"HLamb","timestamp":"2025-10-12T17:10:06.230Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The ConvertProtoToChoices and ConvertModelToProtoChoices functions lack interface abstraction, preventing substitutability and violating Liskov Substitution Principle.\n\n```go\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\tif protoChoices == nil {\n\t\treturn nil\n\t}\n\t// ...\n}\n```","codeResolution":"To improve Liskov Substitution Principle adherence, the conversion logic should delegate to an abstraction rather than directly handling struct fields. Replace the original code block with the following:\n\n```go\n// Golang\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\tif protoChoices == nil {\n\t\treturn nil\n\t}\n\top := getOperation(\"ProtoToModel\")\n\treturn op.Convert(protoChoices).(*jsonSchema.Choices)\n}\n```","severity":"High","rationale":"The code violates the Liskov Substitution Principle because it tightly couples conversion logic to specific types (`pb.Choices` and `jsonSchema.Choices`) without using interfaces or abstractions. This rigidity means alternative implementations or extensions cannot be substituted without modifying existing functions, reducing maintainability and flexibility. If requirements change or new types are introduced, the code must be rewritten rather than extended. Adhering to LSP would allow for easier testing, future-proofing, and improved correctness by enabling polymorphic behavior and reducing the risk of breaking changes.","lineStart":1,"lineEnd":22,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code violates dependency inversion by directly depending on concrete types from external packages rather than abstractions.\n\n```go\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n```","codeResolution":"The conversion functions should delegate transformation logic to an abstraction, enabling easier extension and testing.\n\n```go\n// Replace direct conversion logic with abstraction usage\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\treturn operationFactory.GetOperation(\"ProtoToModel\").Convert(protoChoices).(*jsonSchema.Choices)\n}\n\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n\treturn operationFactory.GetOperation(\"ModelToProto\").Convert(modelChoices).(*pb.Choices)\n}\n```","severity":"Critical","rationale":"This code tightly couples the conversion logic to specific protobuf and Go model types, violating dependency inversion principles. By directly referencing concrete types (`pb.Choices`, `jsonSchema.Choices`), it becomes difficult to extend or test the conversion functions in isolation. This approach reduces maintainability, as any changes to the underlying types require updates throughout the codebase. Introducing interfaces or abstraction layers would decouple the conversion logic, improving flexibility and enabling easier unit testing.","lineStart":1,"lineEnd":18,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The code violates openClosed principles by requiring modification of existing conversion functions to support new fields or types, rather than allowing extension.\n\n```go\nreturn &jsonSchema.Choices{\n\tNumber:  int(protoChoices.Number),\n\tOptions: protoChoices.Options,\n}\n```","codeResolution":"The conversion logic is refactored to leverage an abstraction for openClosed compliance, allowing new conversion types to be added without modifying existing functions.\n\n```go\n// Replacement for the original conversion block\nfunc ConvertChoices(src interface{}) interface{} {\n\top := getOperation(src)\n\treturn op.Convert(src)\n}\n```","severity":"Critical","rationale":"Violating the open/closed principle here means any changes to the Choices structure (e.g., adding new fields) require modifying both conversion functions directly. This tightly couples the conversion logic to the data model, making maintenance difficult and error-prone as the codebase evolves. Such rigidity increases the risk of bugs if updates are missed and hinders extensibility, since supporting new fields or types demands manual changes throughout. Refactoring to use interfaces or reflection could allow the code to adapt to model changes without direct modification, improving maintainability and adherence to open/closed principles.","lineStart":13,"lineEnd":19,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"C-","openClosedScore":"F","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package converison\n\nimport (\n\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n)\n\n// ConvertProtoToChoices converts a protobuf Choices to the Go model Choices\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\tif protoChoices == nil {\n\t\treturn nil\n\t}\n\n\treturn &jsonSchema.Choices{\n\t\tNumber:  int(protoChoices.Number),\n\t\tOptions: protoChoices.Options,\n\t}\n}\n\n// ConvertModelToProtoChoices converts a Go model Choices to a protobuf Choices\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n\tif modelChoices == nil {\n\t\treturn nil\n\t}\n\n\treturn &pb.Choices{\n\t\tNumber:  int32(modelChoices.Number),\n\t\tOptions: modelChoices.Options,\n\t}\n}\n","reason":"Modified","start":1,"end":31,"grade":"C-"}]},"hash":"cfae6060fb5ce395e4e6f4a5869667d14363d551068722b03ffd683fbbd14051","id":"eJyVkzFrwzAQhf/KoaHYwbGh3QyZUiiFtgkkoxZbkW019p2Q5C4h/70osZOoTindpHd3T+8+0IEV1kprFdZbopblbLN6e31mCRO0k0tCJ9GxnOlC7ItagiD8kkZZQo4cVafJOIg4cqdL4KxWrunLVFCXVcpI0ahOz8nUWU1zu9tntdGCM9/+d++nJdyIRnaFn4j9e1kGy1MAtzbkaEvLhpSQdojlLBSgfaXsKxhrjsA1El4IOtrJdtQ5Vj2K+37RyWQ0mOkyHc4xzK6xRhEOfiFVQTC1WACq9lzjzkjXG/SKvx/9MhfxYWo5TH30XSlNDqDQBZnScyVOzn0r7RShzYME6aAmw4vHkOC7h7Gl9W3mG4w/cXmMU7ghxDuW0cnkQnK6aXyL90IymPoHyavVHYJPj0Ga3xgGPVOGLGGVauW6cA3L2fU/ZGIYqYkdvwHlzDzA"}
{"assessingTool":"SOLID","filePath":"converison/grpcConverison.go","grade":"B","username":"HLamb","timestamp":"2025-10-12T17:09:59.264Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code tightly couples conversion logic directly to concrete types from external packages, violating dependency inversion and reducing flexibility.\n\n```go\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n\tif protoDef == nil {\n\t\treturn nil\n\t}\n\t// ...\n}\n```","codeResolution":"The solution for dependency inversion restructures the conversion logic to depend on an abstract Operation interface, allowing flexible injection of conversion strategies. Replace the original conversion block with the following:\n\n```go\n// Golang\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n\tif protoDef == nil {\n\t\treturn nil\n\t}\n\top := getOperation(\"protoToModel\")\n\treturn op.Execute(protoDef).(*jsonSchema.Definition)\n}\n```","severity":"High","rationale":"The code tightly couples conversion logic to specific protobuf and model types (e.g., `pb.Definition`, `jsonSchema.Definition`) without using interfaces or abstractions. This direct dependency makes it difficult to extend or test conversion logic for new types or schemas, as every change requires modifying the core functions. For example, both `ConvertProtoToModel` and `ConvertModelToProto` directly reference concrete types on nearly every line, violating the Dependency Inversion Principle. This reduces maintainability and flexibility, as the code cannot easily support alternative serialization formats or mock implementations for testing. Introducing interfaces for conversion would decouple the logic, improving testability and future extensibility.","lineStart":3,"lineEnd":67,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The conversion functions in this code violate interfaceSegregation by combining multiple unrelated responsibilities into single, monolithic functions rather than delegating to focused interfaces.\n\n```go\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n\t// ... handles many unrelated fields and conversions in one place ...\n}\n```","codeResolution":"The solution restructures the conversion logic to delegate each nested conversion to specialized operation abstractions, ensuring each concern is handled by a focused interface.\n\n```go\n// Go\nmodelDef.Items = getOperation(\"items\").Convert(protoDef.GetItems())\nmodelDef.HashMap = getOperation(\"hashMap\").Convert(protoDef.GetHashMap())\nmodelDef.NarrowFocus = getOperation(\"focus\").Convert(protoDef.GetNarrowFocus())\nmodelDef.Req = getOperation(\"request\").Convert(protoDef.GetReq())\nmodelDef.Choices = getOperation(\"choices\").Convert(protoDef.GetChoices())\nmodelDef.SpeechToText = getOperation(\"speechToText\").Convert(protoDef.GetSpeechToText())\nmodelDef.TextToSpeech = getOperation(\"textToSpeech\").Convert(protoDef.GetTextToSpeech())\nmodelDef.SendImage = getOperation(\"sendImage\").Convert(protoDef.GetSendImage())\n```","severity":"High","rationale":"The code violates the Interface Segregation Principle by tightly coupling conversion logic for multiple distinct types (e.g., SpeechToText, TextToSpeech, SendImage) into a single package without using focused interfaces. This approach forces clients to depend on all conversion functions, even if they only need one, reducing modularity and making future changes riskier. For example, lines like `func ConvertProtoToModel(protoDef *pb.Definition)` and the various `convertProto...` helpers are all exposed together, rather than behind minimal, type-specific interfaces. This can negatively impact maintainability, as changes to one conversion may inadvertently affect others, and it complicates testing and extension. Introducing fine-grained interfaces for each conversion concern would improve separation and adherence to ISP.","lineStart":1,"lineEnd":67,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"C-","interfaceSegregationScore":"C-","liskovSubstitutionScore":"A+","openClosedScore":"A-","singleResponsibilityScore":"A"},"codeDiff":{"changes":[{"newCode":"package converison\n\nimport (\n\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n)\n\n// ConvertProtoToModel converts a protobuf Definition to your Go model Definition\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n\tif protoDef == nil {\n\t\treturn nil\n\t}\n\n\tmodelDef := &jsonSchema.Definition{\n\t\tType:               jsonSchema.DataType(protoDef.Type),\n\t\tInstruction:        protoDef.Instruction,\n\t\tProperties:         make(map[string]jsonSchema.Definition),\n\t\tItems:              ConvertProtoToModel(protoDef.GetItems()), // Use Getters to handle nil cases\n\t\tModel:              protoDef.Model,\n\t\tProcessingOrder:    protoDef.ProcessingOrder,\n\t\tSystemPrompt:       getStringPointer(protoDef.GetSystemPrompt()), // Safe getter for pointers\n\t\tImprovementProcess: protoDef.ImprovementProcess,\n\t\tSelectFields:       protoDef.SelectFields,\n\t\tVoters:             protoDef.Voters,\n\t\tHashMap:            ConvertProtoToHashMap(protoDef.GetHashMap()),   // Check with Getters\n\t\tNarrowFocus:        ConvertProtoToFocus(protoDef.GetNarrowFocus()), // Handle nil safely\n\t\tReq:                ConvertProtoToRequestFormat(protoDef.GetReq()),\n\t\tChoices:            ConvertProtoToChoices(protoDef.GetChoices()),\n\t\tSpeechToText:       convertProtoSpeechToText(protoDef.GetSpeechToText()), // Safely handle nested structs\n\t\tTextToSpeech:       convertProtoTextToSpeech(protoDef.GetTextToSpeech()),\n\t\tSendImage:          convertProtoSendImage(protoDef.GetSendImage()), // Handle nil structs\n\t\tStream:             protoDef.Stream,\n\t}\n\n\t// Handle Properties map\n\tif protoDef.Properties != nil {\n\t\tfor key, protoProperty := range protoDef.Properties {\n\t\t\tmodelDef.Properties[key] = *ConvertProtoToModel(protoProperty)\n\t\t}\n\t}\n\n\treturn modelDef\n}\n\n// Helper function to safely get string pointers\nfunc getStringPointer(val string) *string {\n\tif val == \"\" {\n\t\treturn nil\n\t}\n\treturn &val\n}\n\n// ConvertModelToProto converts your Go model Definition to a protobuf Definition\nfunc ConvertModelToProto(modelDef *jsonSchema.Definition) *pb.Definition {\n\tif modelDef == nil {\n\t\treturn nil\n\t}\n\n\tsystemPrompt := \"\"\n\tif modelDef.SystemPrompt != nil {\n\t\tsystemPrompt = *modelDef.SystemPrompt\n\t}\n\n\tprotoDef := &pb.Definition{\n\t\tType:               string(modelDef.Type),\n\t\tInstruction:        modelDef.Instruction,\n\t\tProperties:         make(map[string]*pb.Definition),\n\t\tItems:              ConvertModelToProto(modelDef.Items),\n\t\tModel:              modelDef.Model,\n\t\tProcessingOrder:    modelDef.ProcessingOrder,\n\t\tSystemPrompt:       systemPrompt,\n\t\tImprovementProcess: modelDef.ImprovementProcess,\n\t\tSelectFields:       modelDef.SelectFields,\n\t\tVoters:             modelDef.Voters,\n\t\tHashMap:            ConvertModelToProtoHashMap(modelDef.HashMap),\n\t\tNarrowFocus:        ConvertModelToProtoFocus(modelDef.NarrowFocus),\n\t\tReq:                ConvertModelToProtoRequestFormat(modelDef.Req),\n\t\tChoices:            ConvertModelToProtoChoices(modelDef.Choices),\n\t\tImage:              convertModelImage(modelDef.Image),\n\t\tSpeechToText:       convertModelSpeechToText(modelDef.SpeechToText),\n\t\tTextToSpeech:       convertModelTextToSpeech(modelDef.TextToSpeech),\n\t\tSendImage:          convertModelSendImage(modelDef.SendImage),\n\t\tStream:             modelDef.Stream,\n\t}\n\n\t// Handle Properties map\n\tif modelDef.Properties != nil {\n\t\tfor key, modelProperty := range modelDef.Properties {\n\t\t\tprotoDef.Properties[key] = ConvertModelToProto(&modelProperty)\n\t\t}\n\t}\n\n\treturn protoDef\n}\n\n// Helper functions for SpeechToText, TextToSpeech, and other nested structs\n\nfunc convertProtoSpeechToText(speechToText *pb.SpeechToText) *jsonSchema.SpeechToText {\n\tif speechToText == nil {\n\t\treturn nil\n\t}\n\treturn &jsonSchema.SpeechToText{\n\t\tModel:             jsonSchema.SpeechToTextModel(speechToText.Model),\n\t\tAudioToTranscribe: speechToText.AudioToTranscribe,\n\t\tLanguage:          speechToText.Language,\n\t\tToString:          speechToText.ToString,\n\t\tToCaptions:        speechToText.ToCaptions,\n\t\tFormat:            jsonSchema.AudioFormat(speechToText.Format),\n\t}\n}\n\nfunc convertProtoTextToSpeech(textToSpeech *pb.TextToSpeech) *jsonSchema.TextToSpeech {\n\tif textToSpeech == nil {\n\t\treturn nil\n\t}\n\treturn &jsonSchema.TextToSpeech{\n\t\tModel:         jsonSchema.TextToSpeechModel(textToSpeech.Model),\n\t\tVoice:         jsonSchema.Voice(textToSpeech.Voice),\n\t\tStringToAudio: textToSpeech.StringToAudio,\n\t\tFormat:        jsonSchema.AudioFormat(textToSpeech.Format),\n\t}\n}\n\nfunc convertProtoSendImage(sendImage *pb.SendImage) *jsonSchema.SendImage {\n\tif sendImage == nil {\n\t\treturn nil\n\t}\n\treturn &jsonSchema.SendImage{\n\t\tImagesData: sendImage.ImagesData,\n\t}\n}\n\nfunc convertModelSpeechToText(speechToText *jsonSchema.SpeechToText) *pb.SpeechToText {\n\tif speechToText == nil {\n\t\treturn nil\n\t}\n\treturn &pb.SpeechToText{\n\t\tModel:             string(speechToText.Model),\n\t\tAudioToTranscribe: speechToText.AudioToTranscribe,\n\t\tLanguage:          speechToText.Language,\n\t\tToString:          speechToText.ToString,\n\t\tToCaptions:        speechToText.ToCaptions,\n\t\tFormat:            string(speechToText.Format),\n\t}\n}\n\nfunc convertModelTextToSpeech(textToSpeech *jsonSchema.TextToSpeech) *pb.TextToSpeech {\n\tif textToSpeech == nil {\n\t\treturn nil\n\t}\n\treturn &pb.TextToSpeech{\n\t\tModel:         string(textToSpeech.Model),\n\t\tVoice:         string(textToSpeech.Voice),\n\t\tStringToAudio: textToSpeech.StringToAudio,\n\t\tFormat:        string(textToSpeech.Format),\n\t}\n}\n\nfunc convertModelSendImage(sendImage *jsonSchema.SendImage) *pb.SendImage {\n\tif sendImage == nil {\n\t\treturn nil\n\t}\n\treturn &pb.SendImage{\n\t\tImagesData: sendImage.ImagesData,\n\t}\n}\n\nfunc convertModelImage(image *jsonSchema.Image) *pb.Image {\n\tif image == nil {\n\t\treturn nil\n\t}\n\treturn &pb.Image{\n\t\tModel: string(image.Model),\n\t\tSize:  string(image.Size),\n\t}\n}\n","reason":"Modified","start":1,"end":177,"grade":"B"}]},"hash":"06d8c3f79781256f5d6ff40428b3cc68985ace998b2684030cb7e49ed019e5a9","id":"eJzlWU1v2zgQ/StcHYI4cO27AB8WCfIBtNsg9vZS98DIY1lri1RIOl1vkP++4KeGMmU7SW/NKeLMPM5whu8RyUtGpQQpK1bOON9keTb9+vnuKhtmBV/AJWcKmMryrKHFmpZACs6eQVSSszmbs6puuFDkfM7mqnkk86ys1Gr7OCp4PV5WAopVVTefuCjHJf8kF+txKZpinmn3477/SM6mxQpqqiMGer/xmFyaBNS94IrP+Be+gI1LSklCSaPXH7dLcgXLilWq4owoTnZ8K8gNJ7Xxb21zttyyIgV6bpCuYEkumsdRGzEgF21iaJ286KqqJQlxkwlh1cauz5UAtRVMr+jvV13NXJl0tG8+IWdJWBc92zWQk/gH+1NFtUtIeqS/BkMbfMekEttCwwWM4IiMzv1e8AaEqkC2O9Z0Dec1bb5LJSpW/kjmGvZTUMtOtodOeHQDNuZ8MBiS8Zj8LYHcgFIgpG7eirLFBsxhFlSCtLsYjM4uAdEY23oKO+FfxQJEHjl2jC5kupMK6nvB60b5LUpQU1P8Pa+YAhGljwN8FVO6BB2lQJAlF6SxcS79u7oR/BlqYD7BHDVlz+gTgw0U6rqCzSKccIjCRuf/jesd8/QhWaPzvKVy9YU2kWvcNOcR1e3XdMlEF325gmJNflZq5Tto4f+iQvCf17zYttnE8MYWgaMYf6a37ShIuoTNzqI/wFP3dnTQH+BpC1Jdc1FTFe3yAE8a3QJdrnhVgDxwCs4jgvBrAWbaABSrGZ/Bv2F+CgSD7fEcYQOao80u3AKQChbEXlp3uNp75kBT22F7tF1kaLMHtriraYkZJ8re2+PUw2qiVzjbqRJA656ZtMYh4sgWqSUmUtOmQ7cjZP0jYl5999awG1pX57bTlCsoKyGJ4EJbhkbG72vY/SATctHLaX6PgUV5RdU4GfCwc/bqdO0WNo0mii0rvGjZCdcUQiztIgoxsrVHSc9041wH5MLFeF3StsmEzLN51q9JfunsmW7a3FyhpsIZN/W2mtsnrbqCpB7HmotBz4MepjV20NHiUFuIO0FzJaJqPQT6QDowI0znnWmKwifkIhmDtgvPAS3xUfYHpN22LhzHUTUPju9T884L57iMJ5s2MgE+OiXPwfOYPONbd6I84774AhIS2yb7Foltm3yaxAb/UyUWH6jX1ADiFvzJHpBSDGN1M4CgKA90QDUxUCydAfABnk5QTQzkZTJAuIUwcB3NQbpjYKy6oA7SEk5QXBMbCWvbTrTqkQ6IqS0Ga2Z7Q9HqCTpqcwqKiebLLQWMhFi23m8Vy4Sa9Ymlcd0XyxRCEMuEknqxTBHHWbRHv1h62F6xlOZ9jZs5JLghQ0LZgnC1ArH/frJq1Ps6k+jDyE80M5FQYUuQpij+mDwF+e1Bfenl1p4A+yjBOVju9eP153ZR8RmfCcpkIapHyKOER3t2F/eZsnIbT3YU5+3+TnH7Tulz9/bgfkkb09i8x93bXYDlprznQEwRjr4iHLs28BfoNTkN0X1X6MNMQ3Tvo2nAljANUfx7pgGjpqehx9lOAt4/noRvmoqTKMYSR5olRFHmr0fmmPOoxFFkSzerp1ERzEmNaulU+t/shQ2cGt/W4BSualh51z310S9IzaT+y0zeIo/a1d5i9vUq5qCeqz7YY6cPclAHrZ973Gv1d2SZVOnHhnX/FRGzSs8FHuzxzQdZpYOW7q8r8GTeSPn/SrZI4Z904El2SF3fQUwaH2EHjPNLWMEWUO0ljxKPk67enDBO1s2CO3ODFTd/Wv2nex856DXci2yYLasN3FO1yvKs/f+B+V/AZfgclTx7/R/mdror"}
{"assessingTool":"SOLID","filePath":"client/model.go","grade":"B-","username":"HLamb","timestamp":"2025-10-12T17:09:55.614Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependencyInversion","violatingCode":"The RequestBody struct directly depends on the concrete jsonSchema.Definition type, violating dependency inversion by coupling to a specific implementation.\n\n```go\ntype RequestBody struct {\n\tPrompt     string                 `json:\"prompt\"`\n\tDefinition *jsonSchema.Definition `json:\"definition\"`\n}\n```","codeResolution":"The solution introduces an abstraction layer for operation handling, ensuring the client code depends on interfaces rather than concrete implementations.\n\n```go\n// Go\nfunc ProcessRequest(req *RequestBody) (*Response, error) {\n    op := getOperation(req.Definition) // Returns an Operation interface\n    result, err := op.Execute(req.Prompt)\n    if err != nil {\n        return nil, err\n    }\n    return &Response{Data: result, UsdCost: calculateCost(result)}, nil\n}\n```","severity":"Critical","rationale":"This code tightly couples the RequestBody struct to the concrete jsonSchema.Definition type, violating dependency inversion principles. Such direct dependency on an external implementation makes the code harder to maintain and test, as changes in the jsonSchema package could ripple through client code. It also limits extensibility, since swapping out or mocking Definition for testing or future requirements becomes difficult. Introducing an interface or abstraction for Definition would decouple client from jsonSchema, improving maintainability and testability.","lineStart":6,"lineEnd":7,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The RequestBody struct violates the Open/Closed Principle because adding new request fields requires modifying the existing struct.\n\n```go\ntype RequestBody struct {\n\tPrompt     string                 `json:\"prompt\"`\n\tDefinition *jsonSchema.Definition `json:\"definition\"`\n}\n```","codeResolution":"The current code can be improved for openClosed by delegating the resolution logic to an abstraction, allowing new operations to be added without modifying existing code. Replace the violating block with the following:\n\n```go\n// Golang\nfunc codeResolution(request *RequestBody) (*Response, error) {\n\top := getOperation(request.Definition)\n\tresult, err := op.Resolve(request.Prompt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Response{Data: result.Data, UsdCost: result.UsdCost}, nil\n}\n```","severity":"High","rationale":"The current code tightly couples the RequestBody struct to a specific jsonSchema.Definition type, violating the Open/Closed Principle. This design means that any new schema type or extension requires modifying the RequestBody definition directly, reducing maintainability and making future enhancements error-prone. Such coupling can also hinder scalability, as adding support for new schema formats or validation logic would necessitate changes throughout the codebase. Adhering to openClosed would allow new schema types to be introduced via interfaces or abstractions, minimizing code changes and improving long-term flexibility.","lineStart":20,"lineEnd":13,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"C-","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package client\n\nimport \"github.com/objectweaver/go-sdk/jsonSchema\"\n\ntype RequestBody struct {\n\tPrompt     string                 `json:\"prompt\"`\n\tDefinition *jsonSchema.Definition `json:\"definition\"`\n}\n\n// Create a response struct\ntype Response struct {\n\tData    map[string]any `json:\"data\"` //this data can then be marshalled into the apprioate object type.\n\tUsdCost float64        `json:\"usdCost\"`\n}\n","reason":"Modified","start":1,"end":15,"grade":"B-"}]},"hash":"e47d4062cd046d074d173a2343099dfad5262c9da25b437066cf41977041154a","id":"eJxdkUFPwzAMhf+K5SPa2gvi0CPbBQmJicGJIM1L3TZbG4fEPUzT/jvKyjbAtzzn+X2Jj0gpcUrOt28iPVa4fnl+WuIMrdS8EK/sFSsMZPfUMtjesVfjjXdDkKhgsHXajdvCylA2LrLt3BDmEtuylXmq9+UuiV/bjgcymI16CAyv/DVy0kepD5A0jlbhaLzRVZQhKORKGp1v4X9t8rzKYDjfNLjJtiU3zjt14uHullf8ki+2+iqdradMVJawiEzKQBA5BfGJf6iuuH/UiXVJSplooPAxwX6SP9ySSMngBspSO5cgH8GSB+3Yw5ZhoJg66nuuwXmVrAOFEJ1kEtnu2Crk9CKHvad6IUmh6YX04f7/b4xT+/ImnGHjel6RdljhtLRykJr7ohU8fQO/wbEg"}
{"assessingTool":"SOLID","filePath":"converison/focus.go","grade":"D","username":"HLamb","timestamp":"2025-10-12T17:09:54.465Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"openClosed","violatingCode":"The conversion functions violate openClosed principles by requiring modification for every new Focus field added.\n\n```go\nreturn &jsonSchema.Focus{\n    Prompt:       protoFocus.Prompt,\n    Fields:       protoFocus.Fields,\n    KeepOriginal: protoFocus.KeepOriginal,\n}\n```","codeResolution":"The conversion functions are currently tightly coupled to specific types, making extension difficult. Refactoring to use an abstraction for conversion operations enables open/closed compliance and easier future extension.\n\n```go\n// Go\nfunc ConvertProtoToFocus(protoFocus *pb.Focus) *jsonSchema.Focus {\n\treturn getOperation(\"ProtoToModel\").Convert(protoFocus).(*jsonSchema.Focus)\n}\n\nfunc ConvertModelToProtoFocus(modelFocus *jsonSchema.Focus) *pb.Focus {\n\treturn getOperation(\"ModelToProto\").Convert(modelFocus).(*pb.Focus)\n}\n```","severity":"Critical","rationale":"### Rationale\n\nThis code tightly couples the conversion logic to specific types (`pb.Focus` and `jsonSchema.Focus`), violating the Open/Closed Principle. Any future changes—such as supporting new focus types or conversion rules—will require modifying these functions directly, increasing the risk of bugs and regressions. This approach reduces maintainability and extensibility, as developers cannot add new conversion behaviors without altering existing code. Adhering to open/closed would allow new conversions to be added via interfaces or extension points, improving testability and long-term flexibility.","lineStart":1,"lineEnd":24,"status":""},{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The code violates Liskov Substitution Principle by directly coupling conversion logic to concrete types, preventing substitutability or extension via interfaces.\n\n```go\nfunc ConvertProtoToFocus(protoFocus *pb.Focus) *jsonSchema.Focus {\n\tif protoFocus == nil {\n\t\treturn nil\n\t}\n```","codeResolution":"The solution introduces an abstraction layer for conversion operations, enabling substitutability and adherence to the Liskov Substitution Principle.\n\n```go\n// Go\nfunc ConvertProtoToFocus(protoFocus *pb.Focus) *jsonSchema.Focus {\n    return getOperation(\"ProtoToModel\").Convert(protoFocus)\n}\n\nfunc ConvertModelToProtoFocus(modelFocus *jsonSchema.Focus) *pb.Focus {\n    return getOperation(\"ModelToProto\").Convert(modelFocus)\n}\n```","severity":"Critical","rationale":"The provided code snippet demonstrates a lack of adherence to the Liskov Substitution Principle (LSP) due to the absence of interface abstractions. The functions `ConvertProtoToFocus` and `ConvertModelToProtoFocus` are tightly coupled to specific types (`pb.Focus` and `jsonSchema.Focus`), making it difficult to substitute these implementations with alternative types without modifying the existing code. This rigidity can lead to maintainability issues, as any changes to the underlying types require updates across multiple functions. \n\nTo improve LSP adherence, consider defining interfaces for the focus types and using those interfaces in the conversion functions. This would allow for greater flexibility and easier testing, as different implementations could be substituted without altering the core logic, enhancing both maintainability and correctness.","lineStart":1,"lineEnd":22,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code directly depends on concrete types from external packages, violating dependency inversion by not abstracting these dependencies.\n\n```go\nfunc ConvertProtoToFocus(protoFocus *pb.Focus) *jsonSchema.Focus {\n```","codeResolution":"The conversion logic should delegate to an abstracted Operation interface, enabling flexible extension and improved testability.\n\n```go\n// Go\nfunc ConvertProtoToFocus(protoFocus *pb.Focus) *jsonSchema.Focus {\n    return getOperation(\"ProtoToFocus\").Execute(protoFocus)\n}\n\nfunc ConvertModelToProtoFocus(modelFocus *jsonSchema.Focus) *pb.Focus {\n    return getOperation(\"ModelToProtoFocus\").Execute(modelFocus)\n}\n```","severity":"Critical","rationale":"This code tightly couples the conversion logic to specific concrete types from external packages (`pb.Focus` and `jsonSchema.Focus`), violating dependency inversion principles. Such direct dependencies make the code harder to maintain and test, as any change in the external types or their structure requires changes throughout the conversion functions. Introducing abstractions or interfaces for the conversion process would decouple the implementation, improving flexibility and enabling easier mocking for unit tests. This would enhance maintainability and correctness, especially as the codebase grows or external dependencies evolve.","lineStart":1,"lineEnd":22,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"F","openClosedScore":"F","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package converison\n\nimport (\n\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n)\n\n// ConvertProtoToFocus converts a protobuf Focus to the Go model Focus\nfunc ConvertProtoToFocus(protoFocus *pb.Focus) *jsonSchema.Focus {\n\tif protoFocus == nil {\n\t\treturn nil\n\t}\n\n\treturn &jsonSchema.Focus{\n\t\tPrompt:       protoFocus.Prompt,\n\t\tFields:       protoFocus.Fields,\n\t\tKeepOriginal: protoFocus.KeepOriginal,\n\t}\n}\n\n// ConvertModelToProtoFocus converts a Go model Focus to a protobuf Focus\nfunc ConvertModelToProtoFocus(modelFocus *jsonSchema.Focus) *pb.Focus {\n\tif modelFocus == nil {\n\t\treturn nil\n\t}\n\n\treturn &pb.Focus{\n\t\tPrompt:       modelFocus.Prompt,\n\t\tFields:       modelFocus.Fields,\n\t\tKeepOriginal: modelFocus.KeepOriginal,\n\t}\n}\n","reason":"Modified","start":1,"end":33,"grade":"D"}]},"hash":"6d45c36b41ac83bd667288128cc1208056ed48ed4887906462e6d54b353c69df","id":"eJyVk8FugzAQRH9l5UOVRCTckXJK1apqqyAlR1/AGOMGvJZteony75UxDU6apionmJ0Zr5/EkRTWcmulEnvElmRkt317eSQJYVjxDSrHlSMZ0QU7FIIDQ/XJjbSoqKJKdhqNgxlV1OkSKBHSNX25YtiltTScNbLTSzQiFbi01SEVRjNKvP1v74dFtWMN7wqfmPvz0hQ2wwIuN+hwj0/Iejsu5SwUoL1e9jWEiUNwDYdnhA4r3gaVqrpX7FbTbIiH6EKXq+FtDotplSDB0V9B1hD512tQsg0T6gx3vVFe8d8nv/xZfLiuGzO5wU67DMIzVa/CIAmuJ8nbyt5whcHoeuVcb40UUhVtFrviQTLudrpk++5R7TGf7hYBvkTpAV9Dv8T7o2w2xEfG1yTmE/Yz48j/D8bfNTfZTpX32EauO2wj1y9sSUJq2fK8cA3JyPQHpfWQEkhOX9uSSko="}
{"assessingTool":"SOLID","filePath":"client/grpcGenerateObject.go","grade":"C-","username":"HLamb","timestamp":"2025-10-12T17:09:53.593Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"singleResponsibility","violatingCode":"The GrpcGenerateObject method is responsible for both managing gRPC connection lifecycle and handling request/response logic, violating the single responsibility principle.\n\n```go\nconn, err := grpc.NewClient(c.BaseURL, grpc.WithInsecure(), grpc.WithBlock())\n...\ndefer func(conn *grpc.ClientConn) {\n    err = conn.Close()\n    if err != nil { }\n}(conn)\n```","codeResolution":"The solution applies the single responsibility principle by delegating the gRPC request logic to a dedicated abstraction, ensuring the client method only coordinates the operation.\n\n```go\n// Go\nfunc (c *Client) GrpcGenerateObject(prompt string, definition *pb.Definition) (*Response, error) {\n    op := getOperation(\"GenerateObject\", c.BaseURL, c.Password)\n    result, err := op.Execute(prompt, definition)\n    if err != nil {\n        return nil, err\n    }\n    return result, nil\n}\n```","severity":"High","rationale":"The method `GrpcGenerateObject` violates the Single Responsibility Principle by handling connection setup, authentication, request construction, RPC invocation, and response conversion all within a single function. This tightly coupled design makes the code harder to maintain and test, as changes to any one concern (e.g., authentication or connection logic) require modifications to the entire method. It also increases the risk of introducing bugs and reduces code clarity. Separating these responsibilities into distinct functions or types would improve maintainability, enable easier unit testing, and enhance overall code correctness.","lineStart":17,"lineEnd":36,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The GrpcGenerateObject method violates the Open/Closed Principle by hardcoding the gRPC method call, making it difficult to extend for other RPC methods without modifying the function.\n\n```go\nresponse, err := client.GenerateObject(ctx, request) // Replace 'GenerateObject' with the actual RPC method name\n```","codeResolution":"The current GrpcGenerateObject implementation can be improved for openClosed compliance by delegating the RPC method selection to an abstraction, allowing new operations without modifying this function.\n\n```go\n// SendRequestToServer sends a request to the gRPC server with authorization headers\nfunc (c *Client) GrpcGenerateObject(prompt string, definition *pb.Definition, op Operation) (*Response, error) {\n\t// ... (setup code as before) ...\n\trequest := &pb.RequestBody{\n\t\tPrompt:     prompt,\n\t\tDefinition: definition,\n\t}\n\tresponse, err := op.Execute(ctx, client, request)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"operation failed: %v\", err)\n\t}\n\tdata, err := converison.ConvertStructpbToMap(response.Data)\n\tres := &Response{\n\t\tData:    data,\n\t\tUsdCost: response.UsdCost,\n\t}\n\treturn res, nil\n}\n```","severity":"High","rationale":"The current implementation violates the Open/Closed Principle because any change to the request or response handling, such as supporting a new gRPC method or modifying metadata, requires direct modification of the `GrpcGenerateObject` function (lines 10–56). This tightly couples the logic to a specific RPC and request structure, making future extensions error-prone and harder to maintain. As new features or RPCs are added, developers must repeatedly alter the same function, increasing the risk of introducing bugs and regressions. Refactoring to use abstractions or interfaces for request construction and RPC invocation would allow the code to be extended without modifying existing logic, improving maintainability and scalability.","lineStart":22,"lineEnd":38,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code violates dependency inversion by directly instantiating and depending on the concrete gRPC client within the method, rather than relying on abstractions.\n\n```go\nclient := pb.NewJSONSchemaServiceClient(conn)\nresponse, err := client.GenerateObject(ctx, request)\n```","codeResolution":"The solution introduces an abstraction layer for gRPC operations, allowing the client to depend on an interface rather than a concrete implementation, which improves testability and flexibility.\n\n```go\n// Replace direct usage of pb.JSONSchemaServiceClient with an injected Operation abstraction\noperation := getOperation(conn) // Returns an Operation interface implementation\nresponse, err := operation.GenerateObject(ctx, request)\nif err != nil {\n    return nil, fmt.Errorf(\"failed to call GenerateObject: %v\", err)\n}\n```","severity":"Critical","rationale":"This code violates dependency inversion by directly instantiating and managing the gRPC connection and service client within the GrpcGenerateObject method (lines 10–24). This tight coupling to concrete implementations makes the code harder to test, maintain, and extend. For example, swapping out the gRPC client for a mock or alternative transport would require modifying this method, rather than simply injecting an abstraction. Adhering to dependency inversion would allow for easier unit testing, improved flexibility, and better separation of concerns.","lineStart":22,"lineEnd":44,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The GrpcGenerateObject method violates interface segregation by directly depending on the concrete pb.JSONSchemaServiceClient rather than an abstract, minimal interface.\n\n```go\nclient := pb.NewJSONSchemaServiceClient(conn)\nresponse, err := client.GenerateObject(ctx, request)\n```","codeResolution":"The current GrpcGenerateObject implementation can be improved by delegating the object generation logic to an Operation abstraction, promoting better interface segregation:\n\n```go\ngo\n// Replace direct gRPC call with Operation abstraction\noperation := getOperation(\"generateObject\")\nresult, err := operation.Execute(ctx, prompt, definition)\nif err != nil {\n    return nil, fmt.Errorf(\"operation failed: %v\", err)\n}\nreturn result, nil\n```","severity":"High","rationale":"The current implementation violates the Interface Segregation Principle by tightly coupling the `GrpcGenerateObject` method to the entire gRPC client and connection setup (lines 10–44). This monolithic approach forces consumers to depend on all aspects of request creation, connection management, and response handling, even if they only need a subset of this functionality. Such coupling reduces maintainability, as changes to connection logic or metadata handling will ripple through unrelated code. Splitting responsibilities into smaller, focused interfaces would allow for easier testing, extension, and reuse, improving both correctness and long-term code quality.","lineStart":17,"lineEnd":38,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"C-","liskovSubstitutionScore":"A+","openClosedScore":"C-","singleResponsibilityScore":"C-"},"codeDiff":{"changes":[{"newCode":"package client\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/objectweaver/go-sdk/converison\"\n\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"time\"\n)\n\n// SendRequestToServer sends a request to the gRPC server with authorization headers\nfunc (c *Client) GrpcGenerateObject(prompt string, definition *pb.Definition) (*Response, error) {\n\t// Set up a connection to the gRPC server\n\tconn, err := grpc.NewClient(c.BaseURL, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect to server: %v\", err)\n\t}\n\tdefer func(conn *grpc.ClientConn) {\n\t\terr = conn.Close()\n\t\tif err != nil {\n\n\t\t}\n\t}(conn)\n\n\t// Create a new client from the gRPC service\n\tclient := pb.NewJSONSchemaServiceClient(conn)\n\n\t// Create a context with a timeout\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*10)\n\tdefer cancel()\n\n\t// Set up metadata with the authorization token\n\tmd := metadata.New(map[string]string{\"x-api-key\": c.Password})\n\tctx = metadata.NewOutgoingContext(ctx, md)\n\n\t// Create the request object\n\trequest := &pb.RequestBody{\n\t\tPrompt:     prompt,\n\t\tDefinition: definition,\n\t}\n\n\t// Call the gRPC method on the client\n\tresponse, err := client.GenerateObject(ctx, request) // Replace 'GenerateObject' with the actual RPC method name\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to call GenerateObject: %v\", err)\n\t}\n\n\tdata, err := converison.ConvertStructpbToMap(response.Data)\n\n\tres := &Response{\n\t\tData:    data,\n\t\tUsdCost: response.UsdCost,\n\t}\n\n\treturn res, nil\n}\n","reason":"Modified","start":1,"end":59,"grade":"C-"}]},"hash":"172a30e28a4bff4002054a70600a6c0dc841783a5acb5552409ccbb3a1903f14","id":"eJylVE2P4zYM/SusgHbtwGO3VwO5TKZYbLHdGSSz6KHuQZFpW40tuhI9M9tB/vtCkp2PzgJ7aA6JQlLke4+kXoV0Dp3Tpn0k6kUpdvcfP9yJTCiqcUOG0bAoxSjVQbYIqtdouDKV0cNIliGpTMWVUD7yhSsR/zbD6dhq7qZ9rmgoGm1RdXoYb8i2RUs3rj4UiswTWu3IxBvjHr5/qbWjOhUganvMW+qlafMQ9F1vMSDLWrJcwlgP6M+pp1YUsENTb/GfCR0/0g7tE1pwaGoHEmy0AxNwh9BuHzbgYsiz5g7kxB1Z/a9kTQY6lDVaV5lmMgoSBatN0DCF93ZU79GglYz3+79RcTJaGkYGx1abNoMaG210SLMa9/nd6W8KyWqLbiTjMAO0lmwKr55KwM4wjSBBkTGowvW3WH2wDwjXoVyD1yX/hM8RXqLyW+nw8/ZjFj1/aO4+GIdqspikF8bbntQhSb1yrJuQ7Yc1GN1HQBVb5Mkab8mgGTj/1cNtkko0UvdYe2wzUn+M6Er48akSAVtIfPRfNTZoweuY+AuwChgi3g0Zky4VPYZ1SJpvenKYpNH+Fl4wh+THkDONtqKAjUXJCBIMPs9jD42l4VpHrTAIGf3lGsa91/C33f2nnepwkLsYtIj67RLz9szjA34YaeKQmF8yUNIo7H32OTDo/hijksV2K9WhtTSZ2rfH58h3qMjUq19+Ts/yxWTJGcU8LstGRBCe5PUcMx0wXBlqj2QJ92yTQY5/xpn9K/68VuLlRo765oBfKlGCyh+kc89k62M604LrHPcTt6RNu4lskkB8qN+I5YEtC0hhabx/sZRr+Gnc5/Pm3lL9ZZ6Ih7BYJfhPXLIsOs47VV6sW7bM3Fxb9v257wNyRzV4TbqLF5Ht5UKGbgVX/p8dD8xmwCkUBWxx7KVCeHcd+O6iE4on2cNFcSMH/F8L5xld1/vWyvmpkSzPjE6Pdb4JR96xnRSP+0f6XY7JIkF+J1nOvbPoQl+W92oG6SNCP0KBaPvs6g05LuGUZ7Zc9mNmZ9FlnmJljpURmWh0jw+SO1GKqHt46K8p5i2J41fiv39Y"}
{"assessingTool":"Complexity","filePath":"client/client.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:09:52.023Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A+","testability":"A"},"issues":{"cyclomaticComplexity":3,"dependenciesModules":2,"functionMethodCounts":3,"linesOfCode":66,"nestingDepth":2}},"hash":"44d02efe11ac4cd09df65e3852bece30371b9606311b07dbb68ce12abd237f78","id":"eJzdVblu3DAQ/ZWJCkO7kKV+ATe2gbgIgoWPJlDDpUYSY4mkyVE2juF/D3jo8tpAUqSJGq3meHwzb4b7kjBr0Vohm3ulumSXXKled/hT0HOSJVxVeKUkoaRkl2jGH1mDwDuBkkpZStFrZQjSUpZUJhKpaIl0mTifszSC2uGQc9UXtTDIW9Hrc2WaolHntnosvlsl73iLPXM5G5dWFHDl8cGg1UpacegQamWgVV0lZAMHZhG4krVoBsNIKAlMVlChRlmh5AJtKelZ4whkyQyc4MVx2jNrj8pUMD2WjJCN810yiw+3X+A93w2RjnDxmS3Of4tPA1q6cxSM968sIcTXg3ujOFqrDJxYSvkae7A4T0hCUzOOQArYwZJhnODm/n4PSmPowFjxu2m+8GuVGnyCrRMoj9w2kI7fgUgGaIwym5nHuq4Zc+RhwYQIsCiDPNiyH8LV4hl9BOBJOWsMuFTVczqYLgNSjyhj67MR3rlhu4j9A+5f8XiNNRs6mloiSLBO/EILDCQeYXJYYpIjHAW1UIUkEG4TepQ0trgeJD9BTXUcqQwG0028w5LEfofIDWzjeb54gzQYCWfB5k3zfO7mIZzwQ0Sc0kWAOzc6Z/0nfyAS/Ss1Qshcz8qZhrzNlPhmVHcu8cSahvjXlQifvwn9dwq4DOCq18bdTUr6/Y+TsNBhBv4PRHDF/BMFFkvml9QCtQjaqF5TvDlrr4uSmf8OPYlhzFisxrsYY+9TPnZxs4RPI+jY/hkYtvNVn19PZrfEb/d31GVe+90FnC02fxTJnxXaF86NjZrhd8vSYlfcqyjgwaKvb309kfId8p7IIJCx2tNzVHi+ysnf3mE8j8ORAc/301guCnL/cyRqD/jpAqToINYUp1GKzh+3phwljuRGPaYknp/MQh5/jY7UpYULMsmSWnS4Z9QmuyRMWhFeeaOS19/fr+9u"}
{"assessingTool":"SOLID","filePath":"client/req.go","grade":"D-","username":"HLamb","timestamp":"2025-10-12T17:09:48.375Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"singleResponsibility","violatingCode":"The ExecuteRequest function violates single responsibility by handling request body merging, JSON marshaling, HTTP request creation, header setting, and request execution all within one method.\n\n```go\nbody, err := json.Marshal(d.Req.Body)\nreq, err := http.NewRequest(string(d.Req.Method), d.Req.URL, bytes.NewBuffer(body))\nclient := &http.Client{}\nresp, err := client.Do(req)\n```","codeResolution":"The solution introduces an abstraction layer for request execution, ensuring that each component adheres to the single responsibility principle by delegating HTTP operations to a dedicated type.\n\n```go\n// Go\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\top := getOperation(def, currentGen)\n\tresult, err := op.Execute()\n\tif err != nil {\n\t\tlog.Println(\"failed to execute operation\", err)\n\t\treturn nil\n\t}\n\treturn result\n}\n```","severity":"Critical","rationale":"This code violates the single responsibility principle by combining request construction, body merging, header management, authorization, and network execution within `ExecuteRequest` (lines 8–44). Such coupling makes the function harder to maintain and test, as changes to any aspect (e.g., body format or header logic) require modifying the same method. This increases the risk of introducing bugs and complicates future enhancements. Separating concerns—such as extracting body preparation, header setup, and HTTP execution into distinct functions—would improve maintainability, readability, and correctness.","lineStart":17,"lineEnd":41,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The code violates the open/closed principle by requiring direct modification of the ExecuteRequest function to support new request types or authentication schemes.\n\n```go\n// Set authorization\nreq.Header.Set(\"Authorization\", d.Req.Authorization)\n```","codeResolution":"The solution introduces an abstraction layer for request execution, allowing new request types or behaviors to be added without modifying existing logic. The original direct call to `ExecuteRequest` is replaced by invoking an `Operation` interface, promoting open/closed compliance.\n\n```go\n// Go\nop := getOperation(def.Req.Method)\nrequest, err := op.Execute(currentGen, def)\n```","severity":"Critical","rationale":"This implementation violates the open/closed principle by tightly coupling request construction logic to specific struct fields and direct map manipulation (e.g., lines 11–22). Any change to the request format or addition of new behaviors requires modifying the core ExecuteRequest function, increasing maintenance burden and risk of regressions. This rigidity hinders extensibility, as supporting new request types or authentication schemes would force invasive changes rather than allowing extension via new abstractions. Such design choices reduce maintainability and scalability, making future enhancements error-prone and costly. Refactoring to use interfaces or strategy patterns would better support open/closed compliance.","lineStart":22,"lineEnd":54,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code violates dependency inversion by directly instantiating and depending on the concrete http.Client type within the ExecuteRequest function.\n\n```go\nclient := &http.Client{}\nresp, err := client.Do(req)\n```","codeResolution":"The solution introduces an abstraction layer for HTTP operations, enabling dependency inversion by decoupling request execution from concrete implementations.\n\n```go\n// Go\n// Replace direct usage of http.Client with injected Operation abstraction\nfunc ExecuteRequest(currentGen map[string]any, d *jsonSchema.Definition, op Operation) (*http.Response, error) {\n\t// ... (body and request preparation as before)\n\treq, err := http.NewRequest(string(d.Req.Method), d.Req.URL, bytes.NewBuffer(body))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create request: %w\", err)\n\t}\n\tfor key, value := range d.Req.Headers {\n\t\treq.Header.Set(key, value)\n\t}\n\treq.Header.Set(\"Authorization\", d.Req.Authorization)\n\t// Use abstraction for execution\n\treturn op.Do(req)\n}\n```","severity":"Critical","rationale":"This code tightly couples the HTTP client instantiation (`client := &http.Client{}` in `ExecuteRequest`) and request execution logic directly within the function, violating dependency inversion principles. By depending on concrete implementations rather than abstractions (e.g., an injected interface for HTTP operations), the code becomes difficult to test, extend, or maintain. For example, swapping out the HTTP client for a mock in unit tests or customizing client behavior (timeouts, retries) would require modifying the function itself. Adhering to dependency inversion would allow for greater flexibility, easier testing, and improved maintainability by decoupling high-level logic from low-level details.","lineStart":22,"lineEnd":38,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The code violates interface segregation by forcing all request execution logic into a single ExecuteRequest function, making clients depend on unnecessary details regardless of their specific needs.\n\n```go\nfunc ExecuteRequest(currentGen map[string]any, d *jsonSchema.Definition) (*http.Response, error) {\n\t// Merge currentGen into the existing body\n\tif d.Req.Body == nil {\n\t\td.Req.Body = make(map[string]interface{})\n\t}\n\tfor key, value := range currentGen {\n\t\td.Req.Body[key] = value\n\t}\n```","codeResolution":"The solution applies interface segregation by delegating request execution to an abstraction, ensuring each component only depends on the methods it requires.\n\n```go\n// Go\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\toperation := getOperation(def.Req.Method)\n\trequest, err := operation.Execute(currentGen, def)\n\tif err != nil {\n\t\tlog.Println(\"failed to execute request\", err)\n\t\treturn nil\n\t}\n\n\tvalue, err := extractValue(request)\n\tif err != nil {\n\t\tlog.Println(\"failed to extract value\", err)\n\t\treturn nil\n\t}\n\n\treturn value\n}\n```","severity":"Critical","rationale":"This code violates interface segregation by tightly coupling HTTP request execution, body merging, header setting, and error handling into a single function (`ExecuteRequest`). This monolithic approach forces all consumers to depend on unnecessary details, making the code harder to maintain and test. For example, changes to request construction or error handling logic require modifications across unrelated concerns, increasing the risk of bugs. Segregating responsibilities into focused interfaces (e.g., a body builder, header manager, and request executor) would improve modularity, facilitate unit testing, and enhance maintainability.","lineStart":22,"lineEnd":41,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"F","liskovSubstitutionScore":"A+","openClosedScore":"D-","singleResponsibilityScore":"D"},"codeDiff":{"changes":[{"newCode":"package client\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n\t\"log\"\n\t\"net/http\"\n)\n\n// ExecuteRequest executes an HTTP request based on the RequestFormat\nfunc ExecuteRequest(currentGen map[string]any, d *jsonSchema.Definition) (*http.Response, error) {\n\t// Merge currentGen into the existing body\n\tif d.Req.Body == nil {\n\t\td.Req.Body = make(map[string]interface{})\n\t}\n\tfor key, value := range currentGen {\n\t\td.Req.Body[key] = value\n\t}\n\n\t// Marshal the body to JSON\n\tbody, err := json.Marshal(d.Req.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal body: %w\", err)\n\t}\n\n\t// Create the HTTP request\n\treq, err := http.NewRequest(string(d.Req.Method), d.Req.URL, bytes.NewBuffer(body))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create request: %w\", err)\n\t}\n\n\t// Set headers\n\tfor key, value := range d.Req.Headers {\n\t\treq.Header.Set(key, value)\n\t}\n\t// Set authorization\n\treq.Header.Set(\"Authorization\", d.Req.Authorization)\n\n\t// Execute the request\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to execute request: %w\", err)\n\t}\n\n\treturn resp, nil\n}\n\n// the below occurs within the internal workings (i think)\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\t//the request that is sent out needs to send out a current map of the generated object.\n\n\trequest, err := ExecuteRequest(currentGen, def)\n\tif err != nil {\n\t\tlog.Println(\"failed to execute request\", err)\n\t\treturn nil\n\t}\n\n\tvalue, err := extractValue(request)\n\tif err != nil {\n\t\tlog.Println(\"failed to extract value\", err)\n\t\treturn nil\n\t}\n\n\treturn value\n}\n","reason":"Modified","start":1,"end":69,"grade":"D-"}]},"hash":"87c029de7050e65fa40eaf471b534bcadbeb7bac7700aaebebf9341448c2c10e","id":"eJyllE1v2zAMhv8KJ2CDXXj2PUAPW9t9od2KpNtl7kGxaVuLTaUSvTQr8t8HyXLibMgGbJcgoijyIV+aT0Jai9Yqqu+0bsVMLD5dv78UiSh0iReaGInFTKxlsZI1QtEqJM4pJ9WttWGIcso5F8sto83FcEAqdKmozr5ZTaOx6nj8Wytu+mVa6C6rlMGiUd36pTZ1VuuXtlz5Z4uiwU6OL1pdj38JOWuY1+4cO5Asg6tHLHrGOT70aBlwOFqQBO/u7m7BhIultFiCJuAGIXi/0aaTnFPVU/FLoKjojUHit0jQyfVXy0ZRfS9pm0AJZwfM9BIrRYqVphiiM4eXztGuNVlMAI3RJoYnx59lcIPGNfIQWhFrT4SPyrKiGpa63DpvVUGZzvEhfa3LLZyfA6l2iJPz9AI6ucJogqiI0VSywKed6xHv3E+lDaxwm8B32fYIs3Mwko5Rfov9dYXbezgfnoyRQh3S2Ea2ntwBA2v4sPj00V27sy/cZXF9SoN3dAgdhwqd17Oj0gxyb8hZEqg6Tq9cA6soF5VULZYuUReSu0QzeL7JhU8XHyNeGJSMnnA6B+7W4MMe0Ov1ETej7EMTA+oNcqPLOAlKfJ5fJ+Cn3b143VcVmshRxP9VTzGQBsDTFS2QoUFZorF/knRgfTc4HjBGU7pAjg7vDiMSMsieG23UD+kmOnRr+jQXr448xNidI3O8pw6flRdiosGwTBz1Cy/BhT8/7YaMdr0XaHBML3Vk8OG/+hxWw18aHQINDKTanHZh0/hhx1ZvQBdFbyxsFDdqWCj+oyPZwkablaLaQqTA3a7isF4WSOU4ZCVWJ1ZIAif3Tgxnc7TjKpm0E7iRDMqCdR3VPQMhltaVbJFKb5FjXBcUdOWhayQ0kt1aXH7DgtOxAz7sXoGTizGBEqvTkrS6Tm+NIm7pTzpMNZjqONHET+qeBx/ZyIK/OGMUgvwLhY8SttvfGYIxLMNdTiIRlWrxVnIjZmIY08x9LLUWu5/2C6Ze"}
{"assessingTool":"SOLID","filePath":"converison/hashmap.go","grade":"C-","username":"HLamb","timestamp":"2025-10-12T17:09:46.773Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code directly depends on concrete types from external packages, violating dependency inversion by not using abstractions.\n\n```go\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n```","codeResolution":"The conversion functions should delegate field conversion to an injected abstraction, promoting loose coupling and testability.\n\n```go\n// Replace direct calls with abstraction usage\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap, converter FieldConverter) *jsonSchema.HashMap {\n\tif protoHashMap == nil {\n\t\treturn nil\n\t}\n\treturn &jsonSchema.HashMap{\n\t\tKeyInstruction:  protoHashMap.KeyInstruction,\n\t\tFieldDefinition: converter.ToModel(protoHashMap.FieldDefinition),\n\t}\n}\n\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap, converter FieldConverter) *pb.HashMap {\n\tif modelHashMap == nil {\n\t\treturn nil\n\t}\n\treturn &pb.HashMap{\n\t\tKeyInstruction:  modelHashMap.KeyInstruction,\n\t\tFieldDefinition: converter.ToProto(modelHashMap.FieldDefinition),\n\t}\n}\n```","severity":"Critical","rationale":"This code tightly couples the conversion logic to specific protobuf and Go model types, violating dependency inversion principles. By directly referencing concrete types (e.g., `pb.HashMap`, `jsonSchema.HashMap`), any change in these structures or the conversion process requires modifying this function, reducing maintainability and flexibility. It also makes unit testing difficult, as mocking or substituting dependencies is not straightforward. Introducing interfaces or abstraction layers for conversion would decouple the logic, making the codebase easier to extend, test, and maintain.","lineStart":7,"lineEnd":18,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The ConvertProtoToHashMap and ConvertModelToProtoHashMap functions violate interface segregation by directly depending on concrete types rather than abstractions, reducing flexibility and testability.\n\n```go\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n```","codeResolution":"The current conversion functions can be improved by delegating field conversion to an Operation abstraction, ensuring better adherence to the interface segregation principle.\n\n```go\n// Go\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\tif protoHashMap == nil {\n\t\treturn nil\n\t}\n\top := getOperation(\"protoToModel\")\n\treturn &jsonSchema.HashMap{\n\t\tKeyInstruction:  protoHashMap.KeyInstruction,\n\t\tFieldDefinition: op.Convert(protoHashMap.FieldDefinition),\n\t}\n}\n\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n\tif modelHashMap == nil {\n\t\treturn nil\n\t}\n\top := getOperation(\"modelToProto\")\n\treturn &pb.HashMap{\n\t\tKeyInstruction:  modelHashMap.KeyInstruction,\n\t\tFieldDefinition: op.Convert(modelHashMap.FieldDefinition),\n\t}\n}\n```","severity":"High","rationale":"The code violates interface segregation by tightly coupling conversion logic for both protobuf and Go model HashMap types within the same package and functions (lines 7–28). This approach reduces modularity and makes future changes harder, as any update to one conversion method may inadvertently affect the other. It also hinders testability and reusability, since clients must depend on all conversion logic even if they only need one direction. Separating conversion responsibilities into distinct, fine-grained interfaces would improve maintainability and allow clients to depend only on the functionality they require.","lineStart":1,"lineEnd":23,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The code violates openClosed by requiring modification of existing conversion functions whenever a new field is added to the HashMap models.\n\n```go\nreturn &jsonSchema.HashMap{\n\tKeyInstruction:  protoHashMap.KeyInstruction,\n\tFieldDefinition: ConvertProtoToModel(protoHashMap.FieldDefinition),\n}\n```","codeResolution":"The conversion functions are refactored to leverage an abstraction for field conversion, ensuring new conversion strategies can be added without modifying existing code.\n\n```go\n// ConvertProtoToHashMap converts a protobuf HashMap to the Go model HashMap using an Operation abstraction\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\tif protoHashMap == nil {\n\t\treturn nil\n\t}\n\treturn &jsonSchema.HashMap{\n\t\tKeyInstruction:  protoHashMap.KeyInstruction,\n\t\tFieldDefinition: getOperation(\"protoToModel\").Convert(protoHashMap.FieldDefinition),\n\t}\n}\n\n// ConvertModelToProtoHashMap converts a Go model HashMap to a protobuf HashMap using an Operation abstraction\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n\tif modelHashMap == nil {\n\t\treturn nil\n\t}\n\treturn &pb.HashMap{\n\t\tKeyInstruction:  modelHashMap.KeyInstruction,\n\t\tFieldDefinition: getOperation(\"modelToProto\").Convert(modelHashMap.FieldDefinition),\n\t}\n}\n```","severity":"Critical","rationale":"This code violates the Open/Closed Principle because any new mapping logic between protobuf and Go models requires modifying the existing conversion functions (e.g., `ConvertProtoToHashMap`, `ConvertModelToProtoHashMap`). This approach tightly couples conversion logic to specific types, making the code harder to maintain and extend. If new fields or types are added to `HashMap`, every conversion function must be updated, increasing the risk of errors and regressions. A more extensible design would use interfaces or generic mapping strategies, allowing new types or fields to be supported without altering existing code, thus improving maintainability and correctness.","lineStart":13,"lineEnd":22,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"C-","liskovSubstitutionScore":"A+","openClosedScore":"F","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package converison\n\nimport (\n\tpb \"github.com/objectweaver/go-sdk/grpc\"\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n)\n\n// ConvertProtoToHashMap converts a protobuf HashMap to the Go model HashMap\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\tif protoHashMap == nil {\n\t\treturn nil\n\t}\n\n\treturn &jsonSchema.HashMap{\n\t\tKeyInstruction:  protoHashMap.KeyInstruction,\n\t\tFieldDefinition: ConvertProtoToModel(protoHashMap.FieldDefinition),\n\t}\n}\n\n// ConvertModelToProtoHashMap converts a Go model HashMap to a protobuf HashMap\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n\tif modelHashMap == nil {\n\t\treturn nil\n\t}\n\n\treturn &pb.HashMap{\n\t\tKeyInstruction:  modelHashMap.KeyInstruction,\n\t\tFieldDefinition: ConvertModelToProto(modelHashMap.FieldDefinition),\n\t}\n}\n","reason":"Modified","start":1,"end":31,"grade":"C-"}]},"hash":"1cac7bfb034f8da304ebf63c8d2fa6962b6e71189d99c0932e51e8f402cfdb0d","id":"eJyVk1FvwiAUhf8K4WGxprbvTXzSbDObmYk+8kIpLcyWS4AuWYz/faG2WtRt8Q3u5Rzu+QgHTK3l1kpV7QBqnOHtx/tqiWPMoOALUI4rhzOsKdvTiiMG6osbaUERRZRsNBiHJkQRp3NEcCWdaPOEQZOW0nAmZKNnYKq0gpkt9mllNCPYH///7KcFtWWCN9QrIn9fmqJFN4DbGHCwg1dqxZrqfixnEUXad/K2REPPAXKCoxdADRS8HupEla1i9/0mnclgMNV50q8jNL2MNRTRwQeSJQpU8zlSsj71iDPctUb5it8ffZhz8enWsle98e+Vss60zElQGQpuSMJufJI8S14XS15KJU+aMODaIwjiJVeKKO4nPIbEO+UONuOMI+zXeD3228cIod+xnHQmZ/K3ZKLxc5zJB6oHyF+sfiM+dn6M+DhdEOsv4jjGpaz5hjqBM3z5bamgVjRUJxXg4w8SiGA/"}
{"assessingTool":"Complexity","filePath":"client/model.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:09:45.190Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":0,"dependenciesModules":1,"functionMethodCounts":0,"linesOfCode":15,"nestingDepth":1}},"hash":"b41b95475a37c6c947307e2bffbac5cb169fa0cdd6fb839a792342e92d005a89","id":"eJxdkU1uAjEMha9ieVnBzKbqgmXhAKg/q6YSJmNmAkmcJh6pCHH3KlCgxbs85/l9iQ9IpXApLvZvIh5nOJeQPH873eMErXQ8l6gcFWeYyO6oZ7DecVQTTXQhSVYw2DsdxnVjJbQbl9kOLqSp5L7tZVq6XbstEl/twIEMVqPuE8MLf41c9Fm6PRTNo1U4mGh0mSUkhVpFs4s93NeqzpsZTKebBlfVtuCNi06dRHi45TV/5Iutu0on67EStS3MM5MyEGQuSWLhX6or7j/1zLogpUoUKH2cYT8p7m9JpGRwBW2rgytQj2Apgg4cYc0QKJeBvOcOXFSpOlBK2UklkfWWrUJNb2rYe+nmUhQ2XkifHu9/Yzy3L2/CCW6c5yXpgDM8L60N0rFvesHjD/8Qs9M="}
{"assessingTool":"Complexity","filePath":"converison/focus.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:09:39.257Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A+","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":2,"functionMethodCounts":2,"linesOfCode":33,"nestingDepth":2}},"hash":"440797a7dd531fffceaaa8585254b9e635243f17da35fabcb35938dfc2c47079","id":"eJyVk8FugzAQRH/F8qFKIhLuSDlFSg9VVaTm6As4i3EDXsteqlZR/r0ypoGkaapygtmZ8fpJHHnhPXivjdohNjzjG2xtAx+aPnnCJe5hg4bAEM+4LeShUMAkmndw2qMRRhjdWnTEZsIIsiUTXGmqu3IlsU0r7UDWurVLdCpVuPT7Q6qclYIH+9/eN4/mVdbQFiExD+elKdv0C1DukHCHW5SdH5Yizwpmg152FYsTQkY1sEdkLe6hiaowVWfkraZZH4/RhS1X/ducLcZVosSO4Qq6YhP/es2MbuJEkAPqnAlK+D6F5c/iw3XdkMkdtpYyFp+xehUHSXRtNTR7f8MVB4PrCcC+OK20KZps6poOkmG30yXb54Bqh/l4twngS5QB8DX0S7w/ymZ9fGB8TWI+Yj8znvj/wfi75ibbsfIe24nrDtuJ6xe2POGVbiAvqOYZH/+gtOpTCvnpC1WPTP0="}
{"assessingTool":"SOLID","filePath":"client/client.go","grade":"A","username":"HLamb","timestamp":"2025-10-12T17:09:32.819Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"dependencyInversionScore":"A+","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"A+","singleResponsibilityScore":"A"},"codeDiff":{"changes":[{"newCode":"package client\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/objectweaver/go-sdk/jsonSchema\"\n)\n\n// Client responsible for holding base configuration and dependencies\ntype Client struct {\n\tPassword          string\n\tBaseURL           string\n\tHttpClient        HttpClient\n\tRequestSender     RequestSender\n\tResponseProcessor ResponseProcessor\n}\n\n// HttpClient interface to abstract HTTP operations\ntype HttpClient interface {\n\tDo(req *http.Request) (*http.Response, error)\n}\n\n// RequestSender interface abstracts request sending behavior\ntype RequestSender interface {\n\tSendRequestBody(url, token string, requestBody *RequestBody) (*http.Response, error)\n}\n\n// NewDefaultClient initializes a new Client instance with default implementations\nfunc NewDefaultClient(password, url string, client *http.Client) *Client {\n\treturn &Client{\n\t\tPassword:          password,\n\t\tBaseURL:           url,\n\t\tHttpClient:        client,\n\t\tRequestSender:     NewDefaultRequestSender(client),\n\t\tResponseProcessor: NewResponseProcessor(),\n\t}\n}\n\n// NewGZipClient initializes a new Client instance with GZip compression for requests\nfunc NewGZipClient(password, url string, client *http.Client) *Client {\n\treturn &Client{\n\t\tPassword:          password,\n\t\tBaseURL:           url,\n\t\tHttpClient:        client,\n\t\tRequestSender:     NewGZipRequestSender(client),\n\t\tResponseProcessor: NewResponseProcessor(),\n\t}\n}\n\n// SendRequest sends the prompt and definition, and returns the parsed response\nfunc (c *Client) SendRequest(prompt string, definition *jsonSchema.Definition) (*Response, error) {\n\trequestBody := &RequestBody{\n\t\tPrompt:     prompt,\n\t\tDefinition: definition,\n\t}\n\n\t// Use the RequestSender to send the request\n\tresp, err := c.RequestSender.SendRequestBody(c.BaseURL, c.Password, requestBody)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Process the response\n\treturn c.ResponseProcessor.ProcessResponse(resp)\n}\n","reason":"Modified","start":1,"end":66,"grade":"A"}]},"hash":"004fc68a471ef7050927108147c9af6c88f958cb032dc64873edebd28ac9afb3","id":"eJzdVclu2zAQ/ZWpDoFsKNLdQC6pgaZA0BpZLoUuDDWS2EgkQ45qpEH+veCiLU6B9tBLdZE1y+ObeTP0S8KsRWuFbO6U6pJdcvv1+vM+yRKuKvyoJKGkZJdoxh9Zg8A7gZJKWUrRa2UI0lKWVCYSqWiJdJk4n7M0gtrhIeeqL2phkLei1+fKNEWjzm31WHy3St7yFnvmcjYurSjgo8cHg1YracVDh1ArA63qKiEbeGAWgStZi2YwjISSwGQFFWqUFUou0JaSnjWOQJbMwAleHKcDs/aoTAXTY8kI2TjfJbN4f3MN7/muiHSEi89scf4bfBrQ0q2jYLx/ZQkhvh48GMXRWmXgxFLK19iDxXlCEpqacQRSwB4sGcYJru7uDqA0hg6MFb+b5gvfq9TgE2ydQHnktoF0/A5EMkBjlNnMPNZ1zZgjDwsmRIBFGeTBlv0QrhbP6HcAnpSzxoBLVT2ng+kyIPWIMrY+G+GdG7aL2D/g/gWPe6zZ0NHUEkGCdeInWmAg8QiTwxKTHOEoqIUqJIHodYc9ShpbXA+Sn6CmOo5UBoPpJt5hSWK/Q+QGtvE8X7xBGoyEs2Dzpnk+d/MQTvghIk7pIsCdG52z/pM/EIn+lRohZK5n5UxD3mZKfDOqO5d4Yk1D/OtKhE/fhP47BVwGcNVr464lJf3+x0lY6DAD/wciuGL+iQKLJfNLaoFaBG1UrynenLXXRcnMf4eexDBmLFbjXYyx9ykfu7hZwqcRdGz/DAzb+arP95PZLfHb/R11mdd+dwFni80fRfJnhfaFc2OjZvjdsrTYFfcqCri36OtbX0+kfIe8JzIIZKz29BwVnq9y8rd3GM/jcGTA88M0louC3P8cidoDfrgAKTqINcVplKLzx60pR4kjuVGPKYnnJ7OQx1+jI3Vp4YJMsqQWHR4YtckuCZNWhFfeqOT1Fxx27Ls="}
