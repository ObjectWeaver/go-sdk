{"assessingTool":"Complexity","filePath":"jsonSchema/toolModel.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:11:13.290Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"linesOfCode","violatingCode":"The SubordinateFunction struct is concise, but the linesOfCode principle is undermined by embedding a pointer to another complex type, which can lead to hidden verbosity and maintenance challenges.\n\n```go\ntype SubordinateFunction struct {\n\tName       string      `json:\"name\"`\n\tDefinition *Definition `json:\"definition\"`\n}\n```","codeResolution":"The current implementation can be streamlined by delegating the operation logic to an abstraction, reducing lines of code and improving maintainability. Replace the original block with the following concise approach:\n\n```go\n// Go\nfunc ExecuteOperation(opType string, a, b int) int {\n\top := getOperation(opType)\n\treturn op.Apply(a, b)\n}\n```","severity":"Critical","rationale":"This implementation disregards linesOfCode best practices by combining data structure definition and documentation in a single block (lines 3–10). While concise, this approach can hinder maintainability as future changes to the struct or its comments may introduce inconsistencies. Additionally, the lack of separation between concerns (e.g., no validation or constructor logic) means any expansion will likely increase code complexity and line count, making the code harder to test and refactor. Adhering to linesOfCode principles—such as modularizing responsibilities and minimizing unnecessary lines—would improve clarity and scalability.","lineStart":3,"lineEnd":5,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The SubordinateFunction struct is simple and does not violate cyclomaticComplexity principles; there is no branching logic present.\n\n```go\ntype SubordinateFunction struct {\n\tName       string      `json:\"name\"`\n\tDefinition *Definition `json:\"definition\"`\n}\n```","codeResolution":"The solution for cyclomatic complexity involves refactoring deeply nested or multi-branch logic into simple, single-responsibility abstractions. Here is the replacement code for the block identified in `violatingCode`, assuming all helper abstractions are already defined:\n\n```go\n// Go\nop := getOperation(subordinateFunc.Name)\nresult := op.Execute(subordinateFunc.Definition)\nreturn result\n```","severity":"Critical","rationale":"High cyclomatic complexity in this code would make future changes risky and error-prone. If the SubordinateFunction struct or its usage involved deeply nested logic or multiple branching paths, it would be difficult to test all scenarios, increasing the likelihood of missed edge cases and bugs. Excessive complexity also hinders readability, making onboarding and code reviews harder. By simplifying control flow and breaking logic into smaller, focused functions, maintainability and correctness are improved, and the risk of regressions is reduced.","lineStart":7,"lineEnd":6,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The SubordinateFunction struct is simple and does not violate nestingDepth principles; there are no nested control structures present.\n\n```go\ntype SubordinateFunction struct {\n\tName       string      `json:\"name\"`\n\tDefinition *Definition `json:\"definition\"`\n}\n```","codeResolution":"Reducing nesting depth in SubordinateFunction logic improves readability and maintainability by delegating responsibilities to helper abstractions.\n\n```go\n// Instead of deeply nested logic, delegate to a helper for validation and processing.\nfunc (sf *SubordinateFunction) Process() error {\n\tif err := validateDefinition(sf.Definition); err != nil {\n\t\treturn err\n\t}\n\treturn processResponses(sf.Name, sf.Definition)\n}\n```","severity":"Critical","rationale":"Excessive nestingDepth in this code can make future changes error-prone and difficult to test. If logic for handling subordinate functions is deeply nested (e.g., multiple if-else or switch statements within methods), it increases cognitive load and obscures the core functionality. This reduces readability and maintainability, making it harder for developers to trace bugs or extend features. Flattening the structure—such as using guard clauses or splitting responsibilities into smaller functions—would improve clarity and reliability.","lineStart":1,"lineEnd":7,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode fails to separate responsibilities, resulting in a single struct definition with no supporting functions or methods.\n\n```go\ntype SubordinateFunction struct {\n\tName       string      `json:\"name\"`\n\tDefinition *Definition `json:\"definition\"`\n}\n```","codeResolution":"The SubordinateFunction struct's handling can be improved by delegating schema validation and response formatting to dedicated functions, enhancing separation of concerns and maintainability.\n\n```go\n// Improved usage of SubordinateFunction with abstraction\nfunc (sf *SubordinateFunction) Process(input interface{}) (interface{}, error) {\n\tif err := validateDefinition(sf.Definition, input); err != nil {\n\t\treturn nil, err\n\t}\n\treturn formatResponse(sf.Name, input), nil\n}\n```","severity":"Critical","rationale":"This code violates functionMethodCounts principles by defining only a single struct and no functions or methods. Without dedicated functions for tasks like validation, serialization, or business logic, the code becomes difficult to extend and maintain. The absence of methods means that any future logic will likely be added in a monolithic fashion, increasing the risk of errors and making unit testing challenging. Introducing separate methods for responsibilities such as schema validation or JSON marshaling would improve modularity and maintainability.","lineStart":5,"lineEnd":5,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A","readability":"A","testability":"A-"},"issues":{"cyclomaticComplexity":1,"dependenciesModules":0,"functionMethodCounts":1,"linesOfCode":8,"nestingDepth":1}},"hash":"f9d20818d128085cef8a9f9021d4f2ef55931756a808d9ce9cb272e358df1f3f","id":"eJxtkDFrw0AMhf+K0FIoJt69lZRCh5ZCMt6Q651sX3uWzEmGhpD/XuzGSYZqEkL63ns6oVcl1cTdXiRjg1sZxkw/yY5YYZBIW2EjNmxw9OHbdwRfKrwLPQ3eseO6ht30KSUm9kYvEwdLwlBoLKTEpuChXacTRypgPcHT64NCELYiuYLEIU8xcQfJFNgPVEGkNnGazyrwHKGQjsJKunFsx5H+lVUrUzA4OXb27geCv1IrM3ypw+y/cTirODxcNuoa9j0t0iDtYlFv/GuCzQx+vjqDx7t+Bd+Mz/gLWJeH3YVaVe7IZ8dYYZsyfXjrscHbp2sTyW8SKW86wfMvD7mciA=="}
{"assessingTool":"Complexity","filePath":"jsonSchema/toMap.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:11:11.809Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode fails functionMethodCounts by placing all logic into a single method, making it difficult to maintain and extend.\n\n```go\nfunc (d Definition) ToMap() map[string]interface{} {\n\tresult := make(map[string]interface{})\n\t// ... all conversion logic is here ...\n\treturn result\n}\n```","codeResolution":"The ToMap method in the Definition struct centralizes multiple responsibilities, making the code harder to maintain and extend. Refactoring is needed to delegate each conversion step to specialized helper functions, improving separation of concerns and readability.\n\n```go\n// Improved ToMap using helper abstractions\nfunc (d Definition) ToMap() map[string]interface{} {\n\tresult := make(map[string]interface{})\n\taddType(result, d.Type)\n\taddInstruction(result, d.Instruction)\n\taddProperties(result, d.Properties)\n\taddItems(result, d.Items)\n\taddModel(result, d.Model)\n\taddProcessingOrder(result, d.ProcessingOrder)\n\treturn result\n}\n```","severity":"Critical","rationale":"The code defines only one function, ToMap, which handles all logic for converting a Definition to a map. This violates functionMethodCounts principles by combining multiple responsibilities—such as handling properties, items, and metadata—into a single method. Such monolithic design makes the code harder to maintain, test, and extend. For example, changes to how properties are processed would require modifying ToMap directly, increasing the risk of introducing bugs. Splitting logic into smaller, focused functions (e.g., separate methods for properties and items) would improve modularity and maintainability.","lineStart":3,"lineEnd":22,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The ToMap function contains excessive vertical repetition and deep nesting, resulting in unnecessarily high linesOfCode and reduced maintainability.\n\n```go\nif d.Properties != nil && len(d.Properties) > 0 {\n\tpropertiesMap := make(map[string]interface{})\n\tfor key, value := range d.Properties {\n\t\tpropertiesMap[key] = value.ToMap()\n\t}\n}\n```","codeResolution":"The ToMap function can be streamlined by delegating property and item conversions to helper abstractions, reducing lines of code and improving clarity.\n\n```go\nfunc (d Definition) ToMap() map[string]interface{} {\n\tresult := make(map[string]interface{})\n\tsetIfNotEmpty(result, \"type\", d.Type)\n\tsetIfNotEmpty(result, \"instruction\", d.Instruction)\n\tsetIfNotNil(result, \"properties\", convertProperties(d.Properties))\n\tsetIfNotNil(result, \"items\", convertItem(d.Items))\n\tsetIfNotEmpty(result, \"model\", d.Model)\n\tsetIfNotEmptySlice(result, \"processingOrder\", d.ProcessingOrder)\n\treturn result\n}\n```","severity":"Critical","rationale":"The rationale for linesOfCode in this snippet centers on maintainability and clarity. The function is lengthy and contains repeated conditional blocks, which increases the cognitive load for future readers and maintainers. For example, the repeated pattern of checking fields and populating the map could be abstracted or split into helper functions, reducing duplication and improving readability. Excess lines also make unit testing and debugging harder, as logic is tightly coupled in a single function. Streamlining the code would enhance maintainability and reduce the risk of errors.","lineStart":7,"lineEnd":18,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The ToMap function disregards cyclomatic complexity principles by using multiple nested conditionals and loops, making the code harder to test and maintain.\n\n```go\nif d.Properties != nil && len(d.Properties) > 0 {\n\tpropertiesMap := make(map[string]interface{})\n\tfor key, value := range d.Properties {\n\t\tpropertiesMap[key] = value.ToMap()\n\t}\n}\n```","codeResolution":"The ToMap function’s cyclomatic complexity can be reduced by delegating property and item mapping to helper functions, improving readability and maintainability.\n\n```go\n// Improved ToMap using helper abstractions for properties and items\nfunc (d Definition) ToMap() map[string]interface{} {\n\tresult := make(map[string]interface{})\n\taddBasicFields(result, d)\n\taddProperties(result, d.Properties)\n\taddItems(result, d.Items)\n\treturn result\n}\n```","severity":"Critical","rationale":"The cyclomatic complexity in this function is elevated due to multiple independent conditional branches (lines 6–22), each checking different struct fields. This increases the number of possible execution paths, making the code harder to maintain and test. If new fields are added, the complexity will grow linearly, further impacting readability and maintainability. Refactoring by grouping related conditions or extracting logic into helper functions would reduce complexity, improve testability, and make future changes less error-prone.","lineStart":13,"lineEnd":22,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The ToMap function exhibits excessive nestingDepth, making the logic harder to follow and maintain.\n\n```go\nif d.Properties != nil && len(d.Properties) > 0 {\n    propertiesMap := make(map[string]interface{})\n    for key, value := range d.Properties {\n        propertiesMap[key] = value.ToMap()\n    }\n    result[\"properties\"] = propertiesMap\n}\n```","codeResolution":"The ToMap function’s nesting can be reduced by extracting property and item conversions into helper functions, resulting in clearer, flatter code:\n\n```go\n// Replacement for the deeply nested block in ToMap\nif d.Properties != nil && len(d.Properties) > 0 {\n\tresult[\"properties\"] = convertProperties(d.Properties)\n}\nif d.Items != nil {\n\tresult[\"items\"] = convertItem(d.Items)\n}\n```","severity":"Critical","rationale":"The nesting depth in this implementation is moderate, but the repeated use of nested if-statements and a for-loop inside another if-statement (lines 10–18) increases cognitive complexity. This structure makes the function harder to read and maintain, especially as more fields are added. Deep nesting can obscure the core logic, making future changes error-prone and unit testing more difficult. Refactoring with guard clauses or splitting responsibilities into helper functions would flatten the structure, improving maintainability and reducing the risk of bugs.","lineStart":9,"lineEnd":22,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A","testability":"A-"},"issues":{"cyclomaticComplexity":6,"dependenciesModules":0,"functionMethodCounts":1,"linesOfCode":32,"nestingDepth":3}},"hash":"02ebbcd8ecf0adfb023a3d2fecbe49760f950b857bfc2b228804759413df7689","id":"eJyFk81uwjAQhF9l6wNKJAQ9I9ELvfSAilRumIOVbIJLsrbsDWqE8u6VCfmjrXpMdubbzNi5CuU9eq8p3xtTiJXYmNIW+KW5FnORmBQ3hhiJxUpYlZxVjvDpDX0kJyyVJEnLJezNVllIDF3QsQc+IbxipkmzNgSeXZUwsAEFpbLg0Dr0SKzCWFJWUQJROrLELTGKg/7g2WnKj5oYXaYSvDZwlSTZoa8KhtUaSnXG6HdpHD5Rss4gXexri/C0BimkaBEd5CAF1xalOML6Lgzjpre+UZsi5PmLoAdNBxrZprydMxYda/QBR7qA2QwKpGg8iuEFnrs1tn8duv4/NEvOjIMz1nO4qKLC4HGKcpyuv+MfFhzOWIcIN+fifhqtsnmIPfja1BPOQ4uMZR/4R31h2BcXHsZ7B8jWpFj8eQhlmHaUm3Ts7htO2jv/7lJ0k5rHscaiDvng7eC368iVI2gBkhpJYi4yXeBO8UmsxPDXLDnkWuRGNN+4HkV5"}
{"assessingTool":"Complexity","filePath":"jsonSchema/toJson.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:11:09.043Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode contains only one function, causing all responsibilities to be handled within a single method and violating functionMethodCounts best practices.\n\n```go\nfunc (d Definition) MarshalJSON() ([]byte, error) {\n\tif d.Properties == nil {\n\t\td.Properties = make(map[string]Definition)\n\t}\n\ttype Alias Definition\n\treturn json.Marshal(struct {\n\t\tAlias\n\t}{\n\t\tAlias: (Alias)(d),\n\t})\n}\n```","codeResolution":"The MarshalJSON method should delegate property initialization to a dedicated helper, improving separation of concerns and functionMethodCounts:\n\n```go\npackage jsonSchema\n\nimport \"encoding/json\"\n\nfunc (d Definition) MarshalJSON() ([]byte, error) {\n\tinitializeProperties(&d)\n\ttype Alias Definition\n\treturn json.Marshal(struct {\n\t\tAlias\n\t}{\n\t\tAlias: (Alias)(d),\n\t})\n}\n```","severity":"Critical","rationale":"This code violates functionMethodCounts principles by placing all logic within a single method, `MarshalJSON`. With no separation of concerns, future changes or bug fixes will require editing this monolithic function, increasing the risk of introducing errors. The lack of helper functions makes unit testing difficult, as individual behaviors cannot be isolated. Maintainability suffers because developers must understand the entire method to make even minor changes. Refactoring to extract property initialization and JSON marshaling into separate functions would improve clarity and testability.","lineStart":3,"lineEnd":10,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code adheres to dependenciesModules principles, using only the standard \"encoding/json\" package without introducing unnecessary dependencies.\n\n```go\nimport \"encoding/json\"\n```","codeResolution":"The codeResolution introduces a cleaner approach to dependency management by leveraging existing abstractions for operations, ensuring modularity and separation of concerns.\n\n```go\n// Replaces direct logic with abstraction usage\nfunc (d Definition) MarshalJSON() ([]byte, error) {\n\top := getOperation(\"marshalJSON\")\n\treturn op.Execute(d)\n}\n```","severity":"Critical","rationale":"This implementation adheres to dependenciesModules principles by only importing the standard \"encoding/json\" package, which is necessary for JSON marshaling. There are no unnecessary or redundant imports, reducing the risk of dependency bloat and improving maintainability. Keeping external dependencies minimal ensures better performance, easier upgrades, and fewer compatibility issues. However, if future features require additional packages, care should be taken to evaluate their necessity to avoid complicating the codebase.","lineStart":1,"lineEnd":7,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The MarshalJSON method unnecessarily increases nestingDepth by embedding logic for property initialization and type aliasing within a single function.\n\n```go\nif d.Properties == nil {\n\td.Properties = make(map[string]Definition)\n}\ntype Alias Definition\n```","codeResolution":"Reducing nesting depth in the MarshalJSON method improves readability and maintainability by using guard clauses and flattening control flow.\n\n```go\npackage jsonSchema\n\nimport \"encoding/json\"\n\nfunc (d Definition) MarshalJSON() ([]byte, error) {\n\tif d.Properties == nil {\n\t\td.Properties = make(map[string]Definition)\n\t}\n\treturn json.Marshal(struct{ Alias Definition }{Alias: d})\n}\n```","severity":"Critical","rationale":"This implementation does not address nestingDepth concerns, as the function contains multiple levels of nesting within a single scope. While the current depth is manageable, further logic additions could quickly increase complexity, making the code harder to read and maintain. Deeply nested structures hinder testability and increase the risk of subtle bugs, especially if future requirements expand the function. Refactoring with guard clauses or splitting responsibilities into smaller functions would improve maintainability and reduce cognitive load.","lineStart":6,"lineEnd":8,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The MarshalJSON function disregards cyclomaticComplexity principles by introducing unnecessary conditional logic that increases branching.\n\n```go\nif d.Properties == nil {\n\td.Properties = make(map[string]Definition)\n}\n```","codeResolution":"To address cyclomatic complexity, the solution refactors the conditional logic into a dedicated abstraction, simplifying the main function and improving maintainability.\n\n```go\nfunc (d Definition) MarshalJSON() ([]byte, error) {\n\tprepareProperties(&d)\n\treturn marshalAlias(d)\n}\n```","severity":"Critical","rationale":"This implementation does not address cyclomatic complexity, as the function contains a conditional branch that could be further decomposed. While the logic is simple now, adding more conditions or responsibilities would quickly make the code harder to maintain and test. High cyclomatic complexity increases the risk of hidden bugs and makes future changes error-prone. Refactoring to separate concerns—such as extracting the property initialization into its own function—would improve readability and maintainability, ensuring the code remains robust as it evolves.","lineStart":7,"lineEnd":10,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The MarshalJSON function unnecessarily increases linesOfCode by including redundant initialization and type aliasing.\n\n```go\nif d.Properties == nil {\n\td.Properties = make(map[string]Definition)\n}\ntype Alias Definition\n```","codeResolution":"The current MarshalJSON implementation can be streamlined to reduce lines of code and improve clarity by delegating property initialization to a helper and leveraging type aliasing more concisely.\n\n```go\nfunc (d Definition) MarshalJSON() ([]byte, error) {\n\tensurePropertiesInitialized(&d)\n\treturn json.Marshal((Alias)(d))\n}\n```","severity":"Critical","rationale":"This implementation overlooks linesOfCode best practices by embedding logic directly within the MarshalJSON method and using an inline struct for marshalling. While concise, this approach can hinder maintainability, as future changes to the marshalling logic or the Definition type may require edits in multiple places. For example, the initialization of d.Properties on line 4 could be refactored into a helper function to reduce repetition and improve clarity. Reducing tightly coupled logic and separating concerns would make the code easier to test and extend, ultimately improving maintainability and correctness.","lineStart":5,"lineEnd":10,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":1,"functionMethodCounts":1,"linesOfCode":16,"nestingDepth":1}},"hash":"5a6f206628ead7c3fbcb88dea8549dd6524faf6b0e5d26a8e0fa17e155a72e25","id":"eJxVkLFqw0AMhl9FaDqDSXZDhpJOgbaBdMtluNqyo8SWzJ0MNcHvXuy21F0k0Cfp/6UHhpQoJZbmXbXFAvfa9S19so2YY6kV7VWMxLDAPpT30BDcksqpvFIXvHjhrtdo4JGk1Iql2c7c48zqQUpwFTxTzcLGKhm8hJiuoT2c3l5dBu58+RiNcqAYNWbw8OKNa6g2x6g9RWNKsNuBcPvNvP1H0IU7uS7052SRpbmstOb+aQ429gRPLYe0sjKDSDZEWS7a/BhzyeJQ2q/aMrUsWhcKcEvOXJXlC828TF4wx5pbOga7YoF/j9qaHmaNRnH6AszWh8Y="}
{"assessingTool":"Complexity","filePath":"jsonSchema/model.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:11:05.425Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode exhibits excessive nesting within its struct definitions, making the code harder to read and maintain.\n\n```go\ntype Definition struct {\n\tProperties map[string]Definition `json:\"properties\"`\n\tItems *Definition `json:\"items,omitempty\"`\n\tHashMap *HashMap\n}\n```","codeResolution":"To address excessive nesting depth, the solution refactors deeply nested logic into clear, single-responsibility function calls, improving readability and maintainability.\n\n```go\n// Original deeply nested block:\nif def.Choices != nil && len(def.Choices.Options) > 0 {\n    // ...complex selection logic...\n}\n\n// Replacement using abstraction:\nif def.Choices != nil {\n    processChoices(def.Choices, def.Properties)\n}\n```","severity":"Critical","rationale":"Deep nesting within the `Definition` struct and related types can lead to code that is difficult to maintain and understand. For example, fields like `Properties` (which is a map of `Definition`), `Items` (pointer to `Definition`), and nested structs such as `HashMap` and `Focus` introduce multiple layers of indirection. This increases cognitive load for developers, making it harder to trace logic, debug, or extend functionality. Excessive nesting also complicates unit testing and can obscure bugs, as changes in one deeply nested field may have unintended side effects elsewhere. Flattening the structure or refactoring responsibilities into smaller, focused types would improve readability and maintainability.","lineStart":1,"lineEnd":82,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode suffers from excessive lines of code due to the Definition struct containing a large number of fields, many of which are rarely used and could be grouped or modularized for clarity and maintainability.\n\n```go\ntype Definition struct {\n\t// ...over 20 fields, many optional and loosely related...\n}\n```","codeResolution":"The codeResolution solution streamlines the handling of schema operations by delegating logic to a pre-defined abstraction, significantly reducing lines of code and improving maintainability.\n\n```go\n// Instead of manually processing schema operations, delegate to the abstraction:\noperation := getOperation(def.Type)\nresult := operation.Execute(def)\n```","severity":"Critical","rationale":"### Rationale\n\nThe code snippet demonstrates excessive lines of code within the `Definition` struct, primarily due to the large number of fields and verbose comments. This high LoC count negatively impacts maintainability, as future changes require navigating and understanding a sprawling structure (see lines 6–61). It also increases the risk of errors, such as mismatched field tags or overlooked dependencies. Refactoring by grouping related fields into smaller structs or leveraging composition would reduce LoC, improve readability, and make unit testing more manageable. Streamlining comments and removing redundant fields further enhances maintainability and correctness.","lineStart":1,"lineEnd":94,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The Definition struct disregards cyclomaticComplexity principles by including numerous optional fields and nested types, resulting in a highly complex and difficult-to-maintain design.\n\n```go\ntype Definition struct {\n\tProperties map[string]Definition `json:\"properties\"`\n\tItems *Definition `json:\"items,omitempty\"`\n\tTextToSpeech *TextToSpeech `json:\"textToSpeech,omitempty\"`\n\tSpeechToText *SpeechToText `json:\"speechToText,omitempty\"`\n\t// ...many more fields...\n}\n```","codeResolution":"The solution for cyclomaticComplexity involves refactoring deeply nested conditional logic into clear, single-responsibility function calls, reducing branching and improving maintainability.\n\n```go\n// Instead of nested if/else blocks for processing choices:\nif def.Choices != nil {\n    processChoices(def.Choices, def.Properties)\n}\n```","severity":"Critical","rationale":"The cyclomatic complexity in the `Definition` struct is high due to the large number of fields and nested types (lines 5–61). This increases the number of possible code paths when constructing, validating, or processing instances, making the code harder to maintain and test. Complex nested structures like `Properties map[string]Definition` and multiple pointer fields (e.g., `Items`, `SystemPrompt`, `HashMap`) further complicate logic in downstream usage. High complexity can lead to bugs, reduce readability, and make future changes risky. Refactoring into smaller, focused structs or using composition could improve maintainability and reduce cyclomatic complexity.","lineStart":1,"lineEnd":87,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A+","readability":"A-","testability":"A-"},"issues":{"cyclomaticComplexity":1,"dependenciesModules":0,"functionMethodCounts":0,"linesOfCode":103,"nestingDepth":3}},"hash":"728a6a2f070e59c1d0347a4b641dc2588b2ed1cce8c4f428cc3f9fac8c2f1255","id":"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"}
{"assessingTool":"Complexity","filePath":"grpc/object-generation_grpc.pb.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:11:03.203Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The violatingCode exhibits elevated cyclomatic complexity due to deeply nested error handling and type assertions within handler functions.\n\n```go\nfunc _JSONSchemaService_GenerateObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(RequestBody)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(JSONSchemaServiceServer).GenerateObject(ctx, in)\n\t}\n\t// ...\n}\n```","codeResolution":"The solution for cyclomatic complexity in this context replaces nested logic with clear delegation to helper abstractions, making the code easier to test and maintain.\n\n```go\n// Instead of handling all logic inline, delegate to helper functions.\nfunc (s *serverImpl) GenerateObject(ctx context.Context, req *RequestBody) (*Response, error) {\n\tif !validateRequest(req) {\n\t\treturn nil, status.Error(codes.InvalidArgument, \"invalid request\")\n\t}\n\treturn generateFromSchema(req.Schema)\n}\n```","severity":"Critical","rationale":"Cyclomatic complexity is important because it directly impacts code maintainability and testability. In the provided code, most functions (e.g., `GenerateObject`, `StreamGeneratedObjects`, and their handlers) have low complexity, with minimal branching and straightforward control flow. This makes the code easier to understand, modify, and test. If complexity were higher—such as deeply nested conditionals or multiple decision points—future changes would risk introducing bugs and make unit testing more difficult. Keeping cyclomatic complexity low, as seen here, ensures the codebase remains robust and easier to extend.","lineStart":97,"lineEnd":143,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode exhibits excessive nestingDepth, particularly in handler functions where control flow is deeply layered and difficult to follow.\n\n```go\nif interceptor == nil {\n\treturn srv.(JSONSchemaServiceServer).GenerateObject(ctx, in)\n}\ninfo := &grpc.UnaryServerInfo{\n\tServer:     srv,\n\tFullMethod: JSONSchemaService_GenerateObject_FullMethodName,\n}\nhandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\treturn srv.(JSONSchemaServiceServer).GenerateObject(ctx, req.(*RequestBody))\n}\nreturn interceptor(ctx, in, info, handler)\n```","codeResolution":"The codeResolution for nestingDepth focuses on flattening the control flow in the handler by delegating logic to helper functions, reducing the maximum nesting level and improving readability.\n\n```go\nfunc (s *serverImpl) GenerateObject(ctx context.Context, req *RequestBody) (*Response, error) {\n\tif !validateRequest(req) {\n\t\treturn nil, status.Error(codes.InvalidArgument, \"invalid request\")\n\t}\n\treturn processGeneration(ctx, req)\n}\n```","severity":"Critical","rationale":"Deep nesting in several handler functions (e.g., `_JSONSchemaService_GenerateObject_Handler` and `_JSONSchemaService_StreamGeneratedObjects_Handler`) increases cognitive complexity and makes the code harder to maintain and test. For example, lines with multiple nested `if` statements and inline anonymous functions (see lines 97–110) bury core logic within several layers, which can obscure error handling and business logic. Excessive nesting also complicates future modifications and debugging, as developers must trace through multiple levels to understand the flow. Refactoring with guard clauses or splitting responsibilities into smaller functions would improve readability and maintainability.","lineStart":94,"lineEnd":129,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode contains a high number of function and method definitions, but most are thin wrappers or generated stubs, resulting in minimal separation of responsibilities and limited maintainability.\n\n```go\nfunc (UnimplementedJSONSchemaServiceServer) GenerateObject(context.Context, *RequestBody) (*Response, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method GenerateObject not implemented\")\n}\n```","codeResolution":"The code’s functionMethodCounts can be improved by refactoring monolithic handler logic into smaller, purpose-driven functions. Here’s how the main handler block should be replaced to delegate responsibilities:\n\n```go\nfunc (s *JSONSchemaServiceServerImpl) GenerateObject(ctx context.Context, req *RequestBody) (*Response, error) {\n\tif err := validateRequest(req); err != nil {\n\t\treturn nil, err\n\t}\n\treturn processGeneration(ctx, req)\n}\n```\nThis approach separates validation and processing, enhancing maintainability and clarity.","severity":"Critical","rationale":"This code adheres well to functionMethodCounts principles, with clear separation of responsibilities across multiple functions and methods (e.g., `GenerateObject`, `StreamGeneratedObjects`, handler functions, and registration logic). This modularity improves maintainability, as each function is focused and easier to test or update independently. If the code had fewer, monolithic functions, it would be harder to extend or debug, and changes could introduce subtle bugs. By distributing logic across well-named, single-purpose functions, the code remains robust and scalable, supporting future enhancements with minimal risk.","lineStart":41,"lineEnd":110,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode exhibits excessive lines of code due to repeated boilerplate and verbose handler implementations, making it difficult to maintain and refactor.\n\n```go\nfunc _JSONSchemaService_GenerateObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(RequestBody)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(JSONSchemaServiceServer).GenerateObject(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: JSONSchemaService_GenerateObject_FullMethodName,\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(JSONSchemaServiceServer).GenerateObject(ctx, req.(*RequestBody))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n```","codeResolution":"The codeResolution for linesOfCode focuses on reducing repetition and improving clarity by delegating object generation logic to a dedicated abstraction. Replace the original block with the following concise usage:\n\n```go\n// Go\nfunc (s *serverImpl) GenerateObject(ctx context.Context, req *RequestBody) (*Response, error) {\n\treturn getObjectGenerator().Generate(ctx, req)\n}\n```","severity":"Critical","rationale":"## Rationale\n\nThe code snippet contains a high number of lines of code due to repeated boilerplate, verbose type definitions, and duplicated handler logic (e.g., lines 41–56, 59–74, 77–94, 97–112). Excessive LoC increases cognitive load, making the code harder to maintain and review. It also raises the risk of introducing subtle bugs when updating similar blocks. Reducing LoC by consolidating repeated patterns and extracting shared logic into helper functions would improve maintainability and readability without sacrificing correctness or performance.","lineStart":22,"lineEnd":109,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The violatingCode tightly couples the implementation to several external gRPC dependencies, making future maintenance and portability challenging.\n\n```go\nimport (\n\tcontext \"context\"\n\tgrpc \"google.golang.org/grpc\"\n\tcodes \"google.golang.org/grpc/codes\"\n\tstatus \"google.golang.org/grpc/status\"\n)\n```","codeResolution":"The code demonstrates a solid approach to managing dependencies by only importing essential gRPC and context packages, keeping the module footprint minimal and focused.\n\n```go\n// Replacement for direct grpc imports and usage:\nimport (\n\tcontext \"context\"\n\tgrpc \"google.golang.org/grpc\"\n)\n\n// Use the Operation abstraction for service calls:\nresult, err := getOperation(\"GenerateObject\").Execute(ctx, requestBody)\n```","severity":"Critical","rationale":"The code imports several external dependencies (lines 7–11), specifically from the gRPC ecosystem. While these are necessary for generated gRPC code, excessive reliance on tightly coupled, version-specific packages (e.g., `grpc.SupportPackageIsVersion9` on line 16) can hinder maintainability and future upgrades. If any of these packages change APIs or are deprecated, the code may break or require significant refactoring. Additionally, using aliased imports (e.g., `context \"context\"`) can reduce clarity for new contributors. Streamlining imports and minimizing unnecessary dependencies would improve maintainability and reduce the risk of compatibility issues.","lineStart":6,"lineEnd":8,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A-","testability":"A"},"issues":{"cyclomaticComplexity":13,"dependenciesModules":4,"functionMethodCounts":16,"linesOfCode":172,"nestingDepth":2}},"hash":"aa52fe695b40be9ac14ee915b9d8db0b86dcf3ccd7b47f1cd7df87628a24fcfc","id":"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"}
{"assessingTool":"Complexity","filePath":"grpc/object-generation.pb.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:11:00.497Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependenciesModules","violatingCode":"The violatingCode demonstrates poor dependenciesModules discipline by importing more packages than necessary, including unused and redundant dependencies.\n\n```go\nimport (\n\tprotoreflect \"google.golang.org/protobuf/reflect/protoreflect\"\n\tprotoimpl \"google.golang.org/protobuf/runtime/protoimpl\"\n\t_ \"google.golang.org/protobuf/types/known/anypb\"\n\tstructpb \"google.golang.org/protobuf/types/known/structpb\"\n\treflect \"reflect\"\n\tsync \"sync\"\n)\n```","codeResolution":"The codeResolution for dependenciesModules focuses on simplifying and clarifying the import structure by removing unused or redundant dependencies, ensuring only necessary modules are included. This improves maintainability and reduces build complexity.\n\n```go\nimport (\n\tprotoreflect \"google.golang.org/protobuf/reflect/protoreflect\"\n\tprotoimpl \"google.golang.org/protobuf/runtime/protoimpl\"\n\tstructpb \"google.golang.org/protobuf/types/known/structpb\"\n)\n```","severity":"Critical","rationale":"The code imports a large number of external dependencies (lines 8–14), including several protobuf-related packages and standard library modules. While these are required for generated code, excessive or unnecessary imports can complicate dependency management, increase build times, and make the codebase harder to maintain. For example, importing unused packages (such as the blank import on line 12) adds clutter and may confuse future maintainers. Streamlining imports to only those strictly necessary improves clarity, reduces the risk of version conflicts, and enhances maintainability.","lineStart":9,"lineEnd":18,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode disregards linesOfCode principles by generating excessive boilerplate and repetitive getter methods for every field, resulting in unnecessary verbosity.\n\n```go\nfunc (x *Definition) GetType() string {\n\tif x != nil {\n\t\treturn x.Type\n\t}\n\treturn \"\"\n}\n```","codeResolution":"The codeResolution for linesOfCode focuses on reducing boilerplate and improving maintainability by replacing repetitive getter logic with a concise helper. For example, all the `GetX` methods in the `Definition` struct can be replaced with a generic accessor:\n\n```go\n// Go\nfunc (x *Definition) Get(field string) any {\n\tswitch field {\n\tcase \"Type\":\n\t\treturn x.Type\n\tcase \"Instruction\":\n\t\treturn x.Instruction\n\tcase \"Properties\":\n\t\treturn x.Properties\n\t// ...add cases for other fields as needed\n\tdefault:\n\t\treturn nil\n\t}\n}\n```\n\nThis approach eliminates dozens of nearly identical getter methods, streamlining the codebase and reducing lines of code.","severity":"Critical","rationale":"The code violates linesOfCode best practices by generating an extremely high number of non-comment, non-blank lines, much of which is boilerplate from protoc-gen-go. For example, each message type (e.g., `Definition`, `TextToSpeech`, `SpeechToText`) includes repetitive getter methods and reset logic (see lines defining `GetType`, `GetInstruction`, etc.), which inflates the codebase. Excessive LoC like this makes the code harder to maintain, increases cognitive load for future changes, and can slow down code reviews and refactoring. Reducing redundancy—such as consolidating similar getter logic or leveraging code generation options to minimize output—would improve maintainability and clarity.","lineStart":44,"lineEnd":678,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode exhibits excessive nestingDepth, especially in the repeated use of nested if statements within getter methods, which reduces readability and maintainability.\n\n```go\nfunc (x *Definition) GetType() string {\n\tif x != nil {\n\t\treturn x.Type\n\t}\n\treturn \"\"\n}\n```","codeResolution":"The codeResolution for nestingDepth focuses on flattening deep conditional logic by delegating responsibility to helper functions, resulting in clearer and more maintainable code.\n\n```go\n// Instead of deeply nested checks, use guard clauses and helper functions:\nif !isValidDefinition(def) {\n\treturn nil\n}\nif !isSupportedType(def.Type) {\n\treturn nil\n}\nprocessDefinition(def)\n```","severity":"Critical","rationale":"The code’s nesting depth is problematic, especially in the `Definition` struct and its related methods. For example, the recursive nature of `Properties map[string]*Definition` and `Items *Definition` (lines 22–24) means that any logic operating on these fields will likely require deeply nested loops or conditionals to traverse or manipulate the data. This increases cognitive load, makes the code harder to maintain, and complicates debugging and testing. Excessive nesting can also degrade performance due to stack growth in recursive calls. Refactoring to flatten data structures or using iterative traversal patterns would improve maintainability and reduce the risk of errors.","lineStart":81,"lineEnd":425,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The violatingCode exhibits excessive cyclomatic complexity due to deeply nested conditional logic and repetitive guard clauses across multiple getter methods.\n\n```go\nfunc (x *Definition) GetType() string {\n\tif x != nil {\n\t\treturn x.Type\n\t}\n\treturn \"\"\n}\n```","codeResolution":"Cyclomatic complexity is reduced by refactoring nested logic into dedicated helper functions, making the code easier to test and maintain. Here is the replacement code for the identified block:\n\n```go\nif d.TextToSpeech != nil {\n\tprocessTextToSpeech(d.TextToSpeech)\n}\nif d.SpeechToText != nil {\n\tprocessSpeechToText(d.SpeechToText)\n}\nif d.Image != nil {\n\tprocessImage(d.Image)\n}\n```","severity":"Critical","rationale":"Cyclomatic complexity is a concern in this code because the `Definition` struct (lines 18–49) contains a large number of fields, many of which are nested types or maps to other complex types. This design increases the number of possible code paths when interacting with or validating a `Definition` instance, making the logic harder to follow and test. High complexity here can lead to maintainability issues, as future changes may introduce subtle bugs or require extensive refactoring. Breaking down the structure into smaller, focused components or using composition would reduce complexity and improve code clarity.","lineStart":41,"lineEnd":383,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode disregards functionMethodCounts principles by defining an excessive number of getter methods for each field, resulting in unnecessary boilerplate and reduced maintainability.\n\n```go\nfunc (x *Definition) GetType() string {\n\tif x != nil {\n\t\treturn x.Type\n\t}\n\treturn \"\"\n}\n```","codeResolution":"The codeResolution for functionMethodCounts should refactor monolithic logic into smaller, purpose-driven functions to improve maintainability and clarity. Here is how the main block should be replaced to delegate responsibilities:\n\n```go\n// Instead of handling everything in one method:\nfunc (x *Definition) Process() {\n\tif !validateDefinition(x) {\n\t\treturn\n\t}\n\tprocessProperties(x.Properties)\n\tprocessItems(x.Items)\n}\n```\n\nThis approach separates validation and processing, allowing each function to focus on a single responsibility.","severity":"Critical","rationale":"The code violates functionMethodCounts principles by generating a large number of trivial getter methods (e.g., `GetType`, `GetInstruction`, `GetProperties`, etc.) for each field in every struct, rather than encapsulating logic or responsibilities. This leads to bloated code, making maintenance and navigation difficult. The lack of meaningful, responsibility-driven functions means future changes require edits across many repetitive methods, increasing the risk of errors and reducing testability. Refactoring to group related logic into cohesive methods would improve maintainability and correctness.","lineStart":37,"lineEnd":417,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A-","qualityDesign":"A+","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":7,"functionMethodCounts":21,"linesOfCode":1311,"nestingDepth":2}},"hash":"4136c2642dea364c20621e067baef2f5fce805c23037f2874091e5107d6dc5f0","id":"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"}
{"assessingTool":"SOLID","filePath":"jsonSchema/toMap.go","grade":"C+","username":"HLamb","timestamp":"2025-10-12T17:10:56.521Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"openClosed","violatingCode":"The ToMap function violates openClosed by requiring modification whenever new Definition fields are added.\n\n```go\nif d.Model != \"\" {\n    result[\"model\"] = d.Model\n}\nif len(d.ProcessingOrder) > 0 {\n    result[\"processingOrder\"] = d.ProcessingOrder\n}\n```","codeResolution":"The current ToMap method can be refactored to utilize an Operation abstraction, allowing new mapping behaviors to be added without modifying this function.\n\n```go\ngo\nfunc (d Definition) ToMap() map[string]interface{} {\n\top := getOperation(\"definitionToMap\")\n\treturn op.Execute(d)\n}\n```","severity":"High","rationale":"The current implementation tightly couples the conversion logic to the Definition struct’s fields, violating the Open/Closed Principle. Any addition of new fields to Definition requires modifying the ToMap function directly (e.g., adding new if statements for each field). This approach reduces maintainability, as future changes force edits to existing code, increasing the risk of introducing bugs. It also limits extensibility, since developers cannot add new behaviors without altering core logic. Refactoring to use interfaces or reflection could allow new fields to be handled automatically, improving adherence to openClosed and making the codebase easier to extend and maintain.","lineStart":1,"lineEnd":22,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The ToMap method directly constructs and returns a map without any abstraction or interface, violating dependency inversion by tightly coupling the conversion logic to the Definition struct.\n\n```go\nfunc (d Definition) ToMap() map[string]interface{} {\n\tresult := make(map[string]interface{})\n\t// ...\n\treturn result\n}\n```","codeResolution":"The ToMap method should delegate property conversion to an injected abstraction, promoting dependency inversion and testability.\n\n```go\n// Go\nif d.Properties != nil && len(d.Properties) > 0 {\n    propertiesMap := make(map[string]interface{})\n    for key, value := range d.Properties {\n        propertiesMap[key] = propertyConverter.Convert(value)\n    }\n    result[\"properties\"] = propertiesMap\n}\n```","severity":"Critical","rationale":"This implementation tightly couples the ToMap logic directly to the Definition struct, violating dependency inversion principles. By embedding conversion logic within the struct, it becomes difficult to extend or test alternative mapping strategies without modifying the core type. This reduces maintainability and flexibility, as any changes to mapping behavior require direct changes to Definition. Introducing an abstraction, such as a Mapper interface, would decouple the conversion logic, making the codebase easier to test, extend, and maintain.","lineStart":1,"lineEnd":22,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"C-","singleResponsibilityScore":"A-"},"codeDiff":{"changes":[{"newCode":"package jsonSchema\n\n// ToMap converts the Definition struct to a map representation\nfunc (d Definition) ToMap() map[string]interface{} {\n\tresult := make(map[string]interface{})\n\n\tif d.Type != \"\" {\n\t\tresult[\"type\"] = d.Type\n\t}\n\tif d.Instruction != \"\" {\n\t\tresult[\"instruction\"] = d.Instruction\n\t}\n\tif d.Properties != nil && len(d.Properties) > 0 {\n\t\tpropertiesMap := make(map[string]interface{})\n\t\tfor key, value := range d.Properties {\n\t\t\tpropertiesMap[key] = value.ToMap()\n\t\t}\n\t\tresult[\"properties\"] = propertiesMap\n\t}\n\tif d.Items != nil {\n\t\tresult[\"items\"] = d.Items.ToMap()\n\t}\n\tif d.Model != \"\" {\n\t\tresult[\"model\"] = d.Model\n\t}\n\tif len(d.ProcessingOrder) > 0 {\n\t\tresult[\"processingOrder\"] = d.ProcessingOrder\n\t}\n\n\treturn result\n}\n","reason":"Modified","start":1,"end":32,"grade":"C+"}]},"hash":"d7b582b5fb54d1d7c1ad998c853e8d762d56cda8fa8ce60f548942ec16642e12","id":"eJyFk0+LwjAQxb/KbA6iILpnwb2sF2FFQW/GQ0inNdt2UpKpINLvvsTaf+7KHtt57zd9L+lNKO/Re0PJwdpMLMR++7VeianQNsJPS4zEYiEKpVOVIHx7S3t9xlxJkjSfw8FuVAHa0gUde+AzwgpjQ4aNJfDsSs3AFhTkqgCHhUOPxCqMJcUlaRhHPcukJo4nQX/07AwlJ0OMLlYabxXcJEl26MuMYbGEXKU4/ls6CZ8o2cQQzQ7XAuFtCVJIUSMayFEKvhYoxQmWD2EYV611TXWKkOcVwXSaBtSzDXk7Zwt0bNAHHJkMRiPIkMb90QQ+4L1ZU7SvQ9f/h2bJsXWQ4nUKF5WVGDxOUYLD9Q/804JjitcQ4e6cPU6jVlZPsTtfnXrAeWqRMW8D/6ovDNviwkN/bwfZ2Aizl4eQh2lDuUv77rZhXV/3rYvQDWrux+qLGuSTt4HfryOXjqAGSKokiamITYY7xWexEN1fM+eQa5ZYUf0AXpRCxg=="}
{"assessingTool":"SOLID","filePath":"jsonSchema/toJson.go","grade":"C","username":"HLamb","timestamp":"2025-10-12T17:10:55.783Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependencyInversion","violatingCode":"The Definition type directly depends on the concrete map structure for Properties, violating dependency inversion by not abstracting its dependencies.\n\n```go\nif d.Properties == nil {\n    d.Properties = make(map[string]Definition)\n}\n```","codeResolution":"The MarshalJSON method should delegate serialization logic to an injected abstraction, promoting dependency inversion and testability. Replace the direct call to json.Marshal with a call to a marshaler interface:\n\n```go\ngo\nfunc (d Definition) MarshalJSON() ([]byte, error) {\n\tif d.Properties == nil {\n\t\td.Properties = make(map[string]Definition)\n\t}\n\treturn d.Marshaler.Marshal(d)\n}\n```","severity":"Critical","rationale":"This implementation tightly couples the `Definition` type to the `json.Marshal` function, violating dependency inversion principles. By directly depending on a concrete serialization method, the code becomes harder to test, extend, or swap out for alternative JSON libraries. This reduces maintainability and flexibility, as any change to the serialization logic requires modifying the core type. Introducing an abstraction, such as a `JSONEncoder` interface, would decouple the logic and improve testability and future extensibility.","lineStart":6,"lineEnd":13,"status":""},{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The Definition type's MarshalJSON method violates liskovSubstitution by directly mutating its receiver, making substitutability unsafe and unpredictable.\n\n```go\nif d.Properties == nil {\n\td.Properties = make(map[string]Definition)\n}\n```","codeResolution":"The MarshalJSON method is refactored to utilize an Operation abstraction, ensuring substitutability and adherence to the Liskov Substitution Principle:\n\n```go\n// Golang\nfunc (d Definition) MarshalJSON() ([]byte, error) {\n\top := getOperation(\"marshalJSON\")\n\treturn op.Execute(d)\n}\n```","severity":"Critical","rationale":"This implementation violates Liskov Substitution Principle because the MarshalJSON method is tightly coupled to the Definition type and its internal structure. If a different type or a subclass tries to override or extend Definition, it cannot substitute seamlessly due to the hardcoded handling of Properties and the use of a type alias. This rigidity reduces maintainability and testability, as future changes or alternative implementations would require rewriting or duplicating logic. Adhering to Liskov Substitution would allow more flexible, interchangeable types, improving code extensibility and correctness.","lineStart":1,"lineEnd":13,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"F","openClosedScore":"A-","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package jsonSchema\n\nimport \"encoding/json\"\n\nfunc (d Definition) MarshalJSON() ([]byte, error) {\n\tif d.Properties == nil {\n\t\td.Properties = make(map[string]Definition)\n\t}\n\ttype Alias Definition\n\treturn json.Marshal(struct {\n\t\tAlias\n\t}{\n\t\tAlias: (Alias)(d),\n\t})\n}\n","reason":"Modified","start":1,"end":16,"grade":"C"}]},"hash":"31e5560e91f356da349a075163cc4598a5d63aa2335e699406cf76ea355b4cc2","id":"eJxVkMFqwzAMhl9F6GRDaO+BHsZ6WVnXQnare/AcJfGayMFWDqXk3YezjWUXCfRJ+n/pgTYlSslz+x5CjyVWp9eXPRboQk3PgYVYsMTRupttCT5T4Mp1NFjDhv0whihgkNiF2nO7zdxgZs3EDlQNe2o8e/GBNRxtTJ3tD9XpTWlQl+vHXagAijFEDQ/DRnwD9eYcw0hRPCXY7YB9/82M/Ecw2BupwY6XJNFze11p5f45B7mPBE+9t2llJYNIMkVeLtr8GFNJ4uTkV22ZWhatCyWoJWtV62Kh2vBsGAtsfE9nKx2W+PeorYRD1mgDzl/5+4UT"}
{"assessingTool":"SOLID","filePath":"jsonSchema/model.go","grade":"C","username":"HLamb","timestamp":"2025-10-12T17:10:53.586Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"openClosed","violatingCode":"The Definition struct directly embeds new features and fields, requiring modification for every extension and thus violating openClosed.\n\n```go\ntype Definition struct {\n\t// ... many fields added for new features ...\n\tTextToSpeech *TextToSpeech `json:\"textToSpeech,omitempty\"`\n\tSpeechToText *SpeechToText `json:\"speechToText,omitempty\"`\n\tImage        *Image        `json:\"image,omitempty\"`\n\t// ... more fields ...\n}\n```","codeResolution":"The revised solution for openClosed refactors the code to delegate resolution logic to an abstraction, allowing new resolution strategies to be added without modifying existing code. Replace the original block with the following:\n\n```go\ngo\n// Instead of hardcoding resolution logic, use the Operation abstraction:\nop := getOperation(def.Type)\nresult, err := op.Resolve(def)\nif err != nil {\n    // handle error\n}\nreturn result\n```","severity":"High","rationale":"The current implementation tightly couples the `Definition` struct to many specific features (e.g., `TextToSpeech`, `SpeechToText`, `Image`, `HashMap`, etc.), making it difficult to extend without modifying the core type. This violates the Open/Closed Principle, as adding new schema capabilities requires direct changes to the struct, increasing the risk of regressions and making maintenance harder. For example, every new feature (like a new media type or processing option) demands a new field in `Definition`, leading to bloated code and reduced clarity. Adhering to openClosed would allow new behaviors via composition or interfaces, improving scalability and reducing the likelihood of breaking existing functionality.","lineStart":1,"lineEnd":81,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The Definition struct directly depends on multiple concrete types rather than abstractions, violating dependency inversion principles.\n\n```go\ntype Definition struct {\n\tType DataType `json:\"type,omitempty\"`\n\tProperties map[string]Definition `json:\"properties\"`\n\tItems *Definition `json:\"items,omitempty\"`\n\tHashMap *HashMap\n}\n```","codeResolution":"The solution applies dependency inversion by replacing direct calls to concrete types with abstractions, allowing flexible operation selection via an injected factory.\n\n```go\n// Go\nfunc (d *Definition) ResolveCode(opType string, a, b float64) float64 {\n    operation := getOperation(opType) // returns Operation interface\n    return operation.Execute(a, b)\n}\n```","severity":"Critical","rationale":"This code violates dependency inversion by tightly coupling the `Definition` struct to many concrete types (e.g., `HashMap`, `TextToSpeech`, `SpeechToText`, `Image`, etc.) as direct fields. This approach makes the codebase rigid and difficult to extend or test, since any change to these types requires modifying the `Definition` struct itself. For example, lines like `HashMap *HashMap` and `TextToSpeech *TextToSpeech` embed concrete implementations rather than abstractions or interfaces. This reduces maintainability and flexibility, as new features or alternative implementations cannot be injected easily. Refactoring to depend on interfaces would improve testability and allow for easier future enhancements.","lineStart":1,"lineEnd":87,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The Definition struct violates interface segregation by combining many unrelated responsibilities into a single type, forcing clients to depend on fields they may not need.\n\n```go\ntype Definition struct {\n\tProperties map[string]Definition `json:\"properties\"`\n\tItems *Definition `json:\"items,omitempty\"`\n\tTextToSpeech *TextToSpeech `json:\"textToSpeech,omitempty\"`\n\tImage *Image `json:\"image,omitempty\"`\n}\n```","codeResolution":"The solution restructures the code to delegate operation logic to an abstraction, ensuring each operation is handled by its own interface implementation for better interface segregation.\n\n```go\n// Go\nop := getOperation(def.Type)\nresult, err := op.Execute(def)\nif err != nil {\n    return nil, err\n}\nreturn result, nil\n```","severity":"High","rationale":"The Definition struct violates the Interface Segregation Principle by combining many unrelated concerns—such as schema typing, AI model selection, prompt management, external requests, and multimedia processing—into a single type. This monolithic design makes the code harder to maintain and extend, as changes to one aspect (e.g., image handling) could inadvertently affect others (e.g., text-to-speech). For example, lines like `TextToSpeech *TextToSpeech`, `Image *Image`, and `Req *RequestFormat` introduce responsibilities that should be separated into focused interfaces or structs. Improving interface segregation here would allow clients to depend only on the features they need, reducing coupling and improving testability and correctness.","lineStart":7,"lineEnd":81,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"C-","liskovSubstitutionScore":"A+","openClosedScore":"C-","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package jsonSchema\n\n// Definition is a struct for describing a JSON Schema.\n// It is fairly limited, and you may have better luck using a third-party library.\ntype Definition struct {\n\t// Type specifies the data type of the schema.\n\tType DataType `json:\"type,omitempty\"`\n\t// Instruction is the instruction for what to generate.\n\tInstruction string `json:\"instruction,omitempty\"`\n\t// Properties describes the properties of an object, if the schema type is Object.\n\tProperties map[string]Definition `json:\"properties\"`\n\n\t// Items specifies which data type an array contains, if the schema type is Array.\n\tItems *Definition `json:\"items,omitempty\"`\n\t// Model this needs to match the exact name of the model that you will be sending to AI as a Service provider. Such as OpenAI or Google Gemini\n\tModel string `json:\"model,omitempty\"`\n\t// ProcessingOrder this is the order of strings ie the fields of the parent property keys that need to be processed first before this field is processed\n\tProcessingOrder []string `json:\"processingOrder,omitempty\"`\n\n\t// SystemPrompt allows the developer to spefificy their own system prompt so the processing. It operates current at the properties level.\n\tSystemPrompt *string `json:\"systemPrompt,omitempty\"`\n\t// Req allows a developer to send out a request at a given point to ensure that additional information can be extracted from external databases\n\n\t// ImprovementProcess --> so that the user can specify when a super high quality completion is needed and it can be improved upon\n\tImprovementProcess bool `json:\"improvementProcess,omitempty\"`\n\n\t//Map is used here as so that a map of values can be created and then returned -- useful in the instruction creation process -- not sure how useful it is otherwise\n\tHashMap *HashMap\n\n\t//the other data types that need to be filled for the object to be generated within GoR\n\tTextToSpeech *TextToSpeech `json:\"textToSpeech,omitempty\"`\n\tSpeechToText *SpeechToText `json:\"speechToText,omitempty\"`\n\tImage        *Image        `json:\"image,omitempty\"`\n\n\t//Utility fields:\n\tReq *RequestFormat `json:\"req,omitempty\"`\n\t// NarrowFocus\n\tNarrowFocus *Focus `json:\"narrowFocus,omitempty\"`\n\n\t// SelectFields has the aim of being able to select multiple pieice of information and when they are all present then continue with processing. Such that the selection of information can work like so:\n\t//The system works as an absolute path that has to be selected. So starting from the top most object then down to the selected field(s)\n\t//\"car.color\" --> this would fetch the information from the car field and then the color field.\n\t//\"cars.color\" --> Would return the entire list of colours that have been generated so far\n\tSelectFields []string `json:\"selectFields,omitempty\"`\n\n\t// Choices For determining which of the property fields should be generated\n\tChoices *Choices `json:\"choices,omitempty\"`\n\n\t// Voters this is used for determining whether you want to have voters determine the qulaity of completions. Increases costs but improves quality. If avialible to your tier then turned on automatically.\n\tVoters bool `json:\"voters,omitempty\"`\n\n\t//Image URL --> if the LLM supports reading an image due to it being multi-model then the image URL will be passed in here\n\tSendImage *SendImage `json:\"sendImage,omitempty\"`\n\n\t//Stream - used for instructing when the information should be streamed. Please visit the documentation for more information for which types are supported.\n\tStream bool `json:\"stream,omitempty\"`\n\n\t//Temp - used for passing in a temperature value for the prompt request\n\tTemp float64 `json:\"temp,omitempty\"`\n\n\t//OverridePrompt - used for overriding the prompt that is passed in\n\tOverridePrompt *string `json:\"overridePrompt,omitempty\"`\n}\n\ntype Choices struct {\n\tNumber  int      `json:\"number,omitempty\"`  //this denotes the number of choices that should be selected\n\tOptions []string `json:\"options,omitempty\"` //this is the list of fields that will be chosen from\n\t/*\n\t\tHow this works is that it needs to be in a of definitions which match with the properties field. From the properties fields the choice of those keys will be selected\n\t\tthe information of what the overall object, the properties being selected along with the instruction and their type and the types that they contain if the object goes down further.\n\t\tthe prompt will also be pass in so that the agent can make the best decesion possible\n\n\t\tOnce the choices have been selected the choices that haven't been selected will be deleted from the remaining keys avialible in both the ordered and unordered keys.\n\t*/\n}\n\n// HashMap this can output a map of values and so whilst it may take up a single field it could output many fields\ntype HashMap struct {\n\tKeyInstruction  string      `json:\"keyInstruction,omitempty\"`\n\tFieldDefinition *Definition `json:\"fieldDefinition,omitempty\"`\n}\n\n// Focus the idea for this is so that when a narrow focus request needs to be sent out to an LLM without needing all the additional information. From prior generation.\ntype Focus struct {\n\tPrompt string `json:\"prompt\"`\n\t//the fields value denotes the properties that will be extracted from the properties fields. These will only operate at a single level of generation.\n\t//the order in which the fields that are listed will be the order for which the currently generated information will be presented below the prompt value.\n\tFields []string `json:\"fields\"`\n\n\t//KeepOriginal -- for keeping the original prompt in cases for lists where it would otherwise be removed from the context\n\tKeepOriginal bool `json:\"keepOriginal,omitempty\"`\n}\n\n// RequestFormat defines the structure of the request\ntype RequestFormat struct {\n\tURL           string                 `json:\"url\"`\n\tMethod        HTTPMethod             `json:\"method\"`\n\tHeaders       map[string]string      `json:\"headers,omitempty\"`\n\tBody          map[string]interface{} `json:\"body,omitempty\"`\n\tAuthorization string                 `json:\"authorization,omitempty\"`\n\tRequireFields []string               `json:\"requirFields,omitempty\"`\n}\n","reason":"Modified","start":1,"end":103,"grade":"C"}]},"hash":"62595fb0bdc420c81792b39fd4c6f2c7930034548a065f2cb654185cff7d10fc","id":"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"}
{"assessingTool":"Complexity","filePath":"converison/response.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:10:53.085Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A+","testability":"A"},"issues":{"cyclomaticComplexity":8,"dependenciesModules":2,"functionMethodCounts":3,"linesOfCode":61,"nestingDepth":3}},"hash":"a0e299ed9ae0934151ab75ff3b84925ae52733db7c001379d4796cbbcf5e9891","id":"eJzFVd9r3DAM/lc0wyAZIXk/uJeVrYP9YNBjL00ZbqKk5hw52HK6o9z/Puzkrne5tBt72ZuxPn3SJ8nyk5DOoXOK2o0xWqzElel6jb8U70QmKlPjlSFGYrESvay2skWoDA1olTNUUkmq641lSEoquRRNx6UYj60xrca8NVpSmxvbFr01bO59U/CuR1dsyTxS4dj6ivv74JYGwqKAqxiBbybTxnyV/RSWHbw7uOQjANhAJ/tbx1ZRe6eI0Taywqd9SY2napEuueRJITmhkbTLAK01NoWnoEg14GC9BlJ6vCjZIntL4SaDpuP8Q4A3SSkU9Z5hnqdyAVqKIJP3QWugcF4zrNbQyS3OEkhHTGMsbHGXwSC1x4C1kloEl18jf1Soa5ekh5ymMmH9I4CjhOBRndcgGpPIl45+qonQN2cCzyWiteP1/iA/5H67xd0dHCNMgc8kRooRncUS0H7q9CfUPVoIbWJlKLRy4gFFtRpU7aU+6VTkDqhrA3GKpha/LG/unEJy0Vr3qLh6gCEUKjqFwn5WVCdpnoQwE66S7oLv5zevdTytLocian3Rr7tHu+A55Cem1zlu4qgscpyYXud4b8xS/kN+NPwxB1/xAsPisxvyE3z6IukX5ZYoZ20OqGTIj+DIV2MjveaFbpw9UU/O92F1YQ3z8dr1uIK3m1JkMBwe619M7LOIY0bBLMOwOq0qXB7WqEIrt0iQQnJ7uYtmW2NCaKTIE6Y3OrskTU92iLrYIHP0/1si6l9WiMhEozR+l/wgVuL5Xyosut6QC7+P2P8GmPWScw=="}
{"assessingTool":"SOLID","filePath":"jsonSchema/image.go","grade":"C","username":"HLamb","timestamp":"2025-10-12T17:10:51.086Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependencyInversion","violatingCode":"The violatingCode tightly couples the SendImage struct to concrete data representations, ignoring dependency inversion and making future extensions or testing difficult.\n\n```go\ntype SendImage struct {\n\tImagesData [][]byte `json:\"imagesData,omitempty\"`\n}\n```","codeResolution":"To address dependency inversion, the solution introduces an abstraction layer for image processing, allowing the ImageService to depend on an interface rather than a concrete implementation.\n\n```go\n// Go\ntype ImageService struct {\n    processor ImageProcessor // ImageProcessor is an interface defined elsewhere\n}\n\nfunc NewImageService(p ImageProcessor) *ImageService {\n    return &ImageService{processor: p}\n}\n\nfunc (s *ImageService) ProcessImage(img *Image) error {\n    return s.processor.Process(img)\n}\n```","severity":"Critical","rationale":"This code tightly couples the `Image` and `SendImage` types to specific models and sizes, violating dependency inversion. By hardcoding model and size options (lines 3–24), any change or extension requires modifying the core types, reducing maintainability and flexibility. This approach makes unit testing difficult, as dependencies cannot be easily mocked or replaced. For better adherence to dependency inversion, interfaces or abstraction layers should be introduced, allowing new models or sizes to be added without altering existing code. This would improve extensibility and testability, and reduce the risk of bugs when requirements change.","lineStart":1,"lineEnd":22,"status":""},{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The code violates the Liskov Substitution Principle by not providing any interface abstraction for image models or image sending, preventing substitutability and extensibility.\n\n```go\ntype Image struct {\n\tModel ImageModel `json:\"model,omitempty\"`\n\tSize  ImageSize  `json:\"size,omitempty\"`\n}\n```","codeResolution":"To address Liskov Substitution Principle violations, the solution introduces an abstraction for image operations, allowing interchangeable implementations for different models and sizes.\n\n```go\n// Go\nfunc ProcessImage(model ImageModel, size ImageSize, data []byte) error {\n    op := getOperation(model, size) // Returns an Operation interface\n    return op.Execute(data)\n}\n```","severity":"Critical","rationale":"This implementation lacks interface abstraction for image models and image sending, violating Liskov Substitution Principle. Without interfaces, client code cannot substitute different image model or sender implementations, making the system rigid and difficult to extend. For example, if a new image model or sending strategy is needed, significant refactoring would be required. This reduces maintainability and testability, as mocking or swapping components is not straightforward. Introducing interfaces for image handling and sending would allow for flexible, interchangeable implementations, improving adherence to Liskov Substitution and overall code robustness.","lineStart":16,"lineEnd":20,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"F","openClosedScore":"A-","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package jsonSchema\n\ntype ImageModel string\n\nconst OpenAiDalle2 ImageModel = \"OpenAiDalle2\"\nconst OpenAiDalle3 ImageModel = \"OpenAiDalle3\"\n\ntype ImageSize string\n\nconst (\n\t//this code is nicked from go-openai\n\tCreateImageSize256x256   ImageSize = \"256x256\"\n\tCreateImageSize512x512   ImageSize = \"512x512\"\n\tCreateImageSize1024x1024 ImageSize = \"1024x1024\"\n\n\t// dall-e-3 supported only.\n\tCreateImageSize1792x1024 ImageSize = \"1792x1024\"\n\tCreateImageSize1024x1792 ImageSize = \"1024x1792\"\n)\n\n// Image if you want the Url of the image use the DataType String otherwise use the DataType Byte\ntype Image struct {\n\tModel ImageModel `json:\"model,omitempty\"`\n\tSize  ImageSize  `json:\"size,omitempty\"`\n}\n\ntype SendImage struct {\n\tImagesData [][]byte `json:\"imagesData,omitempty\"` //When sending multiple images take into account the model you have selected. Such that Gemini Models support multiple images whereas the Claude models only support one image at a time\n}\n","reason":"Modified","start":1,"end":30,"grade":"C"}]},"hash":"f559799291e4d4ca7cc39d67196421b82117cbeebe62f9db4ad4a95f916ce4d2","id":"eJx9U1Fr2zAQ/iuHnjZI4sVZGhLow5bAKGx04I491IVe7YutRZaMdV7ilv73IsXxvMT0xUin7/vuvrvzi0BryVqpsztjlFiJ6Pb7zUaMRGJSWhvNpFmsRInJDjOCP9boKMmpwFjHmpuS4KbAjH6YlBRYrqTO3EtitGW4LUl/kRtUisI+7hpi0X+LxQBj9g5j5hj9/JF8pov0H2IdcxBwLi04OyAtaJnsKIVtZQrIzNiUpFE63LoiZOrEwvnVIZxfAfT0XRFt3Oc/58yn4WE+DS84bXyQM/0Ufj64zxmnix+dOh+QolJjGs/A1mVpKqYUjFbNZEh2sQwHZU/xd4pZLMPBYhZLb+GjqycIjhCQW2hMDXvUDJwT/KoUmK0/Sg+oLfnbBhnv3LwiPyUwnFO1l3YA8bVh6g/XDbZOGF5cycd96K3Go9vJVSwKdxuZQjIVJTexeHRw76Fnp4Nb+Uxn6NdupyLS6WVqH7GuTLh/uH94apg6Odm9/ScKQfA7Jw2WdOpcF7ViWaq2ORYYdwRSswFMElO3TfRWfF9z/EtgSVHClE4gqpMcOEeGb1RILcG3wJ4W4kJ+n1NFaL3oWmGdttrWL05HM/o0LWRAYFmQ74YYia1U9BM5Fyvx798PPHiSGfH6Bh39e6g="}
{"assessingTool":"Complexity","filePath":"jsonSchema/image.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:10:49.151Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":1,"dependenciesModules":0,"functionMethodCounts":0,"linesOfCode":30,"nestingDepth":0}},"hash":"b438506bc504af56b6b786e71e9f11aea2c748e259197dea1271e18bcc76415a","id":"eJx9U8Fu2zAM/RVCpw1I4sVZGiTADlsKDDsMG5AOO9QFytmMzUWWDIte4hb990FK4nmJ0YshUe898pH0s0LnyDk2+Z21Wq3U2paVpgNLq0YqtRmtrREyolaqwnSHOcFvZ80mLajExCRG2orgS4k5fbUZaXBSs8n9S2qNE/hWkfnIt6g1xX3cB0hU/y1RA4zZK4yZZ/Tzb/iJrtK/SUwiUSQFO/B2gB0YTneUwba2JeR2bCsyyB63rgmFOrF4fnOI5zcAPX1fxCke8l9y5tP4MJ/GV5xTfJAzfRe/P/jPBaeLH516H5Ch1mMaz8A1VWVroQys0e1kSHaxjAdlz/FXilks48FiFstg4a2vJ4qOEOAttLaBPRoBKQh+1BrsNhw5ABpH4XaLgnd+XpswJbBSUL1nN4D41Ar1h+sH26QCz77k4z70VuPR7+QqUaW/jWzJQmUlbaIePTx46Nnp4I6f6AL90u3Uhkx2nTpEnC8T7h/uH361Qp0cd2//iUIU/SzIgCOTeddlo4UrfWqOA8EdARuxgGlqm1MTg5XQ1wL/EDjSlAplE9g0aQFSoMBnKtkwhBa480Jcye8LqgldEF1rbLKTtguL09GsOU8LBRCESwrdUCO1ZU3fUQq1Uv/+/SiAJ7lVL38Bjhd+Ww=="}
{"assessingTool":"Complexity","filePath":"converison/requestFormat.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:10:48.691Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The ConvertProtoToRequestFormat and ConvertModelToProtoRequestFormat functions ignore cyclomatic complexity best practices by embedding multiple conditional branches and conversions within single functions.\n\n```go\nif protoReq == nil {\n\treturn nil\n}\nbody, _ := ConvertStructToMap(protoReq.Body)\nreturn &jsonSchema.RequestFormat{ ... }\n```","codeResolution":"The solution for cyclomatic complexity in this context involves refactoring conditional logic into dedicated helper functions, reducing branching and improving readability.\n\n```go\n// Replace the body conversion logic with a helper function call.\nbody := convertBody(protoReq.Body)\n```","severity":"Critical","rationale":"High cyclomatic complexity in these conversion functions increases the risk of errors and makes future changes difficult. For example, both `ConvertProtoToRequestFormat` and `ConvertModelToProtoRequestFormat` contain multiple conditional branches and implicit error handling (lines 10, 23), which can obscure logic flow and complicate testing. Excessive branching also makes it harder to reason about correctness and can degrade performance if the code grows. Refactoring into smaller, single-responsibility functions would improve maintainability and testability, reducing the likelihood of bugs and simplifying future enhancements.","lineStart":13,"lineEnd":28,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode exhibits unnecessary nesting by placing the main conversion logic inside an if-statement, reducing readability and maintainability.\n\n```go\nif protoReq == nil {\n\treturn nil\n}\n```","codeResolution":"The solution for nestingDepth in this code focuses on flattening control structures by using guard clauses, which improves readability and maintainability.\n\n```go\n// Replace the main conversion logic with guard clauses to reduce nesting depth.\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\tif protoReq == nil {\n\t\treturn nil\n\t}\n\tbody, _ := ConvertStructToMap(protoReq.Body)\n\treturn &jsonSchema.RequestFormat{\n\t\tURL:           protoReq.Url,\n\t\tMethod:        jsonSchema.HTTPMethod(protoReq.Method),\n\t\tHeaders:       protoReq.Headers,\n\t\tBody:          body,\n\t\tAuthorization: protoReq.Authorization,\n\t\tRequireFields: protoReq.RequireFields,\n\t}\n}\n```","severity":"Critical","rationale":"The code demonstrates minimal nesting, with only a single level of 'if' statements in both conversion functions. This shallow nesting depth is beneficial because it keeps the logic straightforward and easy to follow, reducing cognitive load for future maintainers. Deeply nested code can obscure the main logic, making bugs harder to spot and increasing the risk of errors during modifications. By limiting nesting, the code remains readable, testable, and less prone to mistakes, supporting maintainability and correctness.","lineStart":13,"lineEnd":27,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code tightly couples the conversion logic to specific external packages, making future maintenance and testing more difficult.\n\n```go\nimport (\n\tpb \"github.com/firechimp-org/go-sdk/grpc\"\n\t\"github.com/firechimp-org/go-sdk/jsonSchema\"\n)\n```","codeResolution":"The code demonstrates a direct mapping between protobuf and Go model types for request formats, relying on two external packages for type definitions and conversion helpers.\n\n```go\n// codeResolution\n\nreturn &jsonSchema.RequestFormat{\n\tURL:           protoReq.Url,\n\tMethod:        jsonSchema.HTTPMethod(protoReq.Method),\n\tHeaders:       protoReq.Headers,\n\tBody:          body,\n\tAuthorization: protoReq.Authorization,\n\tRequireFields: protoReq.RequireFields,\n}\n```","severity":"Critical","rationale":"The code imports two external packages: `pb` from `github.com/firechimp-org/go-sdk/grpc` and `jsonSchema` from `github.com/firechimp-org/go-sdk/jsonSchema`. While these dependencies are necessary for type conversions, tightly coupling the conversion logic to specific external modules can hinder maintainability. If either package changes its API, all dependent conversion functions must be updated, increasing the risk of breaking changes. Additionally, excessive reliance on external packages may complicate testing and reduce portability. Abstracting conversion logic or using interfaces could improve flexibility and future-proof the code against upstream changes.","lineStart":3,"lineEnd":5,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode unnecessarily duplicates logic across two functions, inflating the lines of code and reducing maintainability.\n\n```go\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\t// ...\n}\n\nfunc ConvertModelToProtoRequestFormat(modelReq *jsonSchema.RequestFormat) *pb.RequestFormat {\n\t// ...\n}\n```","codeResolution":"The solution streamlines lines of code by abstracting conversion logic into reusable functions, reducing duplication and improving maintainability.\n\n```go\n// Replace the conversion blocks with calls to the new abstraction.\nreturn ConvertRequestFormat(protoReq)\n```\n\n```go\nreturn ConvertRequestFormat(modelReq)\n```","severity":"Critical","rationale":"### Rationale\n\nThe code currently has duplicated logic across `ConvertProtoToRequestFormat` and `ConvertModelToProtoRequestFormat`, increasing lines of code unnecessarily. Excessive LoC can hinder maintainability, making future updates error-prone and harder to test. For example, both functions manually map fields between types; extracting shared logic into helper functions would reduce repetition and improve clarity. Streamlining LoC also helps performance by minimizing redundant operations and makes correctness easier to verify, as less code means fewer places for bugs to hide.","lineStart":8,"lineEnd":28,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode fails functionMethodCounts by combining multiple responsibilities into just two functions, making the code less modular and harder to maintain.\n\n```go\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\tif protoReq == nil {\n\t\treturn nil\n\t}\n\n\tbody, _ := ConvertStructToMap(protoReq.Body)\n\n\treturn &jsonSchema.RequestFormat{\n\t\tURL:           protoReq.Url,\n\t\tMethod:        jsonSchema.HTTPMethod(protoReq.Method),\n\t\tHeaders:       protoReq.Headers,\n\t\tBody:          body,\n\t\tAuthorization: protoReq.Authorization,\n\t\tRequireFields: protoReq.RequireFields,\n\t}\n}\n```","codeResolution":"The conversion logic is currently duplicated across two functions, which violates functionMethodCounts best practices. Refactor by introducing a shared abstraction for conversion, reducing redundancy and improving maintainability:\n\n```go\n// Use a unified conversion handler for both directions.\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\treturn convertRequestFormat(protoReq)\n}\n\nfunc ConvertModelToProtoRequestFormat(modelReq *jsonSchema.RequestFormat) *pb.RequestFormat {\n\treturn convertRequestFormat(modelReq)\n}\n```","severity":"Critical","rationale":"The code defines only two functions, each handling both conversion logic and error handling. This low function count means responsibilities are not well separated, making the code harder to maintain and extend. For example, lines handling nil checks and body conversions are embedded directly in the conversion functions (lines 8–11, 22–25), rather than being delegated to dedicated helpers. This approach increases the risk of bugs if conversion logic changes, and makes unit testing more difficult since each function does too much. Increasing the function count by extracting body conversion and validation into separate functions would improve clarity, testability, and future scalability.","lineStart":7,"lineEnd":22,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A","readability":"A","testability":"A-"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":2,"functionMethodCounts":2,"linesOfCode":43,"nestingDepth":2}},"hash":"2263e1ff66e289c0e6ff36b18520255438d1cbb557eec0b97c0382e2f8ba9861","id":"eJydlFFvmzAQx7+K5YcpVDS8I+Vhi9T1oZGilLwhTQYO8Ao+1z6mZVW++2SgJrShm8qb7/539z/7J164sBaslapKEBse8y22uoHfkk485DkWsEVFoIjHXIv8SVTAclS/wEiLKlWpkq1GQ2yVqpR0xlJeSaq7bJ1jG5XSQF7LVt+iqaIKb23xFFVG5yl38n9rf1pUj3kNrXAVgZsXRWzbG6C9QcIED/DcgaU7NK2g0RxZJph2+awr2VxByKgG9h1ZiwU082yqyk7lH01Y9W0P8MxudLaepQJ2Mxmep9iLW1iWzFdvNkzJZoinZIA6o1zEnc9u0ZQyLE4h+8HizauhRzJdTgnuhPY+1t+wOAVDxdjmy5KNcdrx8BCz6fOdjqYJB8UOqMbCiy763SfJfshODoZzMNbegyjA2Pht9zE+qpzrCxP9rkPma0c1GvlHkEQVT/Wz+Kh120kDdxKawl5oZ/FwvNPznJ+de/4E92PNdYiuY+IgWgJsjtDikFXftudo6bWC94h5jnz1pzjaCZ3gAJP3cY2jt+Nf+THNJT++w/HwcJ0fS0aqahr1ITBe9UlgfP1/AOO1S8DwkJeygb2gmsd8+vVF5vJe1hXy81+2Ju2V"}
{"assessingTool":"SOLID","filePath":"jsonSchema/audio.go","grade":"C-","username":"HLamb","timestamp":"2025-10-12T17:10:47.669Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The code violates interface segregation by combining unrelated responsibilities into the TextToSpeech and SpeechToText structs instead of defining focused interfaces.\n\n```go\ntype TextToSpeech struct {\n\tModel         TextToSpeechModel `json:\"model,omitempty\"`\n\tStringToAudio string            `json:\"stringToAudio,omitempty\"`\n\tVoice         Voice             `json:\"voice,omitempty\"`\n\tFormat        AudioFormat       `json:\"format,omitempty\"`\n}\n```","codeResolution":"To address interface segregation, the solution introduces specialized abstractions for each audio operation, ensuring that clients depend only on the functionality they require. The following replacement code demonstrates how to utilize the new abstraction for processing audio operations:\n\n```go\n// Golang\nfunc ProcessAudioOperation(opType string, input interface{}) (interface{}, error) {\n    operation := getOperation(opType) // Returns an Operation interface\n    result, err := operation.Execute(input)\n    return result, err\n}\n```","severity":"High","rationale":"The current design lacks interfaces for the TextToSpeech and SpeechToText types, violating the Interface Segregation Principle. This matters because clients are forced to depend on concrete types rather than abstractions, making future extensions (e.g., supporting new audio models or formats) harder and risking tight coupling. Without focused interfaces, maintainability suffers—any change to these structs could impact all consumers. Introducing minimal, role-specific interfaces (e.g., for conversion or formatting) would allow clients to depend only on what they need, improving modularity and testability.","lineStart":22,"lineEnd":44,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code violates dependency inversion by directly using concrete types instead of abstractions, making it rigid and difficult to extend.\n\n```go\ntype TextToSpeech struct {\n\tModel         TextToSpeechModel `json:\"model,omitempty\"`\n\tStringToAudio string            `json:\"stringToAudio,omitempty\"`\n\tVoice         Voice             `json:\"voice,omitempty\"`\n\tFormat        AudioFormat       `json:\"format,omitempty\"`\n}\n```","codeResolution":"To address dependency inversion, the solution replaces direct instantiation with abstraction-based delegation, ensuring the code depends on interfaces rather than concrete implementations.\n\n```go\n// Go\nfunc (stt *SpeechToText) Transcribe() (string, error) {\n    op := getOperation(stt.Model) // returns Operation interface\n    return op.Transcribe(stt.AudioToTranscribe, stt.Language, stt.Format)\n}\n```","severity":"Critical","rationale":"This code tightly couples the data models to specific implementations (e.g., hardcoded model and format constants), violating dependency inversion principles. By directly referencing concrete types and values, future changes—such as supporting new audio models or formats—require modifying the core structs, reducing maintainability and flexibility. This approach also hinders testability, as it’s difficult to substitute or mock dependencies. Introducing interfaces or abstraction layers for model and format selection would decouple the logic, making the codebase easier to extend and refactor.","lineStart":1,"lineEnd":34,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The code violates openClosed principles by requiring modification of existing types and constants to support new models or formats, rather than allowing extension.\n\n```go\nconst OpenAiWhisper SpeechToTextModel = \"OpenAiWhisper\"\nconst GroqWhisper SpeechToTextModel = \"GroqWhisper\"\n```","codeResolution":"The solution for openClosed refactors the code to delegate audio operations to an abstraction, allowing new models or formats to be added without modifying existing logic.\n\n```go\n// Go\nfunc (stt *SpeechToText) Transcribe() (string, error) {\n    op := getOperation(stt.Model)\n    return op.Transcribe(stt.AudioToTranscribe, stt.Format, stt.Language)\n}\n```","severity":"Critical","rationale":"This code violates the Open/Closed Principle because adding new audio models or formats requires modifying existing structs and constants directly (e.g., adding a new SpeechToTextModel or AudioFormat). This approach leads to poor maintainability, as every extension forces changes throughout the codebase, increasing the risk of bugs and regressions. It also makes testing harder, since new logic is tightly coupled to existing types. Refactoring to use interfaces or composition would allow new models or formats to be added without altering existing code, improving extensibility and correctness.","lineStart":22,"lineEnd":34,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"C-","liskovSubstitutionScore":"A+","openClosedScore":"F","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package jsonSchema\n\n// AudioModel constant types for the different auido models\ntype TextToSpeechModel string\n\nconst OpenAiTTS TextToSpeechModel = \"tts\"\n\n// TextToSpeech the DataType to use with this type is Byte\ntype TextToSpeech struct {\n\tModel         TextToSpeechModel `json:\"model,omitempty\"`\n\tStringToAudio string            `json:\"stringToAudio,omitempty\"`\n\tVoice         Voice             `json:\"voice,omitempty\"`\n\tFormat        AudioFormat       `json:\"format,omitempty\"`\n}\n\ntype SpeechToTextModel string\n\nconst OpenAiWhisper SpeechToTextModel = \"OpenAiWhisper\"\nconst GroqWhisper SpeechToTextModel = \"GroqWhisper\"\n\ntype AudioFormat string\n\nconst Text AudioFormat = \"text\"\nconst SRT AudioFormat = \"srt\"\nconst VTT AudioFormat = \"vtt\"\nconst JSON AudioFormat = \"json\"\nconst VerboseJSON AudioFormat = \"verbose-json\"\n\ntype Voice string\n\nconst (\n\tAlloy   Voice = \"alloy\"\n\tEcho    Voice = \"echo\"\n\tFable   Voice = \"fable\"\n\tOnyx    Voice = \"onyx\"\n\tNova    Voice = \"nova\"\n\tShimmer Voice = \"shimmer\"\n)\n\n// SpeechToText the DataType to use with this type is String\ntype SpeechToText struct {\n\tModel             SpeechToTextModel `json:\"model,omitempty\"`\n\tAudioToTranscribe []byte            `json:\"audioToTranscribe,omitempty\"`\n\tLanguage          string            `json:\"language,omitempty\"` //must be in the format of ISO-639-1  will default to en (english)\n\tFormat            AudioFormat       `json:\"format,omitempty\"`\n\tToString          bool              `json:\"toString,omitempty\"`\n\tToCaptions        bool              `json:\"toCaptions,omitempty\"`\n}\n","reason":"Modified","start":1,"end":49,"grade":"C-"}]},"hash":"31bf39d54c5374e190b0e09e7d888b521cd739215ced13821140b7abef996e89","id":"eJydVd1r2zAQ/1cOPbWQLIzBYIE9ZO06OrpmzKZ7mAdV7LOtzdZ51jmNKf3fhyQntWMvlOnN+n3oPnTyo5DGoDFKZyFRIZYiWN9cX4qZiCnBC9KMmsVSVDL+LTOEX4Z0EOdYykhHerGAVZMo+kIJFhCTNiw1A7cVGkipBs4REpWmWKNmkI1KCEpLNpG2LAhxxyEFFWKcexfDtdKZdXd+sK5Qr1QYBhPc9xAJZhOJLpg+w519KVmG9hwmaAzCg2ILKONiBGXgQ8s4EYsNo4kZHiMdsT9sv8Zh3NuqLCPhMptRqRjLittI3Ft14BIKyVWqSw96a682fd7I5Y5UjAfN8KvvsrXISH1FdSl5z3UnDLb26tRtHsmfbHVdhXzSIdkSnOrW91yZCusJvu3YgGN756WfavpzWthj+Ja7oPrZHIdj9QOCuzG44+djg2/hiGHqHuEuHBO23CN8Dta3I4YtaM8D6w0ZnGRuPTbfK7q0fIuPEzqz3VwVBbWHW2A9pN1xYv4Y5wQDEOOcPHYlNwUOsNTueHCt291QSLrdeeyWtnKIadpKjwW5Kkuse5jxOxY+7yaz39AXTmbQpT66eSdm067x3Tk9n64fIYW11Cau1Qbhx89Nyzg1XfKYO3K7kTpr7Et5WP+e+KLjDkxgsSgbw7BBUNqVyg8lUArXwXr+9s27+WuAB1UUkGAqm4JtDVHDGeqsUCY/H0/8f0x9ZB+5o9A3RMNaHyy4406YXMiKFWnzEpM9d/wCiZlIVYFfJediKZ5/QwvXklcZiae/Yx9TSA=="}
{"assessingTool":"SOLID","filePath":"jsonSchema/toolModel.go","grade":"A+","username":"HLamb","timestamp":"2025-10-12T17:10:45.191Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"dependencyInversionScore":"A+","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"A+","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package jsonSchema\n\n// SubordinateFunction represents a function under the AI's control, including its name, definition, and responses.\ntype SubordinateFunction struct {\n\tName       string      `json:\"name\"`       // The name of the subordinate function.\n\tDefinition *Definition `json:\"definition\"` // The schema definition of the function.\n}\n","reason":"Modified","start":1,"end":8,"grade":"A+"}]},"hash":"31500b5280e5d78fbffd03cb923d04bbb54a5be936fe452b32764ebcbfe6cb80","id":"eJxtkD9rw0AMxb+K0FIoJt69lYZCoP8gGW/I9U62L7Ulc5KHEvLdi9048VBNQki/957O6FVJNXFzEOmwwv3H626LBQaJ9CxsxIYVDj58+4bgpML70FLvHTsuS9iPX5JjYm/0MnKwJAyZhkxKbAoe6mU6cqQM1hI87R4UgrBl6QpIHLoxJm4gmQL7ngqIVCdO01kBniNk0kFYSTeO7Wegf2XV8hgMzo6dvfue4K/U8gSf6zj5rxxOKg6P142yhENLszRIPVvUO/+WYDOBtzdn8LjqF/Dd+IS/gnV+2CrUorIiXxxjgXXq6NNbixXeP12aSPcmkbpNI3j5BYVDmdU="}
{"assessingTool":"Complexity","filePath":"jsonSchema/constantModels.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:10:44.583Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A+","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":1,"dependenciesModules":0,"functionMethodCounts":0,"linesOfCode":27,"nestingDepth":0}},"hash":"ec3a4de11485b9b6d1b41b312c78072832b4af046b70d6c18f22dd70c225b6ed","id":"eJxtk0Fvm0AQhf/KaE+JZNl3Sz24Dkoi1Y0lkxuXAQbYdJlBu4NaVPW/V7uQJsa9ofe+eQxPw2+DIVAIlttcxJm9OUo/OPpldTIbU0lNR2ElVrM3A1Y/sCV4C8KXqqMeCy5Yp4HgARXz+BDUW26jXgkHhbuCC30p36hS+KC+QGEkiYWJwPexL8mvAE7iDDyzUkv+GrCzOBOX9OJVxLJNAg7e4wQrAKP4voNzsPZ5dG62v4o4Qr62y1mciRMOcBPQ47DMT0o3bjkpFQZ2O+1sgJ/WOSgJxkA1NOJBOwIcayuAXIPtY/k1KkIgR5VaYbizDaRhGxaVasAAMTnOM5DVjjw8p2nxcEiB/RgUWDS+j63bgG3AakxJQyzaxTrTSlJVo08rIAP1g05z/Pu+nnT0TPUW8o4gYE8px48UU0vRDtATNNY5qrcF3/87m6c8P59IO6k/Hc5uB8d4O8gaUg2Rgj5h4equHrM8VvopJZb6mOVz5eeXS35rR3XxX/83fn5d7IfsW5Zna3tWl4BDfny6DYhqBO4LNhvTWEdn1M7szcePs6uWLzxJTS5sWzF//gIMDzUA"}
{"assessingTool":"Complexity","filePath":"jsonSchema/audio.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:10:44.088Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A+","testability":"A"},"issues":{"cyclomaticComplexity":1,"dependenciesModules":0,"functionMethodCounts":0,"linesOfCode":49,"nestingDepth":1}},"hash":"cfd32848613f8e6ebea73fbeeffed3233abd54d129711bb751790aefb1cac33e","id":"eJydVd1v0zAQ/1dOftqklgohIVGJh1IYAsGKSDQeCNKc9JIYEl+IL12jaf/7ZDvpkqZUE36Lfx++D59zL6QxaIzSWUhUiKVYU1kVuFfciplIaItr0oyaxVJUMvkjM4TfhnSQ5FjKSEd6sYBVs1X0lbZYQELasNQM3FZoIKUaOEfYqjTFGjWDbNSWoLRkE2nLghD3HFJQISa5dzFcK51Zd+cHmwr1SoVhcIL7FiLBbCLRBTNkuLPfS5ahPYcJGoNwp9gCyrgYQRl41zKeiMWG0SQM95GO2B/Wr2kYt7Yqy0i4zGZUKsay4jYSt1YduIRCcpXq0oPB6tVmyJu43JBK8KAZfw1ddhaZqK+oLiX3XHfCaKtXp27zSP5gq+sq5JMOyZbgXLd+5MpUWJ/g246NOLZ3Xvqxpr/nhQOGb7kLapjNcThWPyK4G4N7fjo2+B5OGKYeEG7CKWHHA8LnYHM9YdiCDjywjsngSebOY/Ne0aXlW3yc0IXt5qooqD3cAush7Y4T84ckJxiBmOTksSsZFzjCUrvjwY1u92Mh6XbvsWvayTGmaSc9FuSqLLEeYMbvWPiym8xhQ585mUGX+uTmnZlNu6Z35/x8un6EFNZSm6RWMcLPX3HLeGq65DF34vZF6qyxL+Vh/Xvii447MoHFomwMQ4ygtCuVH0qgFD4Fm/nrV2/mLwHuVFHAFlPZFGxriBouUGeFMvnldOL/Y+oj+8gdhR4TjWt9sOCOe8JkLStWpM1zTHru9AUSM5GqAr9JzsVSPP2GFq4lLzISD4+w01X7"}
{"assessingTool":"Complexity","filePath":"client/grpcGenerateObject.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:10:42.321Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code unnecessarily imports five external packages, including two from the same organization, which increases complexity and potential maintenance overhead.\n\n```go\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/firechimp-org/go-sdk/converison\"\n\tpb \"github.com/firechimp-org/go-sdk/grpc\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"time\"\n)\n```","codeResolution":"The solution for dependenciesModules streamlines external package usage by focusing only on essential imports for gRPC communication and data conversion.\n\n```go\npackage client\n\nimport (\n\t\"context\"\n\t\"github.com/firechimp-org/go-sdk/grpc\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\n// Only core dependencies for gRPC and context are imported.\n```","severity":"Critical","rationale":"The code imports four external packages, including two from the same organization and two from Google. While these dependencies are necessary for gRPC functionality, the use of the custom \"converison\" package (line 4) raises maintainability concerns, especially if it is not well-documented or widely used. Excessive or poorly managed dependencies can complicate upgrades, introduce compatibility issues, and increase the risk of bugs. Streamlining imports and relying on well-supported libraries improves reliability and makes future maintenance easier. Redundant or unnecessary dependencies should be removed to reduce complexity and potential security risks.","lineStart":3,"lineEnd":8,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The GrpcGenerateObject function exhibits excessive nestingDepth, making error handling and resource management convoluted and difficult to follow.\n\n```go\ndefer func(conn *grpc.ClientConn) {\n\terr = conn.Close()\n\tif err != nil {\n\n\t}\n}(conn)\n```","codeResolution":"The solution for nestingDepth in GrpcGenerateObject focuses on flattening control flow and delegating responsibilities to helper abstractions, improving readability and maintainability.\n\n```go\n// Replacement for the main logic block in GrpcGenerateObject\nconn, err := grpc.NewClient(c.BaseURL, grpc.WithInsecure(), grpc.WithBlock())\nif err != nil {\n\treturn nil, fmt.Errorf(\"failed to connect to server: %v\", err)\n}\ndefer closeConnection(conn)\n\nctx := createAuthorizedContext(c.Password)\nresponse, err := callGenerateObject(ctx, client, prompt, definition)\nif err != nil {\n\treturn nil, fmt.Errorf(\"failed to call GenerateObject: %v\", err)\n}\nreturn buildResponse(response)\n```","severity":"Critical","rationale":"The code demonstrates excessive nesting, particularly in the error handling and resource cleanup sections (lines 13–22). Deeply nested defer functions and error checks make the logic harder to follow and maintain. High nesting depth increases cognitive load, making future modifications and debugging more error-prone. It also complicates unit testing, as tightly coupled logic is harder to isolate. Refactoring with guard clauses and extracting resource management into helper functions would flatten the structure, improving readability and maintainability.","lineStart":19,"lineEnd":38,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The GrpcGenerateObject function contains excessive lines of code due to deeply nested resource management and setup logic, making it difficult to maintain and refactor.\n\n```go\nconn, err := grpc.NewClient(c.BaseURL, grpc.WithInsecure(), grpc.WithBlock())\nif err != nil {\n\treturn nil, fmt.Errorf(\"failed to connect to server: %v\", err)\n}\ndefer func(conn *grpc.ClientConn) {\n\terr = conn.Close()\n\tif err != nil {\n\n\t}\n}(conn)\n```","codeResolution":"The current implementation for linesOfCode in GrpcGenerateObject is verbose due to manual setup and teardown of connections, context, and metadata. This can be streamlined by delegating these responsibilities to helper abstractions, reducing boilerplate and improving clarity.\n\n```go\n// Replacement code using abstractions for connection, context, and metadata\nconn := getGrpcConnection(c.BaseURL)\ndefer closeGrpcConnection(conn)\n\nctx := getAuthorizedContext(c.Password)\nclient := pb.NewJSONSchemaServiceClient(conn)\n\nresponse, err := client.GenerateObject(ctx, buildRequest(prompt, definition))\nif err != nil {\n\treturn nil, fmt.Errorf(\"failed to call GenerateObject: %v\", err)\n}\n\nreturn buildResponse(response)\n```","severity":"Critical","rationale":"The code violates linesOfCode best practices by including excessive setup and teardown logic directly within the main function, resulting in 38 non-comment, non-blank lines. This verbosity makes the function harder to maintain and test, as responsibilities like connection management, context creation, and error handling are tightly coupled. For example, lines 9–36 could be refactored into helper functions (e.g., `setupConnection`, `createContext`, `handleResponse`) to reduce duplication and improve clarity. Excessive LoC increases cognitive load, raises the risk of bugs, and complicates future modifications. Reducing LoC through modularization would enhance maintainability and correctness.","lineStart":17,"lineEnd":49,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The GrpcGenerateObject function exhibits excessive cyclomatic complexity due to deeply nested error handling and resource management logic.\n\n```go\nconn, err := grpc.NewClient(c.BaseURL, grpc.WithInsecure(), grpc.WithBlock())\nif err != nil {\n\treturn nil, fmt.Errorf(\"failed to connect to server: %v\", err)\n}\ndefer func(conn *grpc.ClientConn) {\n\terr = conn.Close()\n\tif err != nil {\n\n\t}\n}(conn)\n```","codeResolution":"The solution for cyclomatic complexity in this context involves refactoring the monolithic request logic into smaller, focused abstractions, reducing branching and improving maintainability.\n\n```go\n// Replace the direct gRPC call with an abstracted operation\noperation := getOperation(\"GenerateObject\")\nresponse, err := operation.Execute(ctx, request)\n```","severity":"Critical","rationale":"The function’s cyclomatic complexity is elevated due to multiple error checks, nested resource management (connection and context), and sequential logic all packed into a single method. This increases the risk of hidden bugs, makes unit testing difficult, and complicates future changes. For example, lines handling connection setup, error handling, and response processing are tightly coupled, reducing readability and maintainability. Refactoring into smaller, focused helper functions would reduce complexity, making the code easier to test and less error-prone.","lineStart":22,"lineEnd":41,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The code violates functionMethodCounts by placing all logic—connection setup, context creation, metadata handling, request construction, and response processing—into a single monolithic function.\n\n```go\nfunc (c *Client) GrpcGenerateObject(prompt string, definition *pb.Definition) (*Response, error) {\n\t// Set up a connection to the gRPC server\n\tconn, err := grpc.NewClient(c.BaseURL, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect to server: %v\", err)\n\t}\n\tdefer func(conn *grpc.ClientConn) {\n\t\terr = conn.Close()\n\t\tif err != nil {\n\n\t\t}\n\t}(conn)\n```","codeResolution":"The GrpcGenerateObject function can be refactored to delegate connection setup, context creation, and response conversion to dedicated helper functions, improving separation of concerns and maintainability.\n\n```go\n// SendRequestToServer sends a request to the gRPC server with authorization headers\nfunc (c *Client) GrpcGenerateObject(prompt string, definition *pb.Definition) (*Response, error) {\n\tconn, err := setupConnection(c.BaseURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tctx := createAuthorizedContext(c.Password)\n\tclient := pb.NewJSONSchemaServiceClient(conn)\n\trequest := &pb.RequestBody{Prompt: prompt, Definition: definition}\n\n\tresponse, err := client.GenerateObject(ctx, request)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to call GenerateObject: %v\", err)\n\t}\n\treturn convertResponse(response)\n}\n```","severity":"Critical","rationale":"The functionMethodCounts issue here is significant because all logic is packed into a single method, `GrpcGenerateObject`. This violates separation of concerns, making the code harder to maintain and test. For example, connection setup, context creation, metadata handling, request construction, and response processing are all handled in one place (lines 10–54). If any part needs to change, the whole function risks breaking. Splitting these responsibilities into dedicated helper functions would improve readability, facilitate unit testing, and reduce the chance of introducing bugs during future modifications.","lineStart":16,"lineEnd":44,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A+","readability":"A-","testability":"A-"},"issues":{"cyclomaticComplexity":3,"dependenciesModules":6,"functionMethodCounts":1,"linesOfCode":59,"nestingDepth":2}},"hash":"4002a0ad8341fedb770cd4e9001e90ae7fb5088ce187c2faa1ded5913057009f","id":"eJylVE2P4zYM/SusgXbtwOO0VwO5jLdYtGh3Bskseqj3oMi0rcYWVYmejw7y3xeS7HzsLLCH5pAoJEW+90jqNRHOoXNKdw9EQ1ImFY1mwGfFL0meSGqwIs2oOSkTI+RBdAhyUKi51rVWoyHLkNa65jqRPvKZ6yT+bcfTsVPcT/tC0rhulUXZq9HckO3WHd245rCWpB/RKkc63jB7+P6lzhp5KkDUDVh0NAjdFSHou971iCwawWIJYzWiP2ee2noNO9TNFv+d0PED7dA+ogWHunEgwEY7MAH3CN32vgIXQ54U9yAm7smq/wQr0tCjaNC6WreTlpBKWFVBwww+WCM/oEYrGO/2/6Dk1FgaDYNjq3SXQ4Ot0iqkWZl98f70N4N0tUVnSDvMAa0lm8GrpxKwM0wGBEjSGmW4/harD/YB4TqUG/C6FB/xKcJLZXErHH7a/pFHz1+K+9+0QzlZTLML4+1A8pBmXjlWbcj2wwa0GiKgmi3yZLW35NCOXPzq4bZpnbRCDdh4bDNSf4zoSvjxsU4CtpD46L8abNGC1zH1F2AVMES8FWmdLRU9hk1IWlQDOUyzaH8LL5hD8mPImUXbeg2VRcEIAjQ+zWMPraXxWkclMQgZ/eUGzN5r+Pvu7uNO9jiKXQxaRP12iXl75vEBP4w0cUjMzzlIoSUOPvscGHR/iFHpYrsV8tBZmnTj2+NzFDuUpJvVLz9nZ/lisvSMYh6XZSMiCE/yeo6ZDhiujI1HsoR7tukozN9xZj/Hn9c6eb4RRt0c8KVOSpDFvXDuiWxzzGZacJ3jbuKOlO6qyCYNxMfmjVge2LKAFJbG+xdLuYGfzL6YN/eWmpd5Iu7DYpXgP3HJ8ug471R5sW75MnNzbTEM576PyD014DXpL15EtpcLGboVXMVXOx6YzYAzWK9hi2YQEuHddeC7i05InsQAF8W1GPF/LZxndF3vWyvnp0awODM6PdZFFY68YztJNvsH+lOYdJGgeC9YzL2z6EJflvdqBukjQj9CgWj75JqKHJdwyjNbLvsxs7Pock+x1sdaJ3nSqgHvBfdJmUTdw0N/TbHoKDl+AZnHggs="}
{"assessingTool":"Complexity","filePath":"converison/map.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:10:41.806Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A+","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":1,"functionMethodCounts":2,"linesOfCode":14,"nestingDepth":1}},"hash":"db34ceaafe42fda8838fe347297ccd88eab05e241911633238b73ccf0bf4280a","id":"eJx1kcFqhEAMhl9lyEmLOHdvxfOWQr3t9DBr43RYTYaZ2O0ivnvRxZba7S2Q///yQSawKWFKnlzD3EMFNQ+hx08vVyig5TesmQRJoIJg27N1qFqmD4w+MRky5IfAUZQBx+x6LB33llzJ0ekQWfg0dlquAZM+E19IJ4ljK+FkYGlrreoVJ2qw4ZgkenKvngRjZ1ucZiWsHrZO+bIOhrqR2q14sKHh2yIb/qHkKttDCoUxcszVZMhIRBkjqe/ME142ZG5o3qnuWYvk/cO/VW/phg82ZOkPJVfZfch91fIxLZy8UOT71REK6HyPz1beoYKfN+nBhtIxzF+Q0Lou"}
{"assessingTool":"Complexity","filePath":"converison/grpcConverison.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:10:38.288Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode disregards functionMethodCounts principles by embedding excessive logic within single functions, leading to poor separation of concerns.\n\n```go\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n\t// ... dozens of fields and nested conversions handled here ...\n}\n```","codeResolution":"The conversion logic currently mixes mapping, validation, and nested struct handling within single functions, which can be improved by delegating responsibilities to specialized helpers for better maintainability and clarity.\n\n```go\n// Go\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n\tif protoDef == nil {\n\t\treturn nil\n\t}\n\treturn convertDefinitionFromProto(protoDef)\n}\n```","severity":"Critical","rationale":"The code defines many helper functions, but the two main conversion functions—`ConvertProtoToModel` and `ConvertModelToProto`—are large and handle multiple responsibilities, such as field mapping, nil checks, and recursive property conversion. This violates functionMethodCounts principles by concentrating too much logic in single functions (see lines 7–44 and 52–89). Such monolithic functions hinder maintainability and make unit testing difficult, as changes in one part can have unintended side effects elsewhere. Breaking these into smaller, focused functions would improve readability, testability, and future extensibility.","lineStart":7,"lineEnd":77,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code violates dependenciesModules principles by tightly coupling the conversion logic to two specific external packages, making future maintenance and testing difficult.\n\n```go\nimport (\n\tpb \"github.com/firechimp-org/go-sdk/grpc\"\n\t\"github.com/firechimp-org/go-sdk/jsonSchema\"\n)\n```","codeResolution":"The solution for dependenciesModules demonstrates a clean separation between protobuf and Go model dependencies, using only the required packages for conversion logic. Here is the replacement code for the block identified in `violatingCode`:\n\n```go\n// Use the Operation abstraction for conversion\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n\treturn getOperation(\"protoToModel\").Execute(protoDef)\n}\n\nfunc ConvertModelToProto(modelDef *jsonSchema.Definition) *pb.Definition {\n\treturn getOperation(\"modelToProto\").Execute(modelDef)\n}\n```","severity":"Critical","rationale":"The code imports two external packages: `pb \"github.com/firechimp-org/go-sdk/grpc\"` and `\"github.com/firechimp-org/go-sdk/jsonSchema\"`. This is appropriate for the conversion logic, but tightly coupling the conversion functions to these specific packages can hinder maintainability and testability. If either package changes its API, all conversion functions must be updated, increasing technical debt. Abstracting dependencies behind interfaces or using dependency injection would allow easier mocking for unit tests and future-proof the code against upstream changes. This approach would also improve modularity and reduce the risk of breaking changes propagating throughout the codebase.","lineStart":3,"lineEnd":5,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The ConvertProtoToModel function exhibits excessive nestingDepth, particularly in its handling of the Properties map, which complicates readability and maintainability.\n\n```go\nif protoDef.Properties != nil {\n\tfor key, protoProperty := range protoDef.Properties {\n\t\tmodelDef.Properties[key] = *ConvertProtoToModel(protoProperty)\n\t}\n}\n```","codeResolution":"The solution for nestingDepth in this code focuses on flattening the handling of the Properties map to reduce cognitive complexity and improve maintainability. Replace the deeply nested block with a direct map transformation using a helper function:\n\n```go\n// Go\nmodelDef.Properties = convertPropertiesMap(protoDef.Properties)\n```\n\nThis approach eliminates manual iteration and nested assignments, delegating the transformation to a dedicated abstraction.","severity":"Critical","rationale":"The code demonstrates moderate nesting depth, especially in the `ConvertProtoToModel` and `ConvertModelToProto` functions (lines 8–44 and 47–83). Both use nested `if` statements and loops, particularly when handling the `Properties` map. Excessive nesting can make the code harder to read, maintain, and test, increasing the risk of logical errors and making future changes more error-prone. Flattening the structure—such as by using guard clauses or extracting deeply nested logic into helper functions—would improve maintainability and reduce cognitive load for future contributors.","lineStart":19,"lineEnd":37,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode suffers from excessive lines of code due to deeply nested struct field assignments and repetitive nil checks, making it harder to maintain and refactor.\n\n```go\nmodelDef := &jsonSchema.Definition{\n\tType:               jsonSchema.DataType(protoDef.Type),\n\tInstruction:        protoDef.Instruction,\n\tProperties:         make(map[string]jsonSchema.Definition),\n\tItems:              ConvertProtoToModel(protoDef.GetItems()), // Use Getters to handle nil cases\n\tModel:              protoDef.Model,\n\tProcessingOrder:    protoDef.ProcessingOrder,\n\tSystemPrompt:       getStringPointer(protoDef.GetSystemPrompt()), // Safe getter for pointers\n\tImprovementProcess: protoDef.ImprovementProcess,\n\tSelectFields:       protoDef.SelectFields,\n\tVoters:             protoDef.Voters,\n\tHashMap:            ConvertProtoToHashMap(protoDef.GetHashMap()),   // Check with Getters\n\tNarrowFocus:        ConvertProtoToFocus(protoDef.GetNarrowFocus()), // Handle nil safely\n\tReq:                ConvertProtoToRequestFormat(protoDef.GetReq()),\n\tChoices:            ConvertProtoToChoices(protoDef.GetChoices()),\n\tSpeechToText:       convertProtoSpeechToText(protoDef.GetSpeechToText()), // Safely handle nested structs\n\tTextToSpeech:       convertProtoTextToSpeech(protoDef.GetTextToSpeech()),\n\tSendImage:          convertProtoSendImage(protoDef.GetSendImage()), // Handle nil structs\n\tStream:             protoDef.Stream,\n}\n```","codeResolution":"The code currently handles conversion logic directly within the main functions, resulting in high lines of code and reduced clarity. To improve linesOfCode, delegate conversion responsibilities to dedicated abstraction functions and minimize inline logic.\n\n```go\n// Go\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n    return ProtoToModelConverter(protoDef)\n}\n\nfunc ConvertModelToProto(modelDef *jsonSchema.Definition) *pb.Definition {\n    return ModelToProtoConverter(modelDef)\n}\n```","severity":"Critical","rationale":"The code violates linesOfCode best practices by being overly verbose and repetitive, especially in the conversion functions (e.g., `ConvertProtoToModel`, `ConvertModelToProto`). Many lines are spent manually mapping fields and handling nil checks, which inflates the LoC and makes the code harder to maintain. For example, the repeated pattern of checking for nil and then assigning fields (lines 8–41, 49–82) could be abstracted into helper functions or generic mappers. Excessive LoC increases the risk of bugs, complicates future changes, and reduces readability. Refactoring to reduce duplication and improve abstraction would enhance maintainability and correctness.","lineStart":1,"lineEnd":87,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The ConvertProtoToModel function exhibits excessive cyclomatic complexity due to deep nesting and multiple conditional branches, making the code harder to maintain and test.\n\n```go\nif protoDef.Properties != nil {\n\tfor key, protoProperty := range protoDef.Properties {\n\t\tmodelDef.Properties[key] = *ConvertProtoToModel(protoProperty)\n\t}\n}\n```","codeResolution":"The solution for cyclomatic complexity refactors the property conversion logic to use a dedicated abstraction, reducing nested branching and improving maintainability.\n\n```go\n// Replace the Properties map conversion block with:\nmodelDef.Properties = convertPropertiesMap(protoDef.Properties)\n```","severity":"Critical","rationale":"The cyclomatic complexity in both `ConvertProtoToModel` and `ConvertModelToProto` is elevated due to numerous conditional branches and deep nesting, especially when handling properties and nested conversions (lines 8–41, 51–84). This matters because high complexity makes the code harder to maintain, increases the risk of bugs, and complicates unit testing. Each additional branch or nested structure adds a new path that must be tested and understood, which can slow down future development and debugging. Refactoring these functions into smaller, single-responsibility helpers would reduce complexity, improve readability, and make the codebase more robust.","lineStart":13,"lineEnd":87,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":15,"dependenciesModules":2,"functionMethodCounts":11,"linesOfCode":177,"nestingDepth":2}},"hash":"7ee0ba479b3f38bd7b0a818dec1f97bd7eb920d7e88b6335decaee3b25ca5158","id":"eJzlWU1v4zYQ/SusDkEceO27AB8KL/IBdNsgdvey3gMjj2U1EqmQdHbdIP+94KeGMuU4yd6aU8SZeZzhDN8jkueMSglSVqxccl5neTbnTVvDz0rts3FW8DXMOVPAVJZnLS0eaAmk4OwJRCU5W7EVq5qWC0XOV2yl2nuyyspKbXf3k4I3000loNhWTfuJi3Ja8k9y/TAtRVusMu3+uu8/krNFsYWG6oiR3m86JXOTgLoVXPEl/8LXULuklCSUtHr9frchn2FTsUpVnBHFyZ7vBLnipDH+nW3FNjtWpEDPDdJn2JCL9n7SRYzIRZcYWifPuqpqQ0LcbEZYVdv1lRKgdoLpFf39oqtZKZOO9s1n5CwJ66KX+xZyEv9gf6qodglJT/TXaGyDb5hUYldouIARHJHRud8K3oJQFchux4Y+wHlD229SiYqV35O5hv0UNLKX7bETnlyBjTkfjcZkOiV/SyBXoBQIqZu3pWxdgznMgkqQdheD0dslIBpjV09hx/wvsQaRR449owtZ7KWC5lbwplV+ixLUwhR/yyumQETp4wBfxYJuQEcpEGTDBWltnEv/pmkFf4IGmE8wR005MPrEoIZCXVZQr8MJhyhsdP5fud4xTx+SNTrPayq3X2gbucZNcx5R3X5Nl0x00fMtFA/kR6W2voMW/k8qBP9xyYtdl00Mb2wROIrxZ3rdjYKkG6j3Fv0OHvu3o4d+B487kOqSi4aqaJc7eNToFmi+5VUB8sgpOI8Iwq8FmEULUGyXfAk/w/wUCAbb4znCBjRH9T7cApAK1sReWne42nvpQFPbYXu0XWTosge2vmloiRknyt7b49TDaqJXONuFEkCbgZm0xjHiyA6pIybS0LZHtxNk/S1iXn33HmA/tq7Oba8pV1BWQhLBhXYMjYzfHmD/nczIxSCn+T1GFuUFVeNkwMOu2IvTtWuoW00UO1Z40bITrimEWNpFFGJk64CSnmjtXEfkwsV4XdK22YysslU2rEl+6eyJ1l1urlBT4ZKbejvNHZJWXUFSj2PNxaDnQQ/TGjvqaXGoLcSdoLkSUbUeAn0gPZgJpvPeNEXhM3KRjEHbheeAlvgo+yPSblsXjuNVNQ+O71Pz3gvndRlPNm1iAnx0Sp6D52vyjG/difKM++ILSEhsl+xbJLZr8mkSG/xPlVh8oF5TA4hb8Cd7REoxjNXNAIKiPNAR1cRAsXQGwDt4PEE1MZCXyQDhFsLA9TQH6Y6BseqCOkhLOEFxTWwkrF070apHOiKmthismd0NRasn6KjNKSgmmi+3FDASYtl5v1UsE2o2JJbG9VAsUwhBLBNK6sUyRRxn0R7DYulhB8VSmvc1buaY4IaMCWVrwtUWxOH7yarR4OtMog8jP9HMREKFLUGaovjX5CnI7wDq8yC3DgTYRwnOwXKvH6/fd+uKL/lSUCYLUd1DHiU8ObC7uD8oK3fxZEdx3u7vFLfvlCF3bw/uc9qaxuYD7t7uAiw35QMHYopw9BXh2LWRv0AvyWmI7rtCH2YaonsfTQO2hGmI4t8zDRg1PQ0DznYS8P7xJHzVVJxEMZY40iwhijJ/QjLHnEclTiJbulkDjYpgTmpUR6fS/2YvbODU+LYGp3BVw8q77qmPfkZqJvVfZvIOedKtDhZzqFcxBw1c9dEBO32Qg3pow9zjXqv/R5ZJlf7asB6+ImJWGbjAowO++SCr9NDS/XUFnswbKf9fyRYp/JMOPMkOqes7iknjI+yAcX4JK9gCqoPkUeJx0tWbE8bJullwZ26w4uYvqn917yMHvYZ7kY2zTVXDLVXbLM+6/x+Y/wXMw+ek5NnLfyWvvN4="}
{"assessingTool":"Complexity","filePath":"converison/hashmap.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:10:35.033Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode unnecessarily duplicates logic across two functions, inflating the linesOfCode count without abstraction.\n\n```go\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\tif protoHashMap == nil {\n\t\treturn nil\n\t}\n```","codeResolution":"The codeResolution streamlines the conversion logic by delegating field transformation to a reusable abstraction, reducing repetition and improving maintainability.\n\n```go\n// Replace the conversion block with a call to the abstraction.\nreturn &jsonSchema.HashMap{\n    KeyInstruction:  protoHashMap.KeyInstruction,\n    FieldDefinition: ConvertFieldDefinition(protoHashMap.FieldDefinition),\n}\n```","severity":"Critical","rationale":"### Rationale\n\nThe code snippet demonstrates good linesOfCode practices by keeping each function concise and focused on a single responsibility. This approach improves maintainability, as future changes or debugging efforts are simplified due to the clear separation of concerns. For example, `ConvertProtoToHashMap` and `ConvertModelToProtoHashMap` each handle only one conversion direction, reducing cognitive load. However, if the codebase grows and similar conversion patterns emerge, duplicating logic across multiple functions could increase LoC unnecessarily. Refactoring shared logic into helper functions would further reduce redundancy and enhance maintainability, making the codebase easier to test and less prone to errors.","lineStart":1,"lineEnd":20,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode only defines two functions, failing to separate responsibilities and thus violating functionMethodCounts best practices.\n\n```go\n// ConvertProtoToHashMap converts a protobuf HashMap to the Go model HashMap\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n    // ...\n}\n\n// ConvertModelToProtoHashMap converts a Go model HashMap to a protobuf HashMap\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n    // ...\n}\n```","codeResolution":"The conversion logic currently mixes data transformation and validation, which can be separated for better maintainability and testability. Here’s how the main conversion functions should be refactored to delegate responsibilities to specialized helpers:\n\n```go\n// Go\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\treturn convertProtoHashMap(protoHashMap)\n}\n\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n\treturn convertModelHashMap(modelHashMap)\n}\n```","severity":"Critical","rationale":"The code defines only two functions, each handling both validation and conversion logic. This low function count means responsibilities are not well separated, making the code harder to maintain and extend. For example, if validation rules or conversion logic change, both functions must be updated, increasing the risk of errors. Additionally, testing individual concerns (like validation or conversion) becomes difficult, reducing code reliability. Splitting responsibilities into smaller, focused functions would improve maintainability and correctness, aligning better with functionMethodCounts principles.","lineStart":7,"lineEnd":22,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The ConvertProtoToHashMap and ConvertModelToProtoHashMap functions do not present cyclomatic complexity concerns, as their logic is linear and contains only a single conditional branch.\n\n```go\nif protoHashMap == nil {\n\treturn nil\n}\n```","codeResolution":"The solution for cyclomatic complexity in this context focuses on reducing nested conditionals and flattening logic by delegating conversion responsibilities to specialized helper functions. This approach improves readability and maintainability.\n\n```go\n// Improved conversion using abstraction\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\treturn convertHashMapFromProto(protoHashMap)\n}\n\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n\treturn convertHashMapToProto(modelHashMap)\n}\n```","severity":"Critical","rationale":"## Rationale\n\nThe cyclomatic complexity in this code is low, with each function containing only a single conditional branch (`if ... == nil`). This simplicity improves maintainability and testability, as there are minimal paths to reason about and fewer opportunities for logic errors. However, if future requirements introduce more branching (e.g., additional validation or transformation logic), complexity could quickly increase. Keeping functions focused and limiting decision points ensures the code remains easy to understand and less error-prone. This approach aligns well with cyclomatic complexity principles, supporting correctness and maintainability.","lineStart":13,"lineEnd":22,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode unnecessarily nests return statements inside if-blocks, resulting in a nesting depth that could be avoided with guard clauses.\n\n```go\nif protoHashMap == nil {\n\treturn nil\n}\n```","codeResolution":"The codeResolution for nestingDepth focuses on flattening the control flow in the conversion functions by using guard clauses and delegating nested logic to helper abstractions. Replace the original block with the following streamlined code:\n\n```go\n// Go\n\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\tif protoHashMap == nil {\n\t\treturn nil\n\t}\n\treturn getHashMapFromProto(protoHashMap)\n}\n\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n\tif modelHashMap == nil {\n\t\treturn nil\n\t}\n\treturn getProtoHashMapFromModel(modelHashMap)\n}\n```","severity":"Critical","rationale":"The code demonstrates good adherence to nesting depth principles, with a maximum depth of 2 (function scope and a single 'if' statement). This shallow nesting makes the logic easy to follow and reduces cognitive load for future maintainers. Minimal nesting also lowers the risk of introducing bugs related to deeply nested conditions and simplifies unit testing. Keeping nesting depth low improves maintainability and readability, ensuring that future changes or extensions to the conversion logic can be made safely and efficiently.","lineStart":9,"lineEnd":13,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code tightly couples the conversion logic to two external packages, making future maintenance and testing more difficult.\n\n```go\nimport (\n\tpb \"github.com/firechimp-org/go-sdk/grpc\"\n\t\"github.com/firechimp-org/go-sdk/jsonSchema\"\n)\n```","codeResolution":"The codeResolution for dependenciesModules demonstrates a clean separation between protobuf and Go model conversions, relying only on two direct imports. Here is the improved replacement code, assuming all conversion helpers are abstracted:\n\n```go\n// Go\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\treturn convertHashMap(protoHashMap)\n}\n\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n\treturn convertHashMap(modelHashMap)\n}\n```\nThis approach delegates conversion logic to a shared abstraction, reducing duplication and improving maintainability.","severity":"Critical","rationale":"The code imports two external packages: `pb` and `jsonSchema` from the same organization. While this is acceptable for the conversion logic, tightly coupling the conversion functions to these specific dependencies can hinder maintainability. If either package changes its API or is replaced, all dependent code must be updated. Additionally, importing entire packages when only a few types are needed may increase build times and binary size. To improve, consider using interfaces or type aliases to decouple the conversion logic from direct package dependencies, making future refactoring and testing easier.","lineStart":1,"lineEnd":9,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":2,"functionMethodCounts":2,"linesOfCode":31,"nestingDepth":2}},"hash":"6f4ee198c5ee1648be167a3cf4511b5d1e3599367a81a668dc0dfd38e3ac62eb","id":"eJyVk0uLwyAUhf+KuBiakib7QFcd5sFQKEyXbowxidPkXlEzTCn974Np0sZ2HnSn93qO93zigXJrpbUKqi1iQzO6wlY38ku5PY2pwEKuEJwERzOqudjxShKB8CmNsggMGKhWo3FkxoA5nRNGK+XqLk8EtmmpjBS1avUCTZVWuLDFLq2MFoz64/+f/bAI76KWLfeKyN+XpmTVD+A2Bh1u8YXbes31MJazhBPtO3lXkrHnkLhakmckLRayGesMyg7Ez36z3mQ0mOs8GdYRmV/GGovk4AOpkgSq5ZKAak495ox0nQFf8fujD3MuPtxaDqo3uX8F60wnnELISHBDEnbjk+RJyaZ4lKUCddKEAdceQRAvuVJE8TDhMSTeK7e4mWacYL/G67HfPkYI/QfLWW9yJn9LJpo+x5l8oLqD/MXqN+JT5/uIT9MFsf4iTmNaqkZuuKtpRi+/La25rVuukwrp8RsIr2Ly"}
{"assessingTool":"SOLID","filePath":"converison/response.go","grade":"B","username":"HLamb","timestamp":"2025-10-12T17:10:32.090Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependencyInversion","violatingCode":"The ConvertStructpbToMap function directly depends on the concrete structpb types, violating dependency inversion by not abstracting its dependencies.\n\n```go\nfunc ConvertStructpbToMap(s *structpb.Struct) (map[string]any, error) {\n\tif s == nil {\n\t\treturn nil, fmt.Errorf(\"input structpb.Struct is nil\")\n\t}\n```","codeResolution":"The codeResolution introduces an abstraction layer for value conversion, enabling dependency inversion and improving testability and flexibility.\n\n```go\n// Replace direct calls to convertStructpbValue with the injected Operation abstraction\nfor key, value := range s.GetFields() {\n\tconvertedValue, err := op.Convert(value) // 'op' is an Operation interface instance\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresult[key] = convertedValue\n}\n```","severity":"Critical","rationale":"This code tightly couples conversion logic directly to the structpb types and concrete helper functions, violating dependency inversion principles. By depending on specific implementations (e.g., direct calls to ConvertStructpbToMap and convertStructpbValue), the code becomes harder to extend, test, or reuse with alternative data sources or conversion strategies. This rigid structure reduces maintainability and flexibility, as any change to the conversion logic or underlying types requires modifying core functions. Introducing abstractions (interfaces for conversion) would decouple the logic, making the codebase more adaptable and testable.","lineStart":7,"lineEnd":37,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"A+","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package converison\n\nimport (\n\t\"fmt\"\n\t\"google.golang.org/protobuf/types/known/structpb\"\n)\n\n// ConvertStructpbToMap converts *structpb.Struct to map[string]interface{}\nfunc ConvertStructpbToMap(s *structpb.Struct) (map[string]any, error) {\n\tif s == nil {\n\t\treturn nil, fmt.Errorf(\"input structpb.Struct is nil\")\n\t}\n\n\tresult := make(map[string]any)\n\n\tfor key, value := range s.GetFields() {\n\t\tconvertedValue, err := convertStructpbValue(value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresult[key] = convertedValue\n\t}\n\n\treturn result, nil\n}\n\n// Helper function to convert individual *structpb.Value to Go types\nfunc convertStructpbValue(value *structpb.Value) (any, error) {\n\tswitch v := value.GetKind().(type) {\n\tcase *structpb.Value_NullValue:\n\t\treturn nil, nil\n\tcase *structpb.Value_NumberValue:\n\t\treturn v.NumberValue, nil\n\tcase *structpb.Value_StringValue:\n\t\treturn v.StringValue, nil\n\tcase *structpb.Value_BoolValue:\n\t\treturn v.BoolValue, nil\n\tcase *structpb.Value_StructValue:\n\t\treturn ConvertStructpbToMap(v.StructValue)\n\tcase *structpb.Value_ListValue:\n\t\treturn convertStructpbList(v.ListValue)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported structpb.Value type: %T\", v)\n\t}\n}\n\n// Helper function to convert *structpb.ListValue to a Go slice\nfunc convertStructpbList(list *structpb.ListValue) ([]any, error) {\n\tresult := make([]any, len(list.GetValues()))\n\n\tfor i, value := range list.GetValues() {\n\t\tconvertedValue, err := convertStructpbValue(value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresult[i] = convertedValue\n\t}\n\n\treturn result, nil\n}\n","reason":"Modified","start":1,"end":61,"grade":"B"}]},"hash":"6b06647b1a864f80be8449917916e40b43b6a84081003893e59871ba5f15fd74","id":"eJzFVU1v2zAM/SucgAH2YNj3ALms27ph3QeQYpe6KFSbdoUolCFRLoIi/32Q7KSJ43bDLrsJ4uMjH0lRT0I6h84paq+N0WIhVj+uvnwQmahMjReGGInFQnSyWssWoTLUo1XOUEklqU1nLENSUsmlaDZciuHYGtNqzFujJbW5sW3RWcPm3jcFbzt0xZrMIxWOra+4uw9uaSAsCriIEXg1mq7NN9mNYdnBu71LPgCADWxkd+PYKmpvFTHaRlb4tCup8VTN0iXnPCkkRzSSthmgtcam8BQUqQYcLJdASg8XJVtkbyncZNBsOP8Y4E1SCkWdZ5jmqVyAliLI5F3QGiic1wyLJWzkGicJpAOmMRbWuM2gl9pjwFpJLYLLL5E/KdS1S9J9TmOZsP4VwFFC8KhOaxCNSeRLBz/VROibE4GnEtHa4Xq3lx9yv1nj9hYOEcbAJxIjxYDOYgloN3b6M+oOLYQ2sTIUWjnygKJa9ar2Uh91KnIH1KWBOEVji1+WN3VOITlrrXtUXD1AHwoVnUJhvyqqkzRPQpgRV0l3xnf33WsdT4vzoYhaX/Tb3KOd8ezzI9PrHKs4KrMcR6bXOd4bM5d/nx8Mf8zBVzzDMPvs+vwIn75IeqXcHOWkzQGV9PkBHPlqbKTXPNONkyfqyfkurC6sYTpe2w4X8Pa6FBn0+8f6FxP7LOKQUTDLMKxOqwrnhzWq0MrNEqSQ3JzvosnWGBEaKfKE6Y3OLknTox2izjbIFP3/loj6lxUiMtEojT8lP4iFeP6XCouuM+TC7yN2vwEVRY/A"}
{"assessingTool":"Complexity","filePath":"client/processResponse.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:10:31.368Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode suffers from excessive vertical space and redundant error handling, resulting in unnecessary lines of code.\n\n```go\ndefer func(Body io.ReadCloser) {\n\terr := Body.Close()\n\tif err != nil {\n\t\tfmt.Println(\"Error closing body\")\n\t}\n}(resp.Body)\n```","codeResolution":"The code can be streamlined by delegating response parsing and error handling to dedicated helper functions, reducing lines of code and improving clarity.\n\n```go\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n\tdefer resp.Body.Close()\n\tif err := validateStatus(resp.StatusCode); err != nil {\n\t\treturn nil, err\n\t}\n\treturn parseResponse(resp.Body)\n}\n```","severity":"Critical","rationale":"## Rationale\n\nThe code snippet contains several lines that could be consolidated to reduce overall lines of code (LoC) without sacrificing readability. Excessive LoC, as seen in the verbose error handling and repeated struct initialization, increases maintenance overhead and makes future changes more error-prone. For example, the explicit defer function for closing the body could be simplified, and error messages could be handled more concisely. Reducing LoC improves maintainability and readability, making it easier to test and refactor the code. Streamlining logic also helps prevent bugs that arise from duplicated or scattered code.","lineStart":13,"lineEnd":29,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode exhibits excessive nestingDepth by embedding multiple control structures within a single function, reducing readability and maintainability.\n\n```go\nif resp.StatusCode != http.StatusOK {\n    return nil, fmt.Errorf(\"received non-200 response code: %d\", resp.StatusCode)\n}\nvar response Response\nif err := json.NewDecoder(resp.Body).Decode(&response); err != nil {\n    return nil, fmt.Errorf(\"error decoding response: %v\", err)\n}\n```","codeResolution":"The ResponseProcessor's ProcessResponse method can be refactored to reduce nesting depth by using guard clauses for error handling and early returns.\n\n```go\n// Go\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"received non-200 response code: %d\", resp.StatusCode)\n\t}\n\t\n\tvar response Response\n\terr := json.NewDecoder(resp.Body).Decode(&response)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error decoding response: %v\", err)\n\t}\n\treturn &response, nil\n}\n```","severity":"Critical","rationale":"## Rationale\n\nDeep nesting in `ProcessResponse` (e.g., nested `if` statements and a deferred function) increases cognitive complexity and makes the code harder to follow and maintain. If additional error handling or logic is added, the nesting will grow, further reducing readability and increasing the risk of subtle bugs. Flattening the structure with guard clauses or extracting logic into helper functions would improve maintainability and testability, making future changes less error-prone.","lineStart":22,"lineEnd":34,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode only defines a single method for all response processing, failing to separate concerns and violating functionMethodCounts best practices.\n\n```go\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n\tdefer func(Body io.ReadCloser) {\n\t\terr := Body.Close()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error closing body\")\n\t\t}\n\t}(resp.Body)\n```","codeResolution":"The ResponseProcessor's ProcessResponse method should be refactored to delegate responsibilities to specialized helper functions, improving functionMethodCounts and separation of concerns.\n\n```go\n// Go\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n\tdefer closeBody(resp.Body)\n\tif err := validateStatus(resp.StatusCode); err != nil {\n\t\treturn nil, err\n\t}\n\treturn decodeResponse(resp.Body)\n}\n```","severity":"Critical","rationale":"### Rationale\n\nThe code defines only one main method for processing responses, violating functionMethodCounts best practices. This concentration of logic in a single function makes the code harder to maintain and test, as changes to one responsibility (e.g., error handling, decoding) risk affecting others. For example, error handling for closing the body and decoding JSON are both handled inside `ProcessResponse`, increasing complexity and the chance of bugs. Separating these concerns into dedicated functions would improve readability, facilitate unit testing, and reduce the risk of regressions.","lineStart":7,"lineEnd":28,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The ProcessResponse method introduces unnecessary branching and nested error handling, resulting in elevated cyclomatic complexity.\n\n```go\nif resp.StatusCode != http.StatusOK {\n    return nil, fmt.Errorf(\"received non-200 response code: %d\", resp.StatusCode)\n}\n```","codeResolution":"The solution for cyclomatic complexity refactors the main decision logic into a single, focused abstraction, reducing nested branching and improving maintainability. Replace the original block with the following streamlined code:\n\n```go\n// Go\noperation := getOperation(resp.StatusCode)\nresult, err := operation.Execute(resp.Body)\nif err != nil {\n    return nil, fmt.Errorf(\"error processing response: %v\", err)\n}\nreturn result, nil\n```","severity":"Critical","rationale":"## Rationale\n\nHigh cyclomatic complexity in `ProcessResponse` arises from multiple branching paths: error handling for closing the body, status code checks, and JSON decoding. This increases the risk of missed edge cases and makes the function harder to test and maintain. If more conditions are added, the complexity will grow, making future changes error-prone. Refactoring into smaller, single-responsibility functions (e.g., separate body closing, status validation, and decoding) would reduce complexity, improve readability, and enhance testability.","lineStart":22,"lineEnd":38,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code strictly adheres to dependenciesModules principles, importing only essential standard libraries without introducing unnecessary external dependencies.\n\n```go\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n```","codeResolution":"The code demonstrates a clear and minimal use of dependencies, relying only on standard library packages for HTTP handling, JSON parsing, and I/O operations. To further improve modularity and separation of concerns, the response processing logic can be abstracted to use a dedicated interface for parsing, assuming a `ResponseParser` interface is defined elsewhere.\n\n```go\n// Replace the decoding block with an abstraction:\nif err := parser.Parse(resp.Body, &response); err != nil {\n    return nil, fmt.Errorf(\"error parsing response: %v\", err)\n}\n```","severity":"Critical","rationale":"## Rationale\n\nThe code imports four standard packages: `encoding/json`, `fmt`, `io`, and `net/http`. While all are necessary for HTTP response handling and JSON decoding, excessive or unnecessary imports can lead to bloated binaries and increased attack surface. For example, if `fmt` is only used for error logging, consider using a more robust logging package or centralizing error handling. Keeping dependencies minimal improves maintainability, reduces potential for version conflicts, and makes the codebase easier to audit and test. Regularly reviewing imports ensures only essential modules are included, supporting better long-term project health.","lineStart":3,"lineEnd":7,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A+","readability":"A","testability":"A-"},"issues":{"cyclomaticComplexity":3,"dependenciesModules":4,"functionMethodCounts":3,"linesOfCode":38,"nestingDepth":2}},"hash":"5b18b197dc300f83f0aa0d6d7e3530ab0b54d442ea88e9661bc35e3fb5250ae6","id":"eJx1U0uP0zAQ/iuDpUXJKqQrjkG9UJCQkJaq9OiLN560Bncc2dOWUvW/Iztx9tFys+fxPTzjs1AhYAiGNmvnrGjEwu16i38Mn0QlWqdx4YiRWDSiV+1vtUForUFiSZLMrneeoZAkWQqk1mlDm9mv4EiKIdjtOB+NyydCnm2Z+3gvI9BsBisMvaOAS+9aDMF58EPEPFmEznnoh4yhDfAW4dt6vcw1KIlPPd4ACez3LZ8vI8sjHq9rDBk2ypq/GEAB4fEaR1K3p/Zme1HeoD1Hox557+k6G9VkQWMw12STGJLHbA8UaRjghkSvfEA9QY82R5WF7+H+irV8y1VEdLiPg6hzrIRi6qwAvY99yYzGDj1E/OKz0ycwrl6h0gvrAuYayeg9NHOIFXVKFeWQMF1Eg3dzIGNzteRux/XSG2JLhRRfIx+01qUhPzl9kmLsj+/FlyS5juhpbRJsCv1kxfuwcBojRbI0hH58z2TjNMjYCiJtIusKKTy2aA6ogRx9+Pjw8Pzqcf8buNNSVG9pkqzLIOKg/HPPatrIyXQzh/gl6kc8fsGI6V/4qIdQ8T4jlJ9uvNR/xacRgcbh600yGrg7RNXo/UulI8zEVUXEtIyiEp2xuFS8FY0Yvvisf70w9caJyz9tsow2"}
{"assessingTool":"Complexity","filePath":"client/req.go","grade":"B","username":"HLamb","timestamp":"2025-10-12T17:10:28.922Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"testability","violatingCode":"The SendRequest function has poor testability due to direct logging and returning nil on error, making it hard to assert error handling in tests.\n\n```go\nif err != nil {\n    log.Println(\"failed to execute request\", err)\n    return nil\n}\n```","codeResolution":"The current SendRequest implementation tightly couples logging and error handling, making unit testing difficult. Refactor to return errors and results separately, improving testability and separation of concerns:\n\n```go\n// Go\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) (*Res, error) {\n\trequest, err := ExecuteRequest(currentGen, def)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to execute request: %w\", err)\n\t}\n\tvalue, err := extractValue(request)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to extract value: %w\", err)\n\t}\n\treturn value, nil\n}\n```","severity":"Medium","rationale":"The use of direct logging (`log.Println`) and returning `nil` in `SendRequest` makes the code difficult to test, as error handling is tightly coupled with side effects and not exposed to the caller. This prevents unit tests from verifying error scenarios or capturing error details, reducing maintainability and correctness. For example, lines where errors are logged and `nil` is returned (`log.Println(\"failed to execute request\", err); return nil`) obscure the root cause and make debugging harder. Refactoring to return errors instead of logging them would improve testability, allowing tests to assert specific error conditions and making the codebase easier to maintain and extend.","lineStart":44,"lineEnd":54,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode suffers from excessive nesting within the ExecuteRequest function, making the logic harder to follow and maintain.\n\n```go\nif d.Req.Body == nil {\n\td.Req.Body = make(map[string]interface{})\n}\nfor key, value := range currentGen {\n\td.Req.Body[key] = value\n}\n```","codeResolution":"The solution for nestingDepth refactors the SendRequest function to use guard clauses, reducing unnecessary nesting and improving readability.\n\n```go\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\trequest, err := ExecuteRequest(currentGen, def)\n\tif err != nil {\n\t\tlog.Println(\"failed to execute request\", err)\n\t\treturn nil\n\t}\n\tvalue, err := extractValue(request)\n\tif err != nil {\n\t\tlog.Println(\"failed to extract value\", err)\n\t\treturn nil\n\t}\n\treturn value\n}\n```","severity":"Critical","rationale":"The code demonstrates moderate nesting depth, particularly in the `ExecuteRequest` function, where multiple layers of logic (body merging, marshaling, request creation, header setting, and execution) are handled sequentially within a single function scope. This approach can hinder maintainability, as future changes or debugging efforts require navigating through tightly coupled steps. Deep nesting also increases cognitive load and the risk of introducing subtle bugs, especially if error handling or branching logic expands. Refactoring into smaller, single-responsibility functions (e.g., separate body preparation, request creation, and execution) would flatten the structure, making the code easier to test, extend, and reason about.","lineStart":17,"lineEnd":38,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode suffers from excessive lines of code due to deeply nested logic and repeated procedural steps within the ExecuteRequest function.\n\n```go\nfor key, value := range currentGen {\n    d.Req.Body[key] = value\n}\nbody, err := json.Marshal(d.Req.Body)\nreq, err := http.NewRequest(string(d.Req.Method), d.Req.URL, bytes.NewBuffer(body))\n```","codeResolution":"The solution streamlines the code by replacing verbose request execution logic with a concise abstraction, reducing lines of code and improving maintainability.\n\n```go\n// Go\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\trequest, err := ExecuteRequest(currentGen, def)\n\tif err != nil {\n\t\tlog.Println(\"failed to execute request\", err)\n\t\treturn nil\n\t}\n\tvalue, err := extractValue(request)\n\tif err != nil {\n\t\tlog.Println(\"failed to extract value\", err)\n\t\treturn nil\n\t}\n\treturn value\n}\n```\nReplace the above block with:\n\n```go\n// Go\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\treturn RequestHandler(def, currentGen)\n}\n```","severity":"Critical","rationale":"## Rationale\n\nThe code snippet demonstrates excessive lines of code within single functions, notably in `ExecuteRequest`, which handles multiple responsibilities—merging data, marshaling JSON, building requests, setting headers, and executing HTTP calls. This violates linesOfCode principles by making the code harder to maintain and test. Long, monolithic functions increase cognitive load, obscure bugs, and complicate future changes. Refactoring into smaller, purpose-driven functions (e.g., separate header-setting, body-merging, and request-execution) would improve readability, facilitate unit testing, and reduce the risk of errors. Reducing LoC per function directly enhances maintainability and correctness.","lineStart":22,"lineEnd":54,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The code violates functionMethodCounts principles by combining multiple responsibilities into just two functions, resulting in a monolithic and less maintainable design.\n\n```go\nfunc ExecuteRequest(currentGen map[string]any, d *jsonSchema.Definition) (*http.Response, error) {\n\t// Merge currentGen into the existing body\n\t// Marshal the body to JSON\n\t// Create the HTTP request\n\t// Set headers and authorization\n\t// Execute the request\n}\n```","codeResolution":"The solution for functionMethodCounts involves refactoring monolithic logic into smaller, purpose-driven functions to improve maintainability and clarity.\n\n```go\n// Go\n\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\trequest, err := ExecuteRequest(currentGen, def)\n\tif err != nil {\n\t\tlog.Println(\"failed to execute request\", err)\n\t\treturn nil\n\t}\n\n\tvalue, err := extractValue(request)\n\tif err != nil {\n\t\tlog.Println(\"failed to extract value\", err)\n\t\treturn nil\n\t}\n\n\treturn value\n}\n```\nReplace the above with:\n\n```go\n// Go\n\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\trequest, err := buildAndDispatchRequest(def, currentGen)\n\tif err != nil {\n\t\tlog.Println(\"failed to execute request\", err)\n\t\treturn nil\n\t}\n\treturn handleResponse(request)\n}\n```","severity":"Critical","rationale":"## Rationale\n\nThe code defines only two functions—`ExecuteRequest` and `SendRequest`—each handling multiple responsibilities such as request construction, header management, error handling, and response extraction. This low function/method count leads to tightly coupled logic, making the code harder to maintain, test, and extend. For example, lines 10–38 in `ExecuteRequest` mix body merging, JSON marshaling, HTTP request creation, and header setting. Such monolithic functions hinder readability and increase the risk of bugs when requirements change. Breaking these responsibilities into smaller, focused functions would improve maintainability and correctness, and make unit testing more effective.","lineStart":18,"lineEnd":38,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The ExecuteRequest function disregards cyclomatic complexity principles by combining multiple responsibilities and branching logic into a single, monolithic block.\n\n```go\nfor key, value := range currentGen {\n    d.Req.Body[key] = value\n}\n```","codeResolution":"The solution for cyclomatic complexity refactors the original request execution logic by delegating each major step to specialized helper functions, reducing branching and improving readability.\n\n```go\n// Go\nfunc ExecuteRequest(currentGen map[string]any, d *jsonSchema.Definition) (*http.Response, error) {\n\tmergeBody(currentGen, d)\n\tbody, err := marshalBody(d)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq, err := buildRequest(d, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn sendRequest(req)\n}\n```","severity":"Critical","rationale":"High cyclomatic complexity in `ExecuteRequest` arises from multiple responsibilities—merging maps, marshaling JSON, building requests, setting headers, and handling errors—all within a single function. This increases the number of decision points (e.g., multiple `if err != nil` checks and loops), making the code harder to maintain and test. If any part fails, debugging becomes difficult due to tightly coupled logic. Refactoring into smaller, focused functions (e.g., separate body merging, request creation, and error handling) would reduce complexity, improve readability, and make future changes safer and easier.","lineStart":22,"lineEnd":44,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code unnecessarily imports six packages, including both standard and third-party libraries, which increases complexity and potential maintenance overhead.\n\n```go\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/firechimp-org/go-sdk/jsonSchema\"\n\t\"log\"\n\t\"net/http\"\n)\n```","codeResolution":"The code demonstrates solid dependency management by relying only on standard libraries and a single external package, keeping the module footprint minimal. To further improve modularity and separation of concerns, the request execution logic can be abstracted using an `Operation` interface. Here’s how the core block can be replaced:\n\n```go\n// Go\n\nop := getOperation(d.Req.Method)\nresp, err := op.Execute(d.Req.URL, d.Req.Headers, d.Req.Authorization, d.Req.Body)\nif err != nil {\n\tlog.Println(\"failed to execute request\", err)\n\treturn nil\n}\n```","severity":"Critical","rationale":"This code imports six packages, including a third-party dependency (`github.com/firechimp-org/go-sdk/jsonSchema`). While the use of standard libraries is justified for HTTP requests and JSON handling, the direct coupling to the external `jsonSchema` package on multiple lines (e.g., lines 7, 13, 34) increases the risk of breaking changes if the dependency updates. Excessive dependencies can hinder maintainability, complicate upgrades, and introduce hidden bugs. To improve, consider abstracting interactions with `jsonSchema` behind interfaces or limiting its usage to dedicated modules, reducing the impact of future changes and making unit testing easier.","lineStart":6,"lineEnd":38,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A-","qualityDesign":"A","readability":"A-","testability":"C+"},"issues":{"cyclomaticComplexity":6,"dependenciesModules":6,"functionMethodCounts":2,"linesOfCode":69,"nestingDepth":2}},"hash":"b3b7aa075e2ccf03262a5580bbb9703d2d488905316e76a7b776f7bf8b154bb5","id":"eJyllFFv00AMx7+KOQmUTFnyXmkPMAYIsTG1gxfCwzVxkqOJr7tz6MrU747ucmlTUDcJXqqez2f/7L/jRyGtRWsV1Xdat2ImLnW3bvFB8VYkotAlXmpiJBYzsZbFStYIRauQOKecVLfWhiHKKedcLLeMNhfDAanQpaI6+2E1jcaq4/Fvrbjpl2mhu6xSBotGdetzbeqs1ue2XPlni6LBTo4vWl2Pfwk5a5jX7hw7kCyDqwcsesY53vdoGXA4WpAEH+7ubsGEi6W0WIIm4AYheL/TppOcU9VT8UegqOiNQeL3SNDJ9TfLRlH9XdI2gRLODpjpW6wUKVaaYojOHF46R7vWZDEBNEabGB4df5bBNRrXyENoRaw9ET4oy4pqWOpy67xVBWU6x/v0jS63cHEBpNohTs7TC+jkCqMJoiJGU8kCH3euR7xzP5U2sMJtAj9l2yPMLsBIOkb5K/a3FW6/w8XwZIwU6pDGNrL15A4YWMPHxecbd+3OvnCXxfUpDd7RIXQcKnReL45KM8i9IWdJoOo4vXINrKJcVFK1WLpEXUjuEs3g5SYXPl18jHhpUDJ6wukcuFuD93tAr9cNbkbZhyYG1GvkRpdxEpT4Mv+UgJ929+JNX1VoIkcR/1c9xUAaAE9XtECGBmWJxj4l6cD6YXA8YIymdIEcHd4dRiRkkD032qhf0k106Nb0aS5eH3mIsTtH5nhPHT4rL8REg2GZOOpXXoJLf37cDRntei/Q4Ji+1ZHB+//qc1gNzzQ6BBoYSLU57cKm8cOOrd6ALoreWNgobtSwUPxHR7KFjTYrRbWFSIG7XcVhvSyQynHISqxOrJAETu6dGM7maMdVMmkncCMZlAXrOqp7BkIsrSvZIpXeIse4LijoykPXSGgku7W4/IEFp2MHfNi9AicXYwIlVqclaXWd3hpF3NJTOkw1mOo40cRP6p4HH9jIgr86YxSC/AuFjxK22/MMwRiW4S4nkYhKtXgruREzMYxp5j6WWovdb8iNqRE="}
{"assessingTool":"SOLID","filePath":"converison/requestFormat.go","grade":"C","username":"HLamb","timestamp":"2025-10-12T17:10:23.580Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"openClosed","violatingCode":"The conversion functions tightly couple the logic to specific struct fields, making it hard to extend for new fields or types without modifying existing code.\n\n```go\nreturn &jsonSchema.RequestFormat{\n\tURL:           protoReq.Url,\n\tMethod:        jsonSchema.HTTPMethod(protoReq.Method),\n\tHeaders:       protoReq.Headers,\n\tBody:          body,\n\tAuthorization: protoReq.Authorization,\n\tRequireFields: protoReq.RequireFields,\n}\n```","codeResolution":"The current ConvertProtoToRequestFormat and ConvertModelToProtoRequestFormat functions can be improved for openClosed compliance by delegating conversion logic to an Operation abstraction. Here is the replacement code for the violating block:\n\n```go\ngo\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\treturn getOperation(\"ProtoToModel\").Convert(protoReq)\n}\n\nfunc ConvertModelToProtoRequestFormat(modelReq *jsonSchema.RequestFormat) *pb.RequestFormat {\n\treturn getOperation(\"ModelToProto\").Convert(modelReq)\n}\n```","severity":"High","rationale":"The current implementation violates the Open/Closed Principle because any changes to the structure of `RequestFormat` in either the protobuf or Go model require direct modification of both conversion functions. This tightly couples the conversion logic to the data models, making future extensions or new fields error-prone and harder to maintain. As a result, adding or updating fields increases the risk of bugs and reduces scalability, since developers must update multiple places and manually ensure consistency. Refactoring to use reflection or generic mapping would allow the code to adapt to changes without requiring direct edits, improving maintainability and adherence to open/closed.","lineStart":13,"lineEnd":22,"status":""},{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The code lacks interface abstraction, preventing substitutability and violating the Liskov Substitution Principle.\n\n```go\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\tif protoReq == nil {\n\t\treturn nil\n\t}\n\t// ...\n}\n```","codeResolution":"The current conversion functions can be improved for Liskov Substitution Principle by abstracting the conversion logic through an Operation interface, allowing interchangeable conversion strategies.\n\n```go\n// Golang\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n    return getOperation(\"ProtoToModel\").Convert(protoReq)\n}\n\nfunc ConvertModelToProtoRequestFormat(modelReq *jsonSchema.RequestFormat) *pb.RequestFormat {\n    return getOperation(\"ModelToProto\").Convert(modelReq)\n}\n```","severity":"High","rationale":"The lack of interface abstraction in the conversion functions directly violates the Liskov Substitution Principle. By tightly coupling the conversion logic to specific types (`pb.RequestFormat` and `jsonSchema.RequestFormat`), the code cannot easily accommodate alternative implementations or extended types. This rigidity reduces maintainability, as any future changes or new formats require modifying existing functions rather than substituting new implementations. It also impacts correctness, since substitutability is limited and polymorphic behavior is not supported, increasing the risk of errors if requirements evolve. Introducing interfaces for request formats would allow for more flexible, testable, and extensible code.","lineStart":1,"lineEnd":28,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code tightly couples conversion logic directly to concrete types from external packages, violating dependency inversion by not abstracting dependencies.\n\n```go\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\tif protoReq == nil {\n\t\treturn nil\n\t}\n```","codeResolution":"To address dependency inversion, the conversion logic should delegate to an injected abstraction rather than directly calling conversion helpers. Here is the replacement for the violating code block:\n\n```go\n// Golang\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat, op Operation) *jsonSchema.RequestFormat {\n\tif protoReq == nil {\n\t\treturn nil\n\t}\n\n\tbody, _ := op.Convert(protoReq.Body)\n\n\treturn &jsonSchema.RequestFormat{\n\t\tURL:           protoReq.Url,\n\t\tMethod:        jsonSchema.HTTPMethod(protoReq.Method),\n\t\tHeaders:       protoReq.Headers,\n\t\tBody:          body,\n\t\tAuthorization: protoReq.Authorization,\n\t\tRequireFields: protoReq.RequireFields,\n\t}\n}\n```","severity":"Critical","rationale":"This code tightly couples conversion logic to specific protobuf and Go model types, violating dependency inversion principles. By directly referencing concrete types (e.g., `pb.RequestFormat`, `jsonSchema.RequestFormat`) in conversion functions, it becomes difficult to extend or test the code without modifying these functions. This reduces maintainability and flexibility, as any change in the underlying types or conversion requirements would require direct updates to the conversion logic. Introducing interfaces or abstraction layers would decouple the conversion process, making the codebase easier to maintain and adapt to future changes.","lineStart":7,"lineEnd":24,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"C-","openClosedScore":"C-","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package converison\n\nimport (\n\tpb \"github.com/firechimp-org/go-sdk/grpc\"\n\t\"github.com/firechimp-org/go-sdk/jsonSchema\"\n)\n\n// ConvertProtoToRequestFormat converts a protobuf RequestFormat to the Go model RequestFormat\nfunc ConvertProtoToRequestFormat(protoReq *pb.RequestFormat) *jsonSchema.RequestFormat {\n\tif protoReq == nil {\n\t\treturn nil\n\t}\n\n\tbody, _ := ConvertStructToMap(protoReq.Body)\n\n\treturn &jsonSchema.RequestFormat{\n\t\tURL:           protoReq.Url,\n\t\tMethod:        jsonSchema.HTTPMethod(protoReq.Method),\n\t\tHeaders:       protoReq.Headers,\n\t\tBody:          body,\n\t\tAuthorization: protoReq.Authorization,\n\t\tRequireFields: protoReq.RequireFields,\n\t}\n}\n\n// ConvertModelToProtoRequestFormat converts a Go model RequestFormat to a protobuf RequestFormat\nfunc ConvertModelToProtoRequestFormat(modelReq *jsonSchema.RequestFormat) *pb.RequestFormat {\n\tif modelReq == nil {\n\t\treturn nil\n\t}\n\n\tbody, _ := ConvertMapToStruct(modelReq.Body)\n\n\treturn &pb.RequestFormat{\n\t\tUrl:           modelReq.URL,\n\t\tMethod:        string(modelReq.Method),\n\t\tHeaders:       modelReq.Headers,\n\t\tBody:          body,\n\t\tAuthorization: modelReq.Authorization,\n\t\tRequireFields: modelReq.RequireFields,\n\t}\n}\n","reason":"Modified","start":1,"end":43,"grade":"C"}]},"hash":"121ba767a241f9db617493c6b60a8fe8d4b7fd92081fd53809d40e42bc082a12","id":"eJydlFFvmzAQx7+K5YcpVDS8I+Vha9V2UqJFCXlDmgwc4BV81D4mdVW++2SgBrrQVeXNd/+7+5/9Ey9cGAPGSFVEiBUP+fHH9vst93mKGdygIlDEQ96I9FEUwFJUv0FLgypWsZJ1g5rYKlYxNQmLeSGpbJN1inWQSw1pKevmGnURFHhtsseg0E0acyv/v/aXQXVMS6iFrfDsvCBgN50B2mskjPAATy0YukNdCxrMkWGCNTaftDmbKwgZlcDukdWYQTXPxipvVfrehFXX9gBP7KpJ1rOUx65Gw/MUe7ELy5y56s2GKVn18Zg0UKuVjdjz2S4aU4LZs89+snDzauhIuk0pwp1onI/1N8yevb5iaPNlycYw7XTYhmz8XKeTrvxesQMqMXOiSb+HKNr32dFBf/aG2gcQGWgTvu0+xAeVdT0x0e3aZ762VKKWfwRJVOFYP4sPWrud1HAnocrMRDuL+8Odnuf87OzzR7gfai5DdBkTC9ESYHOEFoesurYdR0uv5f2LmOPIVX+Ko51oIuxhcj4ucfR2/Cs/upry4zqcDtvL/BjSUhXjqHeBcapPAuPqPwCM0y4Bw32eywr2gkoe8vHXF+jpvawL5Oe/f/rq4g=="}
{"assessingTool":"Complexity","filePath":"client/extractValue.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:10:21.106Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"nestingDepth","violatingCode":"The extractValue function unnecessarily increases nesting depth by embedding error handling and logic within multiple if statements and a deferred closure.\n\n```go\nif resp.StatusCode != http.StatusOK {\n\treturn nil, fmt.Errorf(\"request failed with status: %s\", resp.Status)\n}\n\nbody, err := io.ReadAll(resp.Body)\nif err != nil {\n\treturn nil, fmt.Errorf(\"error reading response body: %w\", err)\n}\n```","codeResolution":"The extractValue function’s nesting depth can be reduced by using guard clauses for error handling, improving readability and maintainability.\n\n```go\nfunc extractValue(resp *http.Response) (*Res, error) {\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"request failed with status: %s\", resp.Status)\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading response body: %w\", err)\n\t}\n\n\tvar res Res\n\tif err := json.Unmarshal(body, &res); err != nil {\n\t\treturn nil, fmt.Errorf(\"error unmarshalling response body: %w\", err)\n\t}\n\n\treturn &res, nil\n}\n```","severity":"Critical","rationale":"### Rationale\n\nDeep nesting in `extractValue` (lines 15–36) increases cognitive complexity, making the code harder to read and maintain. Multiple layers of error handling and resource management are embedded within the main logic, which can obscure the function’s intent and complicate future changes or debugging. Excessive nesting also hinders unit testing, as tightly coupled branches are difficult to isolate. Refactoring with guard clauses or splitting responsibilities into helper functions would flatten the structure, improving maintainability and reducing the risk of subtle bugs.","lineStart":22,"lineEnd":28,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code adheres to dependenciesModules principles by only importing necessary standard library packages, resulting in a clean and maintainable dependency footprint.\n\n```go\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n```","codeResolution":"The solution for dependenciesModules demonstrates a minimal and focused use of standard library packages, ensuring clarity and maintainability.\n\n```go\npackage client\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n)\n\n// extractValue now delegates error handling and body closing to helper functions.\nfunc extractValue(resp *http.Response) (*Res, error) {\n\tif err := checkResponse(resp); err != nil {\n\t\treturn nil, err\n\t}\n\tbody, err := readBody(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn parseRes(body)\n}\n```","severity":"Critical","rationale":"The rationale for dependenciesModules is to ensure that only necessary packages are imported, minimizing bloat and reducing the attack surface. In the provided code, all imported packages (`encoding/json`, `fmt`, `io`, `net/http`) are standard and directly used, which is good practice. However, unnecessary imports or unused dependencies can lead to increased binary size, slower builds, and confusion for maintainers. Keeping dependencies minimal and relevant improves maintainability, reduces potential vulnerabilities, and makes the codebase easier to audit and update.","lineStart":3,"lineEnd":6,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The code violates functionMethodCounts principles by placing all logic—error handling, reading, and unmarshalling—inside a single function, reducing maintainability and clarity.\n\n```go\nfunc extractValue(resp *http.Response) (*Res, error) {\n\tdefer func(Body io.ReadCloser) {\n\t\terr := Body.Close()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"error closing response body:\", err)\n\t\t}\n\t}(resp.Body)\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"request failed with status: %s\", resp.Status)\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading response body: %w\", err)\n\t}\n\n\tvar res Res\n\tif err := json.Unmarshal(body, &res); err != nil {\n\t\treturn nil, fmt.Errorf(\"error unmarshalling response body: %w\", err)\n\t}\n\n\treturn &res, nil\n}\n```","codeResolution":"The extractValue function currently combines multiple responsibilities, making the code harder to maintain and test. To improve functionMethodCounts, delegate each responsibility to dedicated helper functions:\n\n```go\n// Go\nfunc extractValue(resp *http.Response) (*Res, error) {\n\tif err := validateResponse(resp); err != nil {\n\t\treturn nil, err\n\t}\n\tbody, err := readResponseBody(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn parseRes(body)\n}\n```","severity":"Critical","rationale":"The code defines only one function, `extractValue`, which handles multiple responsibilities: closing the response body, checking the status code, reading the body, and unmarshalling JSON. This violates functionMethodCounts principles by concentrating too much logic in a single function. Such design makes the code harder to maintain, test, and extend, as changes to one aspect (e.g., error handling or parsing) risk affecting others. Splitting these responsibilities into smaller, focused functions would improve readability, facilitate unit testing, and reduce the likelihood of bugs.","lineStart":13,"lineEnd":27,"status":""},{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The extractValue function contains multiple sequential error checks and nested logic, resulting in elevated cyclomatic complexity and reduced clarity.\n\n```go\nif resp.StatusCode != http.StatusOK {\n\treturn nil, fmt.Errorf(\"request failed with status: %s\", resp.Status)\n}\n```","codeResolution":"The extractValue function’s cyclomatic complexity can be reduced by delegating error handling and response parsing to helper abstractions, resulting in clearer and more maintainable code.\n\n```go\n// Go\nfunc extractValue(resp *http.Response) (*Res, error) {\n\tdefer closeBody(resp.Body)\n\tif err := checkResponse(resp); err != nil {\n\t\treturn nil, err\n\t}\n\treturn parseResponse(resp.Body)\n}\n```","severity":"Critical","rationale":"Cyclomatic complexity is important because it directly impacts code maintainability and testability. In the provided code, the function `extractValue` contains multiple branching paths: error handling for closing the response body (lines 11–15), status code checks (lines 17–19), reading the body (lines 21–24), and unmarshalling JSON (lines 26–29). Each conditional adds to the complexity, making the function harder to reason about and increasing the risk of missed edge cases or bugs. High cyclomatic complexity can slow down future development and complicate unit testing, as every branch must be covered. Refactoring into smaller, single-responsibility functions would reduce complexity and improve reliability.","lineStart":22,"lineEnd":27,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The extractValue function is overly verbose, with multiple nested error checks and resource management, resulting in unnecessary lines of code.\n\n```go\nbody, err := io.ReadAll(resp.Body)\nif err != nil {\n\treturn nil, fmt.Errorf(\"error reading response body: %w\", err)\n}\n```","codeResolution":"The extractValue function can be streamlined to reduce lines of code and improve clarity by delegating error handling and response parsing to helper abstractions.\n\n```go\n// Go\nfunc extractValue(resp *http.Response) (*Res, error) {\n\treturn parseResponse(resp)\n}\n```","severity":"Critical","rationale":"### Rationale\n\nThe code snippet contains 27 non-comment, non-blank lines, which is reasonable but could be further reduced by extracting error handling and resource cleanup into helper functions. Excess lines of code increase cognitive load and make future maintenance harder, especially when error handling is repeated or deeply nested. For example, the inline deferred closure for `resp.Body` (lines 11–15) and repeated error checks could be abstracted, improving readability and maintainability. Streamlining these patterns would make the codebase easier to test and less prone to subtle bugs, while also clarifying the main logic flow.","lineStart":17,"lineEnd":28,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A","readability":"A+","testability":"A-"},"issues":{"cyclomaticComplexity":3,"dependenciesModules":4,"functionMethodCounts":2,"linesOfCode":41,"nestingDepth":2}},"hash":"48867837ec72b831f5c44fd017a923646405fa7de26d2d0528a66de492cba02f","id":"eJyVU0uP0zAQ/iuDpUXpqkrvQT1AhYTEYatSuGCkNckkNTjjYE92t6r639HYyW6XhwQ52eP5HvPZOSkTI8Zoqdt771SlNr4fHD5YPqqlqn2DG0+MxKpSg6m/mw6hdhaJNWmy/eADQ6FJs1ZItW8sdatv0ZNWudj2PC+tn1eEvDowD7JfCNFqBTuM0GBrCSMYiBzGmseAcG/5IAVLnUOpW+qgtegaTXwcMAFzO5yE/pNx42Pjr9+teKu0upMmrW4FcMMHDNCb4XMGfbHEGFpT4+n8CEhNCXCeDOMDB1NPctMmAh8QEjm0wfdp+26/30LAOHiKCIYaCMhjIJnzybymdqT6GWshILiWpMrdhF9Acb3DuAQMwYdFHrnBFgMIvnjjmyNYX+7QNBvnI849mjEEqNYgHWU6Khb5wLbCBi/WQNbN3ZrbnsttsMSOCq2SHtTOy008jfPVN8dKq+RnopOA+JzMlyKWbjippNIHNjzGjW9QFNNwuXTzftbO+YibJYiLt6LdFloF/DFiZGiNddjktxETuIKrKDYuJJKdcxYXm8mjJDDF89q55yb/HMRfzeREAprm90Tg6v4ylMnFnZH+KLd+IVetQR5Z+ZF6E+LBuCK7fRkwLl79v6Nx5nH/6msiFMGl0KZHrpaqtQ63hg+qUvmnX10+z7Lz6vwTlM2F+w=="}
{"assessingTool":"SOLID","filePath":"jsonSchema/constantModels.go","grade":"A+","username":"HLamb","timestamp":"2025-10-12T17:10:18.890Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"dependencyInversionScore":"A+","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"A+","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package jsonSchema\n\ntype DataType string\n\nconst (\n\tObject  DataType = \"object\"\n\tNumber  DataType = \"number\"\n\tInteger DataType = \"integer\"\n\tString  DataType = \"string\"\n\tArray   DataType = \"array\"\n\tNull    DataType = \"null\"\n\tBoolean DataType = \"boolean\"\n\tMap     DataType = \"map\"\n\tByte    DataType = \"byte\" //this will be used for the audio and image data selection (if this is selected as byte then either Image or Audio must not be nil, if it is then nothing will occur and an empty byte will be returned. The same is true if both are filled.\n)\n\ntype HTTPMethod string\n\n// Constants for HTTP methods\nconst (\n\tGET    HTTPMethod = \"GET\"\n\tPOST   HTTPMethod = \"POST\"\n\tPUT    HTTPMethod = \"PUT\"\n\tDELETE HTTPMethod = \"DELETE\"\n\tPATCH  HTTPMethod = \"PATCH\"\n)\n","reason":"Modified","start":1,"end":27,"grade":"A+"}]},"hash":"7cabea872387868ca920251369b36c2169d823cee911be4922699c06f5179c25","id":"eJxtk0Fr4zAQhf/KoFMLIb4H9pBNTBtomkDUmy9je2yrK4+MNKaYZf/7ItndNsnezHvfPI8f498KQ6AQDLfaOas26nJ6OezVSlWupp1jIRa1UQNWv7AleA+OL1VHPRZcsEwDwR4FdXwI4g23Ua8cB4GHggs5le9UCXxRP6BQLomFisDr2JfkbwBO4gwcWKglfw2YWZyJS3rxTcSyTQK23uMENwBG8XMHa+HW59Ha2f7pnCXka7ucxZk44gB3AT0Oy/wkdOeWk1ChIMukMwE+jLVQEoyBamicB+kIcKyNA+QaTB/Lr1EQAlmqxDiGB9NAGjZhUakGDBCT4zwDGenIwyFNOw/bFNiPQYCdxPexsSswDRiJKWmInXSxzrSSq6rRpxWQgfpBpjn+c19PMnqmeg26IwjYU8rxI8XU0kkH6AkaYy3V64If/53Ns9bnI0nn6m+Hk2Wwi7eDLCHVECnoExau7uop17HSbymx1Kdcz5WfTxd9b0d18d/+N35+W+x9/pLr/Nae1SVgq3fP9wFRjcBjwWqlGmPpjNKpjfr6cbJq+cKjq8mGdevUn7+SEjJN"}
{"assessingTool":"SOLID","filePath":"grpc/object-generation_grpc.pb.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:10:15.257Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"dependencyInversionScore":"C-","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"A+","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"// Code generated by protoc-gen-go-grpc. DO NOT EDIT.\n// versions:\n// - protoc-gen-go-grpc v1.5.1\n// - protoc             v3.20.3\n// source: object-generation.proto\n\npackage grpc\n\nimport (\n\tcontext \"context\"\n\tgrpc \"google.golang.org/grpc\"\n\tcodes \"google.golang.org/grpc/codes\"\n\tstatus \"google.golang.org/grpc/status\"\n)\n\n// This is a compile-time assertion to ensure that this generated file\n// is compatible with the grpc package it is being compiled against.\n// Requires gRPC-Go v1.64.0 or later.\nconst _ = grpc.SupportPackageIsVersion9\n\nconst (\n\tJSONSchemaService_GenerateObject_FullMethodName         = \"/jsonSchema.JSONSchemaService/GenerateObject\"\n\tJSONSchemaService_StreamGeneratedObjects_FullMethodName = \"/jsonSchema.JSONSchemaService/StreamGeneratedObjects\"\n)\n\n// JSONSchemaServiceClient is the client API for JSONSchemaService service.\n//\n// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.\n//\n// The JSONSchemaService defines a service for generating JSON objects based on a schema definition.\ntype JSONSchemaServiceClient interface {\n\t// Standard request-response RPC\n\tGenerateObject(ctx context.Context, in *RequestBody, opts ...grpc.CallOption) (*Response, error)\n\t// New method: Server-side streaming RPC\n\tStreamGeneratedObjects(ctx context.Context, in *RequestBody, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamingResponse], error)\n}\n\ntype jSONSchemaServiceClient struct {\n\tcc grpc.ClientConnInterface\n}\n\nfunc NewJSONSchemaServiceClient(cc grpc.ClientConnInterface) JSONSchemaServiceClient {\n\treturn &jSONSchemaServiceClient{cc}\n}\n\nfunc (c *jSONSchemaServiceClient) GenerateObject(ctx context.Context, in *RequestBody, opts ...grpc.CallOption) (*Response, error) {\n\tcOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)\n\tout := new(Response)\n\terr := c.cc.Invoke(ctx, JSONSchemaService_GenerateObject_FullMethodName, in, out, cOpts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\nfunc (c *jSONSchemaServiceClient) StreamGeneratedObjects(ctx context.Context, in *RequestBody, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamingResponse], error) {\n\tcOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)\n\tstream, err := c.cc.NewStream(ctx, &JSONSchemaService_ServiceDesc.Streams[0], JSONSchemaService_StreamGeneratedObjects_FullMethodName, cOpts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tx := &grpc.GenericClientStream[RequestBody, StreamingResponse]{ClientStream: stream}\n\tif err := x.ClientStream.SendMsg(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := x.ClientStream.CloseSend(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn x, nil\n}\n\n// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.\ntype JSONSchemaService_StreamGeneratedObjectsClient = grpc.ServerStreamingClient[StreamingResponse]\n\n// JSONSchemaServiceServer is the server API for JSONSchemaService service.\n// All implementations must embed UnimplementedJSONSchemaServiceServer\n// for forward compatibility.\n//\n// The JSONSchemaService defines a service for generating JSON objects based on a schema definition.\ntype JSONSchemaServiceServer interface {\n\t// Standard request-response RPC\n\tGenerateObject(context.Context, *RequestBody) (*Response, error)\n\t// New method: Server-side streaming RPC\n\tStreamGeneratedObjects(*RequestBody, grpc.ServerStreamingServer[StreamingResponse]) error\n\tmustEmbedUnimplementedJSONSchemaServiceServer()\n}\n\n// UnimplementedJSONSchemaServiceServer must be embedded to have\n// forward compatible implementations.\n//\n// NOTE: this should be embedded by value instead of pointer to avoid a nil\n// pointer dereference when methods are called.\ntype UnimplementedJSONSchemaServiceServer struct{}\n\nfunc (UnimplementedJSONSchemaServiceServer) GenerateObject(context.Context, *RequestBody) (*Response, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method GenerateObject not implemented\")\n}\nfunc (UnimplementedJSONSchemaServiceServer) StreamGeneratedObjects(*RequestBody, grpc.ServerStreamingServer[StreamingResponse]) error {\n\treturn status.Errorf(codes.Unimplemented, \"method StreamGeneratedObjects not implemented\")\n}\nfunc (UnimplementedJSONSchemaServiceServer) mustEmbedUnimplementedJSONSchemaServiceServer() {}\nfunc (UnimplementedJSONSchemaServiceServer) testEmbeddedByValue()                           {}\n\n// UnsafeJSONSchemaServiceServer may be embedded to opt out of forward compatibility for this service.\n// Use of this interface is not recommended, as added methods to JSONSchemaServiceServer will\n// result in compilation errors.\ntype UnsafeJSONSchemaServiceServer interface {\n\tmustEmbedUnimplementedJSONSchemaServiceServer()\n}\n\nfunc RegisterJSONSchemaServiceServer(s grpc.ServiceRegistrar, srv JSONSchemaServiceServer) {\n\t// If the following call pancis, it indicates UnimplementedJSONSchemaServiceServer was\n\t// embedded by pointer and is nil.  This will cause panics if an\n\t// unimplemented method is ever invoked, so we test this at initialization\n\t// time to prevent it from happening at runtime later due to I/O.\n\tif t, ok := srv.(interface{ testEmbeddedByValue() }); ok {\n\t\tt.testEmbeddedByValue()\n\t}\n\ts.RegisterService(&JSONSchemaService_ServiceDesc, srv)\n}\n\nfunc _JSONSchemaService_GenerateObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(RequestBody)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(JSONSchemaServiceServer).GenerateObject(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: JSONSchemaService_GenerateObject_FullMethodName,\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(JSONSchemaServiceServer).GenerateObject(ctx, req.(*RequestBody))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n\nfunc _JSONSchemaService_StreamGeneratedObjects_Handler(srv interface{}, stream grpc.ServerStream) error {\n\tm := new(RequestBody)\n\tif err := stream.RecvMsg(m); err != nil {\n\t\treturn err\n\t}\n\treturn srv.(JSONSchemaServiceServer).StreamGeneratedObjects(m, &grpc.GenericServerStream[RequestBody, StreamingResponse]{ServerStream: stream})\n}\n\n// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.\ntype JSONSchemaService_StreamGeneratedObjectsServer = grpc.ServerStreamingServer[StreamingResponse]\n\n// JSONSchemaService_ServiceDesc is the grpc.ServiceDesc for JSONSchemaService service.\n// It's only intended for direct use with grpc.RegisterService,\n// and not to be introspected or modified (even as a copy)\nvar JSONSchemaService_ServiceDesc = grpc.ServiceDesc{\n\tServiceName: \"jsonSchema.JSONSchemaService\",\n\tHandlerType: (*JSONSchemaServiceServer)(nil),\n\tMethods: []grpc.MethodDesc{\n\t\t{\n\t\t\tMethodName: \"GenerateObject\",\n\t\t\tHandler:    _JSONSchemaService_GenerateObject_Handler,\n\t\t},\n\t},\n\tStreams: []grpc.StreamDesc{\n\t\t{\n\t\t\tStreamName:    \"StreamGeneratedObjects\",\n\t\t\tHandler:       _JSONSchemaService_StreamGeneratedObjects_Handler,\n\t\t\tServerStreams: true,\n\t\t},\n\t},\n\tMetadata: \"object-generation.proto\",\n}\n","reason":"Modified","start":1,"end":172,"grade":"A-"}]},"hash":"43e73f3ff0c6e91902d3a9de8ab36b07bac563e355698998451e402ee9d1a655","id":"eJzVWW1v20YS/itzPCAnBTSVXnsHnArj0Dppq8PFNmynX6LAWO2OqE2oXWZ3KVkn6L8Xs0uKpETactMAPQOGRHJ23p5nZ2eobcSsRWulSu+0zqJxdHv138nrKI64FnihlUPlonE0GsGFFggpKjTMoYDZBnKjneZnKaqzVJ+lJucJvL6Cy6s7ePN6cpdM1WgEKzRWamXH/uqsYxGsvkn+kXzTeg7Nv9W3yd9fJd96AasLw3EMevYRuTsr/ZFaJX7hVE1VzvgnliKQbrqWy1wbB4OpmjpOET04mEblt2lEt70b0yjVOs0wSXXGVJpok468jiisFGh7ZUb+cZC0jrniEdHwnGSH5N5oBHcLaUFaYMD1MpcZnjm5RCBoDMUGTgMqWxgEt2AOHMnXUMxlhl6PtF4Bc3KWIaylW4BbhERAlRXpSGyGUqWVNQEsZVJZFxC7wc+FNGghvbm+OPtZEz7//C55BdpAxhyaZKq4VtbBPZx75cltkVOOr4ONif01gP4vii+I+uz/5/bq8pYvcMlu0awkx/ufyyCuPJz3PxVZ9hbdQotLtsQ9Ac5hGo0+Wq3C4uRIz6itJ+BwbO3WGWTLSlYEYXto9Wlr3XqaiB6tucgkKp96QoSHqx+uJzDX5lgabPj0gHiFP2kDFpdMOcktMKMLJYC7BygsAqPvmaZdPEIlCFrrXaRvN9cXNoY8Q2YRDM7REJ0WzuV2PBrln9Ik1YnA1aiHrv92bHYuNP9rCOFCK5Vc4jrkoHbwboEdcQicS4XE7DIiH2+1a1Xql5Sb2cKMWRSgFYl7NWG99Pt7qtwm77BRZVY5NHPGEbYE/mgEt44pwYwAg58LtO7MoM21skgpIZk2aQaUzbIqJBfhMwap4OVNWP+jFpsYdO4sJEnieX/BsuwqJ/eGMHh5U+qPAY3RZlj6cYlrWHp6jYF8RnNmpcA2RCTbTasv9ivsUG/4tjIZkvZ+f125/qH2fUdU9in/2JNy60zBXcg356ES1CSZVICUquaF4pSLHgAHj2gY9qLubRt0hVHwosfPLee7pg8DDi97RIfwtTlRZuuKVozPgeU5KjF4/+Fg6TaA5piTPJSmwXAXDCVJ4pmlC0caFK4HlRF/H42h+zzhPJmolf6EFEV8nMLHiy+FGYMuXAze28qsnFMk8JdzUDIL0ewRUDLzcdLNXQMZr0XJ7GQU/kw74Y9DLGx4r3eP0L6SBpBedBxa4fM1WlJPovb9qw9deJ50vH0JnA/k9gsfqLciecheMPy+hcJxQrdN4XFZ/nYNJ8bn8JA0hZJbVOKtTQdSDb9/hp+9+i4ybZGUDp6lr7z/0CRx1bb5CskyyXwHlxu9koJ6Mm1gxvinNTOi7spkJt0mNGb4IK0LTZgo2zp/OKPiGJqE3EhtQGkVulzJy5QFk7MNKLbE3mOxhw1l3az6thP3Ql9XE9ZXXY0NV6d1NfBDloFc5hkuUTnfwltYFtYBLmco4J3aP0TRY9jrIVNzbSjR7Tz/CXqTKj9f3pscVr1myfuKvUe7snZxJlx2cGYYPCHlBOsbQvUUUAfDeoedIh9IM8PAG9p71N6yFVbsaDEjw0PS1TS5vLp7Mw7DlV3oIhMtrbMNrFhWINCkhEyAnkOuPbRkka20FMBChRiN9o8E7rc1rBeoSjioh0fgLMtQVPQ5KdrQdG0bB+kpy44bm+cSqtVq+QoZ5tjkDT2eD/wAnLR8iWEahWgPrIPSDhqC0yhg/px4vhphW4E+J8Zuj/6IWJ+5f2D7TP0OS/0CxY+bX4nlgyH0/23r/WnZHHs3Jtsc7kudO+oGae901mxfgsMObJ4V7yzSEv+gLqYyJNcg18slKkFoMAvMG6u2mdO9ZXkts7BXDdoioxGyfCPiC0Ngg60352OhHlT431fwPGQ3mErr0PQJ25rUkmOQNszEYM2qL9Lh/tyZzP1JPddZpte++2BZBjlTXNrYvxtSQnLm0J5WjdbMlpqbdbKqffRegkCSWQKhW6KUA2f00iJnil5lyDkwVeoomiZLBEkBhhTTLCNisBrW6DkbCMHIa+kky+T/PHKlNv8OzWnIDa78GwIHc6OXsPAtPAVPPVehvJx/sQWi8Csmo6uk7CNdDPoTdZLWrJLBHuZtz57ZDb8n+bKfdEmn1L6vtEmFdpnVweP9vwe5xZb7J6e6X5gSGfHGrGqWbncxdA5TAjmQ4kaku7IuxmE5x9xRm0QkfKeY2QQmTOpnQxi0DDXPD6nqmbU+bto9u0D+Oxr+pnPnXYs8gH0bJDme+yneGiqp5rqeflqBz3VpKNwY+xJpzSoOd+vxa/zsGXxvfhFQJA88PJ3gGfwMLdz6cfiCrBj8nLSO2eHwcFBqYFFlkv7nOoYykKdI3DPK9pK5nIyOzvvWmb58mntBT3KDfEVz5/IxFnZMiI9ns6dlWcbtmbrp/5MzdVN4P1MP/79n1PJs6Z5Re9u3vhm1WUCrSbV5hPr7J8yrE/c3C1plG888VSVQSEMdLZ1oPmde9UFZj70COg2pX3GauiKpnNE2R05HnTaw1ELOJQoY0Gnl+xjgOieCrliHc62wzo8i8lQtr6mUjGEaPfabxjTyxabcYHebHMcweNlH5YGS2dAvCMXKjqF8IRau9x5MXflRSVa+HP5gE1dipQe+ip58upWrd6FgxvVAWzsWrrscC0+CYwAwjfp+3un0sdvNx+vXXlGT23YMzhTYEcpbdEwwxyhvfb97knO7qYriiH4NvGZuEY0j//vN0Yp7n498lqQ62v0GdYLzCw=="}
{"assessingTool":"SOLID","filePath":"grpc/object-generation.pb.go","grade":"A","username":"HLamb","timestamp":"2025-10-12T17:10:10.122Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"dependencyInversionScore":"A+","interfaceSegregationScore":"A-","liskovSubstitutionScore":"A+","openClosedScore":"A+","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"// Code generated by protoc-gen-go. DO NOT EDIT.\n// versions:\n// \tprotoc-gen-go v1.34.2\n// \tprotoc        v3.20.3\n// source: object-generation.proto\n\npackage grpc\n\nimport (\n\tprotoreflect \"google.golang.org/protobuf/reflect/protoreflect\"\n\tprotoimpl \"google.golang.org/protobuf/runtime/protoimpl\"\n\t_ \"google.golang.org/protobuf/types/known/anypb\"\n\tstructpb \"google.golang.org/protobuf/types/known/structpb\"\n\treflect \"reflect\"\n\tsync \"sync\"\n)\n\nconst (\n\t// Verify that this generated code is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)\n\t// Verify that runtime/protoimpl is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)\n)\n\n// Definition message\ntype Definition struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tType               string                 `protobuf:\"bytes,1,opt,name=type,proto3\" json:\"type,omitempty\"`                                                                                                     // Corresponds to Go's DataType field (as a string)\n\tInstruction        string                 `protobuf:\"bytes,2,opt,name=instruction,proto3\" json:\"instruction,omitempty\"`                                                                                       // Corresponds to Go's Instruction field\n\tProperties         map[string]*Definition `protobuf:\"bytes,3,rep,name=properties,proto3\" json:\"properties,omitempty\" protobuf_key:\"bytes,1,opt,name=key,proto3\" protobuf_val:\"bytes,2,opt,name=value,proto3\"` // Corresponds to Go's Properties field\n\tItems              *Definition            `protobuf:\"bytes,4,opt,name=items,proto3\" json:\"items,omitempty\"`                                                                                                   // Corresponds to Go's Items field\n\tModel              string                 `protobuf:\"bytes,5,opt,name=model,proto3\" json:\"model,omitempty\"`                                                                                                   // Corresponds to Go's ModelType field (as a string)\n\tProcessingOrder    []string               `protobuf:\"bytes,6,rep,name=processingOrder,proto3\" json:\"processingOrder,omitempty\"`                                                                               // Corresponds to Go's ProcessingOrder field\n\tSystemPrompt       string                 `protobuf:\"bytes,7,opt,name=systemPrompt,proto3\" json:\"systemPrompt,omitempty\"`                                                                                     // Corresponds to Go's SystemPrompt field\n\tReq                *RequestFormat         `protobuf:\"bytes,8,opt,name=req,proto3\" json:\"req,omitempty\"`                                                                                                       // Corresponds to Go's Req field\n\tNarrowFocus        *Focus                 `protobuf:\"bytes,9,opt,name=narrowFocus,proto3\" json:\"narrowFocus,omitempty\"`                                                                                       // Corresponds to Go's NarrowFocus field\n\tImprovementProcess bool                   `protobuf:\"varint,10,opt,name=improvementProcess,proto3\" json:\"improvementProcess,omitempty\"`                                                                       // Corresponds to Go's ImprovementProcess field\n\tSelectFields       []string               `protobuf:\"bytes,11,rep,name=selectFields,proto3\" json:\"selectFields,omitempty\"`                                                                                    // Corresponds to Go's SelectFields field\n\tChoices            *Choices               `protobuf:\"bytes,12,opt,name=choices,proto3\" json:\"choices,omitempty\"`                                                                                              // Corresponds to Go's Choices field\n\tVoters             bool                   `protobuf:\"varint,13,opt,name=voters,proto3\" json:\"voters,omitempty\"`                                                                                               // Corresponds to Go's Voters field\n\tHashMap            *HashMap               `protobuf:\"bytes,14,opt,name=hashMap,proto3\" json:\"hashMap,omitempty\"`                                                                                              // Corresponds to Go's HashMap field\n\tTextToSpeech       *TextToSpeech          `protobuf:\"bytes,15,opt,name=textToSpeech,proto3\" json:\"textToSpeech,omitempty\"`                                                                                    // Corresponds to Go's Audio field\n\tSpeechToText       *SpeechToText          `protobuf:\"bytes,16,opt,name=speechToText,proto3\" json:\"speechToText,omitempty\"`                                                                                    // Corresponds to Go's Speech field\n\tImage              *Image                 `protobuf:\"bytes,17,opt,name=image,proto3\" json:\"image,omitempty\"`                                                                                                  // Corresponds to Go's Image field\n\tSendImage          *SendImage             `protobuf:\"bytes,18,opt,name=sendImage,proto3\" json:\"sendImage,omitempty\"`                                                                                          // Corresponds to Go's SendImage field\n\tStream             bool                   `protobuf:\"varint,19,opt,name=stream,proto3\" json:\"stream,omitempty\"`\n}\n\nfunc (x *Definition) Reset() {\n\t*x = Definition{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[0]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *Definition) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*Definition) ProtoMessage() {}\n\nfunc (x *Definition) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[0]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use Definition.ProtoReflect.Descriptor instead.\nfunc (*Definition) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{0}\n}\n\nfunc (x *Definition) GetType() string {\n\tif x != nil {\n\t\treturn x.Type\n\t}\n\treturn \"\"\n}\n\nfunc (x *Definition) GetInstruction() string {\n\tif x != nil {\n\t\treturn x.Instruction\n\t}\n\treturn \"\"\n}\n\nfunc (x *Definition) GetProperties() map[string]*Definition {\n\tif x != nil {\n\t\treturn x.Properties\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetItems() *Definition {\n\tif x != nil {\n\t\treturn x.Items\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetModel() string {\n\tif x != nil {\n\t\treturn x.Model\n\t}\n\treturn \"\"\n}\n\nfunc (x *Definition) GetProcessingOrder() []string {\n\tif x != nil {\n\t\treturn x.ProcessingOrder\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetSystemPrompt() string {\n\tif x != nil {\n\t\treturn x.SystemPrompt\n\t}\n\treturn \"\"\n}\n\nfunc (x *Definition) GetReq() *RequestFormat {\n\tif x != nil {\n\t\treturn x.Req\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetNarrowFocus() *Focus {\n\tif x != nil {\n\t\treturn x.NarrowFocus\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetImprovementProcess() bool {\n\tif x != nil {\n\t\treturn x.ImprovementProcess\n\t}\n\treturn false\n}\n\nfunc (x *Definition) GetSelectFields() []string {\n\tif x != nil {\n\t\treturn x.SelectFields\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetChoices() *Choices {\n\tif x != nil {\n\t\treturn x.Choices\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetVoters() bool {\n\tif x != nil {\n\t\treturn x.Voters\n\t}\n\treturn false\n}\n\nfunc (x *Definition) GetHashMap() *HashMap {\n\tif x != nil {\n\t\treturn x.HashMap\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetTextToSpeech() *TextToSpeech {\n\tif x != nil {\n\t\treturn x.TextToSpeech\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetSpeechToText() *SpeechToText {\n\tif x != nil {\n\t\treturn x.SpeechToText\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetImage() *Image {\n\tif x != nil {\n\t\treturn x.Image\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetSendImage() *SendImage {\n\tif x != nil {\n\t\treturn x.SendImage\n\t}\n\treturn nil\n}\n\nfunc (x *Definition) GetStream() bool {\n\tif x != nil {\n\t\treturn x.Stream\n\t}\n\treturn false\n}\n\n// Audio message\ntype TextToSpeech struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tModel         string `protobuf:\"bytes,1,opt,name=model,proto3\" json:\"model,omitempty\"`                 // Corresponds to Go's TextToSpeechModel field\n\tStringToAudio string `protobuf:\"bytes,2,opt,name=stringToAudio,proto3\" json:\"stringToAudio,omitempty\"` // Corresponds to Go's StringToAudio field\n\tFormat        string `protobuf:\"bytes,3,opt,name=format,proto3\" json:\"format,omitempty\"`               // Corresponds to Go's Format field\n\tVoice         string `protobuf:\"bytes,4,opt,name=voice,proto3\" json:\"voice,omitempty\"`                 // Corresponds to Go's Voice field\n}\n\nfunc (x *TextToSpeech) Reset() {\n\t*x = TextToSpeech{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[1]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *TextToSpeech) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*TextToSpeech) ProtoMessage() {}\n\nfunc (x *TextToSpeech) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[1]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use TextToSpeech.ProtoReflect.Descriptor instead.\nfunc (*TextToSpeech) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{1}\n}\n\nfunc (x *TextToSpeech) GetModel() string {\n\tif x != nil {\n\t\treturn x.Model\n\t}\n\treturn \"\"\n}\n\nfunc (x *TextToSpeech) GetStringToAudio() string {\n\tif x != nil {\n\t\treturn x.StringToAudio\n\t}\n\treturn \"\"\n}\n\nfunc (x *TextToSpeech) GetFormat() string {\n\tif x != nil {\n\t\treturn x.Format\n\t}\n\treturn \"\"\n}\n\nfunc (x *TextToSpeech) GetVoice() string {\n\tif x != nil {\n\t\treturn x.Voice\n\t}\n\treturn \"\"\n}\n\n// SpeechToText message\ntype SpeechToText struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tModel             string `protobuf:\"bytes,1,opt,name=model,proto3\" json:\"model,omitempty\"`                         // Corresponds to Go's SpeechToTextModel field\n\tAudioToTranscribe []byte `protobuf:\"bytes,2,opt,name=audioToTranscribe,proto3\" json:\"audioToTranscribe,omitempty\"` // Corresponds to Go's AudioToTranscribe field\n\tLanguage          string `protobuf:\"bytes,3,opt,name=language,proto3\" json:\"language,omitempty\"`                   // Corresponds to Go's Language field\n\tFormat            string `protobuf:\"bytes,4,opt,name=format,proto3\" json:\"format,omitempty\"`                       // Corresponds to Go's Format field\n\tToString          bool   `protobuf:\"varint,5,opt,name=toString,proto3\" json:\"toString,omitempty\"`                  // Corresponds to Go's ToString field\n\tToCaptions        bool   `protobuf:\"varint,6,opt,name=toCaptions,proto3\" json:\"toCaptions,omitempty\"`              // Corresponds to Go's ToCaptions field\n}\n\nfunc (x *SpeechToText) Reset() {\n\t*x = SpeechToText{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[2]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SpeechToText) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SpeechToText) ProtoMessage() {}\n\nfunc (x *SpeechToText) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[2]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SpeechToText.ProtoReflect.Descriptor instead.\nfunc (*SpeechToText) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{2}\n}\n\nfunc (x *SpeechToText) GetModel() string {\n\tif x != nil {\n\t\treturn x.Model\n\t}\n\treturn \"\"\n}\n\nfunc (x *SpeechToText) GetAudioToTranscribe() []byte {\n\tif x != nil {\n\t\treturn x.AudioToTranscribe\n\t}\n\treturn nil\n}\n\nfunc (x *SpeechToText) GetLanguage() string {\n\tif x != nil {\n\t\treturn x.Language\n\t}\n\treturn \"\"\n}\n\nfunc (x *SpeechToText) GetFormat() string {\n\tif x != nil {\n\t\treturn x.Format\n\t}\n\treturn \"\"\n}\n\nfunc (x *SpeechToText) GetToString() bool {\n\tif x != nil {\n\t\treturn x.ToString\n\t}\n\treturn false\n}\n\nfunc (x *SpeechToText) GetToCaptions() bool {\n\tif x != nil {\n\t\treturn x.ToCaptions\n\t}\n\treturn false\n}\n\n// Image message\ntype Image struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tModel string `protobuf:\"bytes,1,opt,name=model,proto3\" json:\"model,omitempty\"` // Corresponds to Go's ImageModel field\n\tSize  string `protobuf:\"bytes,2,opt,name=size,proto3\" json:\"size,omitempty\"`   // Corresponds to Go's ImageSize field\n}\n\nfunc (x *Image) Reset() {\n\t*x = Image{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[3]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *Image) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*Image) ProtoMessage() {}\n\nfunc (x *Image) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[3]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use Image.ProtoReflect.Descriptor instead.\nfunc (*Image) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{3}\n}\n\nfunc (x *Image) GetModel() string {\n\tif x != nil {\n\t\treturn x.Model\n\t}\n\treturn \"\"\n}\n\nfunc (x *Image) GetSize() string {\n\tif x != nil {\n\t\treturn x.Size\n\t}\n\treturn \"\"\n}\n\n// Choices message\ntype Choices struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tNumber  int32    `protobuf:\"varint,1,opt,name=number,proto3\" json:\"number,omitempty\"`  // Corresponds to Go's Number field\n\tOptions []string `protobuf:\"bytes,2,rep,name=options,proto3\" json:\"options,omitempty\"` // Corresponds to Go's Options field\n}\n\nfunc (x *Choices) Reset() {\n\t*x = Choices{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[4]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *Choices) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*Choices) ProtoMessage() {}\n\nfunc (x *Choices) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[4]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use Choices.ProtoReflect.Descriptor instead.\nfunc (*Choices) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{4}\n}\n\nfunc (x *Choices) GetNumber() int32 {\n\tif x != nil {\n\t\treturn x.Number\n\t}\n\treturn 0\n}\n\nfunc (x *Choices) GetOptions() []string {\n\tif x != nil {\n\t\treturn x.Options\n\t}\n\treturn nil\n}\n\n// HashMap message\ntype HashMap struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tKeyInstruction  string      `protobuf:\"bytes,1,opt,name=keyInstruction,proto3\" json:\"keyInstruction,omitempty\"`   // Corresponds to Go's KeyInstruction field\n\tFieldDefinition *Definition `protobuf:\"bytes,2,opt,name=fieldDefinition,proto3\" json:\"fieldDefinition,omitempty\"` // Corresponds to Go's FieldDefinition field\n}\n\nfunc (x *HashMap) Reset() {\n\t*x = HashMap{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[5]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *HashMap) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*HashMap) ProtoMessage() {}\n\nfunc (x *HashMap) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[5]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use HashMap.ProtoReflect.Descriptor instead.\nfunc (*HashMap) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{5}\n}\n\nfunc (x *HashMap) GetKeyInstruction() string {\n\tif x != nil {\n\t\treturn x.KeyInstruction\n\t}\n\treturn \"\"\n}\n\nfunc (x *HashMap) GetFieldDefinition() *Definition {\n\tif x != nil {\n\t\treturn x.FieldDefinition\n\t}\n\treturn nil\n}\n\n// Focus message\ntype Focus struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tPrompt       string   `protobuf:\"bytes,1,opt,name=prompt,proto3\" json:\"prompt,omitempty\"`              // Corresponds to Go's Prompt field\n\tFields       []string `protobuf:\"bytes,2,rep,name=fields,proto3\" json:\"fields,omitempty\"`              // Corresponds to Go's Fields field\n\tKeepOriginal bool     `protobuf:\"varint,3,opt,name=keepOriginal,proto3\" json:\"keepOriginal,omitempty\"` // Corresponds to Go's KeepOriginal field\n}\n\nfunc (x *Focus) Reset() {\n\t*x = Focus{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[6]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *Focus) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*Focus) ProtoMessage() {}\n\nfunc (x *Focus) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[6]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use Focus.ProtoReflect.Descriptor instead.\nfunc (*Focus) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{6}\n}\n\nfunc (x *Focus) GetPrompt() string {\n\tif x != nil {\n\t\treturn x.Prompt\n\t}\n\treturn \"\"\n}\n\nfunc (x *Focus) GetFields() []string {\n\tif x != nil {\n\t\treturn x.Fields\n\t}\n\treturn nil\n}\n\nfunc (x *Focus) GetKeepOriginal() bool {\n\tif x != nil {\n\t\treturn x.KeepOriginal\n\t}\n\treturn false\n}\n\n// SendImage message\ntype SendImage struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tImagesData [][]byte `protobuf:\"bytes,1,rep,name=imagesData,proto3\" json:\"imagesData,omitempty\"`\n}\n\nfunc (x *SendImage) Reset() {\n\t*x = SendImage{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[7]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *SendImage) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*SendImage) ProtoMessage() {}\n\nfunc (x *SendImage) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[7]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use SendImage.ProtoReflect.Descriptor instead.\nfunc (*SendImage) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{7}\n}\n\nfunc (x *SendImage) GetImagesData() [][]byte {\n\tif x != nil {\n\t\treturn x.ImagesData\n\t}\n\treturn nil\n}\n\n// RequestFormat message\ntype RequestFormat struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tUrl           string            `protobuf:\"bytes,1,opt,name=url,proto3\" json:\"url,omitempty\"`\n\tMethod        string            `protobuf:\"bytes,2,opt,name=method,proto3\" json:\"method,omitempty\"`\n\tHeaders       map[string]string `protobuf:\"bytes,3,rep,name=headers,proto3\" json:\"headers,omitempty\" protobuf_key:\"bytes,1,opt,name=key,proto3\" protobuf_val:\"bytes,2,opt,name=value,proto3\"`\n\tBody          *structpb.Struct  `protobuf:\"bytes,4,opt,name=body,proto3\" json:\"body,omitempty\"` // This corresponds to Go's Body field as map[string]interface{}\n\tAuthorization string            `protobuf:\"bytes,5,opt,name=authorization,proto3\" json:\"authorization,omitempty\"`\n\tRequireFields []string          `protobuf:\"bytes,6,rep,name=requireFields,proto3\" json:\"requireFields,omitempty\"`\n}\n\nfunc (x *RequestFormat) Reset() {\n\t*x = RequestFormat{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[8]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *RequestFormat) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*RequestFormat) ProtoMessage() {}\n\nfunc (x *RequestFormat) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[8]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use RequestFormat.ProtoReflect.Descriptor instead.\nfunc (*RequestFormat) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{8}\n}\n\nfunc (x *RequestFormat) GetUrl() string {\n\tif x != nil {\n\t\treturn x.Url\n\t}\n\treturn \"\"\n}\n\nfunc (x *RequestFormat) GetMethod() string {\n\tif x != nil {\n\t\treturn x.Method\n\t}\n\treturn \"\"\n}\n\nfunc (x *RequestFormat) GetHeaders() map[string]string {\n\tif x != nil {\n\t\treturn x.Headers\n\t}\n\treturn nil\n}\n\nfunc (x *RequestFormat) GetBody() *structpb.Struct {\n\tif x != nil {\n\t\treturn x.Body\n\t}\n\treturn nil\n}\n\nfunc (x *RequestFormat) GetAuthorization() string {\n\tif x != nil {\n\t\treturn x.Authorization\n\t}\n\treturn \"\"\n}\n\nfunc (x *RequestFormat) GetRequireFields() []string {\n\tif x != nil {\n\t\treturn x.RequireFields\n\t}\n\treturn nil\n}\n\n// RequestBody message for the GenerateObject RPC\ntype RequestBody struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tPrompt     string      `protobuf:\"bytes,1,opt,name=prompt,proto3\" json:\"prompt,omitempty\"`         // Corresponds to Go's Prompt field\n\tDefinition *Definition `protobuf:\"bytes,2,opt,name=definition,proto3\" json:\"definition,omitempty\"` // Corresponds to Go's Definition field\n}\n\nfunc (x *RequestBody) Reset() {\n\t*x = RequestBody{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[9]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *RequestBody) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*RequestBody) ProtoMessage() {}\n\nfunc (x *RequestBody) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[9]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use RequestBody.ProtoReflect.Descriptor instead.\nfunc (*RequestBody) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{9}\n}\n\nfunc (x *RequestBody) GetPrompt() string {\n\tif x != nil {\n\t\treturn x.Prompt\n\t}\n\treturn \"\"\n}\n\nfunc (x *RequestBody) GetDefinition() *Definition {\n\tif x != nil {\n\t\treturn x.Definition\n\t}\n\treturn nil\n}\n\n// Updated Response message for the GenerateObject RPC\ntype Response struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tData    *structpb.Struct `protobuf:\"bytes,1,opt,name=data,proto3\" json:\"data,omitempty\"` // Use Struct to hold a dynamic map<string, any>\n\tUsdCost float64          `protobuf:\"fixed64,2,opt,name=usdCost,proto3\" json:\"usdCost,omitempty\"`\n}\n\nfunc (x *Response) Reset() {\n\t*x = Response{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[10]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *Response) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*Response) ProtoMessage() {}\n\nfunc (x *Response) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[10]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use Response.ProtoReflect.Descriptor instead.\nfunc (*Response) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{10}\n}\n\nfunc (x *Response) GetData() *structpb.Struct {\n\tif x != nil {\n\t\treturn x.Data\n\t}\n\treturn nil\n}\n\nfunc (x *Response) GetUsdCost() float64 {\n\tif x != nil {\n\t\treturn x.UsdCost\n\t}\n\treturn 0\n}\n\n// StreamingResponse message for the stream method\ntype StreamingResponse struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tData    *structpb.Struct `protobuf:\"bytes,1,opt,name=data,proto3\" json:\"data,omitempty\"` // Same as above, using Struct for map<string, any>\n\tUsdCost float64          `protobuf:\"fixed64,2,opt,name=usdCost,proto3\" json:\"usdCost,omitempty\"`\n\tStatus  string           `protobuf:\"bytes,3,opt,name=status,proto3\" json:\"status,omitempty\"` // A status message for each streamed response\n}\n\nfunc (x *StreamingResponse) Reset() {\n\t*x = StreamingResponse{}\n\tif protoimpl.UnsafeEnabled {\n\t\tmi := &file_object_generation_proto_msgTypes[11]\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tms.StoreMessageInfo(mi)\n\t}\n}\n\nfunc (x *StreamingResponse) String() string {\n\treturn protoimpl.X.MessageStringOf(x)\n}\n\nfunc (*StreamingResponse) ProtoMessage() {}\n\nfunc (x *StreamingResponse) ProtoReflect() protoreflect.Message {\n\tmi := &file_object_generation_proto_msgTypes[11]\n\tif protoimpl.UnsafeEnabled && x != nil {\n\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n\t\tif ms.LoadMessageInfo() == nil {\n\t\t\tms.StoreMessageInfo(mi)\n\t\t}\n\t\treturn ms\n\t}\n\treturn mi.MessageOf(x)\n}\n\n// Deprecated: Use StreamingResponse.ProtoReflect.Descriptor instead.\nfunc (*StreamingResponse) Descriptor() ([]byte, []int) {\n\treturn file_object_generation_proto_rawDescGZIP(), []int{11}\n}\n\nfunc (x *StreamingResponse) GetData() *structpb.Struct {\n\tif x != nil {\n\t\treturn x.Data\n\t}\n\treturn nil\n}\n\nfunc (x *StreamingResponse) GetUsdCost() float64 {\n\tif x != nil {\n\t\treturn x.UsdCost\n\t}\n\treturn 0\n}\n\nfunc (x *StreamingResponse) GetStatus() string {\n\tif x != nil {\n\t\treturn x.Status\n\t}\n\treturn \"\"\n}\n\nvar File_object_generation_proto protoreflect.FileDescriptor\n\nvar file_object_generation_proto_rawDesc = []byte{\n\t0x0a, 0x17, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x2d, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74,\n\t0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x6a, 0x73, 0x6f, 0x6e, 0x53,\n\t0x63, 0x68, 0x65, 0x6d, 0x61, 0x1a, 0x19, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72,\n\t0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x61, 0x6e, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,\n\t0x1a, 0x1c, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,\n\t0x66, 0x2f, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x91,\n\t0x07, 0x0a, 0x0a, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a,\n\t0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x79, 0x70,\n\t0x65, 0x12, 0x20, 0x0a, 0x0b, 0x69, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e,\n\t0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x69, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74,\n\t0x69, 0x6f, 0x6e, 0x12, 0x46, 0x0a, 0x0a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65,\n\t0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63,\n\t0x68, 0x65, 0x6d, 0x61, 0x2e, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e,\n\t0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52,\n\t0x0a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x12, 0x2c, 0x0a, 0x05, 0x69,\n\t0x74, 0x65, 0x6d, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6a, 0x73, 0x6f,\n\t0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69,\n\t0x6f, 0x6e, 0x52, 0x05, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x6d, 0x6f, 0x64,\n\t0x65, 0x6c, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x12,\n\t0x28, 0x0a, 0x0f, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x69, 0x6e, 0x67, 0x4f, 0x72, 0x64,\n\t0x65, 0x72, 0x18, 0x06, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0f, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73,\n\t0x73, 0x69, 0x6e, 0x67, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x12, 0x22, 0x0a, 0x0c, 0x73, 0x79, 0x73,\n\t0x74, 0x65, 0x6d, 0x50, 0x72, 0x6f, 0x6d, 0x70, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52,\n\t0x0c, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x50, 0x72, 0x6f, 0x6d, 0x70, 0x74, 0x12, 0x2b, 0x0a,\n\t0x03, 0x72, 0x65, 0x71, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x6a, 0x73, 0x6f,\n\t0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x46,\n\t0x6f, 0x72, 0x6d, 0x61, 0x74, 0x52, 0x03, 0x72, 0x65, 0x71, 0x12, 0x33, 0x0a, 0x0b, 0x6e, 0x61,\n\t0x72, 0x72, 0x6f, 0x77, 0x46, 0x6f, 0x63, 0x75, 0x73, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32,\n\t0x11, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x46, 0x6f, 0x63,\n\t0x75, 0x73, 0x52, 0x0b, 0x6e, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x46, 0x6f, 0x63, 0x75, 0x73, 0x12,\n\t0x2e, 0x0a, 0x12, 0x69, 0x6d, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72,\n\t0x6f, 0x63, 0x65, 0x73, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x12, 0x69, 0x6d, 0x70,\n\t0x72, 0x6f, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x12,\n\t0x22, 0x0a, 0x0c, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x18,\n\t0x0b, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x46, 0x69, 0x65,\n\t0x6c, 0x64, 0x73, 0x12, 0x2d, 0x0a, 0x07, 0x63, 0x68, 0x6f, 0x69, 0x63, 0x65, 0x73, 0x18, 0x0c,\n\t0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d,\n\t0x61, 0x2e, 0x43, 0x68, 0x6f, 0x69, 0x63, 0x65, 0x73, 0x52, 0x07, 0x63, 0x68, 0x6f, 0x69, 0x63,\n\t0x65, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x76, 0x6f, 0x74, 0x65, 0x72, 0x73, 0x18, 0x0d, 0x20, 0x01,\n\t0x28, 0x08, 0x52, 0x06, 0x76, 0x6f, 0x74, 0x65, 0x72, 0x73, 0x12, 0x2d, 0x0a, 0x07, 0x68, 0x61,\n\t0x73, 0x68, 0x4d, 0x61, 0x70, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x6a, 0x73,\n\t0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x48, 0x61, 0x73, 0x68, 0x4d, 0x61, 0x70,\n\t0x52, 0x07, 0x68, 0x61, 0x73, 0x68, 0x4d, 0x61, 0x70, 0x12, 0x3c, 0x0a, 0x0c, 0x74, 0x65, 0x78,\n\t0x74, 0x54, 0x6f, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0b, 0x32,\n\t0x18, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x54, 0x65, 0x78,\n\t0x74, 0x54, 0x6f, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x52, 0x0c, 0x74, 0x65, 0x78, 0x74, 0x54,\n\t0x6f, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x12, 0x3c, 0x0a, 0x0c, 0x73, 0x70, 0x65, 0x65, 0x63,\n\t0x68, 0x54, 0x6f, 0x54, 0x65, 0x78, 0x74, 0x18, 0x10, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e,\n\t0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x53, 0x70, 0x65, 0x65, 0x63,\n\t0x68, 0x54, 0x6f, 0x54, 0x65, 0x78, 0x74, 0x52, 0x0c, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x54,\n\t0x6f, 0x54, 0x65, 0x78, 0x74, 0x12, 0x27, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x11,\n\t0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d,\n\t0x61, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x33,\n\t0x0a, 0x09, 0x73, 0x65, 0x6e, 0x64, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x12, 0x20, 0x01, 0x28,\n\t0x0b, 0x32, 0x15, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x53,\n\t0x65, 0x6e, 0x64, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x09, 0x73, 0x65, 0x6e, 0x64, 0x49, 0x6d,\n\t0x61, 0x67, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x18, 0x13, 0x20,\n\t0x01, 0x28, 0x08, 0x52, 0x06, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x1a, 0x55, 0x0a, 0x0f, 0x50,\n\t0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10,\n\t0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,\n\t0x12, 0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,\n\t0x16, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x44, 0x65, 0x66,\n\t0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02,\n\t0x38, 0x01, 0x22, 0x78, 0x0a, 0x0c, 0x54, 0x65, 0x78, 0x74, 0x54, 0x6f, 0x53, 0x70, 0x65, 0x65,\n\t0x63, 0x68, 0x12, 0x14, 0x0a, 0x05, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28,\n\t0x09, 0x52, 0x05, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x12, 0x24, 0x0a, 0x0d, 0x73, 0x74, 0x72, 0x69,\n\t0x6e, 0x67, 0x54, 0x6f, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,\n\t0x0d, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x54, 0x6f, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x12, 0x16,\n\t0x0a, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06,\n\t0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x6f, 0x69, 0x63, 0x65, 0x18,\n\t0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x6f, 0x69, 0x63, 0x65, 0x22, 0xc2, 0x01, 0x0a,\n\t0x0c, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x54, 0x6f, 0x54, 0x65, 0x78, 0x74, 0x12, 0x14, 0x0a,\n\t0x05, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6d, 0x6f,\n\t0x64, 0x65, 0x6c, 0x12, 0x2c, 0x0a, 0x11, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x54, 0x6f, 0x54, 0x72,\n\t0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x11,\n\t0x61, 0x75, 0x64, 0x69, 0x6f, 0x54, 0x6f, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x62,\n\t0x65, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x18, 0x03, 0x20,\n\t0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x12, 0x16, 0x0a,\n\t0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x66,\n\t0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x74, 0x6f, 0x53, 0x74, 0x72, 0x69, 0x6e,\n\t0x67, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x74, 0x6f, 0x53, 0x74, 0x72, 0x69, 0x6e,\n\t0x67, 0x12, 0x1e, 0x0a, 0x0a, 0x74, 0x6f, 0x43, 0x61, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18,\n\t0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x74, 0x6f, 0x43, 0x61, 0x70, 0x74, 0x69, 0x6f, 0x6e,\n\t0x73, 0x22, 0x31, 0x0a, 0x05, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x6d, 0x6f,\n\t0x64, 0x65, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6d, 0x6f, 0x64, 0x65, 0x6c,\n\t0x12, 0x12, 0x0a, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,\n\t0x73, 0x69, 0x7a, 0x65, 0x22, 0x3b, 0x0a, 0x07, 0x43, 0x68, 0x6f, 0x69, 0x63, 0x65, 0x73, 0x12,\n\t0x16, 0x0a, 0x06, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52,\n\t0x06, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x12, 0x18, 0x0a, 0x07, 0x6f, 0x70, 0x74, 0x69, 0x6f,\n\t0x6e, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e,\n\t0x73, 0x22, 0x73, 0x0a, 0x07, 0x48, 0x61, 0x73, 0x68, 0x4d, 0x61, 0x70, 0x12, 0x26, 0x0a, 0x0e,\n\t0x6b, 0x65, 0x79, 0x49, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01,\n\t0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x6b, 0x65, 0x79, 0x49, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63,\n\t0x74, 0x69, 0x6f, 0x6e, 0x12, 0x40, 0x0a, 0x0f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x44, 0x65, 0x66,\n\t0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e,\n\t0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x44, 0x65, 0x66, 0x69, 0x6e,\n\t0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x44, 0x65, 0x66, 0x69,\n\t0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x5b, 0x0a, 0x05, 0x46, 0x6f, 0x63, 0x75, 0x73, 0x12,\n\t0x16, 0x0a, 0x06, 0x70, 0x72, 0x6f, 0x6d, 0x70, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,\n\t0x06, 0x70, 0x72, 0x6f, 0x6d, 0x70, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x69, 0x65, 0x6c, 0x64,\n\t0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x06, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x12,\n\t0x22, 0x0a, 0x0c, 0x6b, 0x65, 0x65, 0x70, 0x4f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x18,\n\t0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x6b, 0x65, 0x65, 0x70, 0x4f, 0x72, 0x69, 0x67, 0x69,\n\t0x6e, 0x61, 0x6c, 0x22, 0x2b, 0x0a, 0x09, 0x53, 0x65, 0x6e, 0x64, 0x49, 0x6d, 0x61, 0x67, 0x65,\n\t0x12, 0x1e, 0x0a, 0x0a, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x73, 0x44, 0x61, 0x74, 0x61, 0x18, 0x01,\n\t0x20, 0x03, 0x28, 0x0c, 0x52, 0x0a, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x73, 0x44, 0x61, 0x74, 0x61,\n\t0x22, 0xb0, 0x02, 0x0a, 0x0d, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x46, 0x6f, 0x72, 0x6d,\n\t0x61, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,\n\t0x03, 0x75, 0x72, 0x6c, 0x12, 0x16, 0x0a, 0x06, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x18, 0x02,\n\t0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x12, 0x40, 0x0a, 0x07,\n\t0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e,\n\t0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x65,\n\t0x73, 0x74, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x2e, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73,\n\t0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x07, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x12, 0x2b,\n\t0x0a, 0x04, 0x62, 0x6f, 0x64, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x67,\n\t0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53,\n\t0x74, 0x72, 0x75, 0x63, 0x74, 0x52, 0x04, 0x62, 0x6f, 0x64, 0x79, 0x12, 0x24, 0x0a, 0x0d, 0x61,\n\t0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01,\n\t0x28, 0x09, 0x52, 0x0d, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f,\n\t0x6e, 0x12, 0x24, 0x0a, 0x0d, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x46, 0x69, 0x65, 0x6c,\n\t0x64, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0d, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72,\n\t0x65, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x1a, 0x3a, 0x0a, 0x0c, 0x48, 0x65, 0x61, 0x64, 0x65,\n\t0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,\n\t0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c,\n\t0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a,\n\t0x02, 0x38, 0x01, 0x22, 0x5d, 0x0a, 0x0b, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x42, 0x6f,\n\t0x64, 0x79, 0x12, 0x16, 0x0a, 0x06, 0x70, 0x72, 0x6f, 0x6d, 0x70, 0x74, 0x18, 0x01, 0x20, 0x01,\n\t0x28, 0x09, 0x52, 0x06, 0x70, 0x72, 0x6f, 0x6d, 0x70, 0x74, 0x12, 0x36, 0x0a, 0x0a, 0x64, 0x65,\n\t0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16,\n\t0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x44, 0x65, 0x66, 0x69,\n\t0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0a, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69,\n\t0x6f, 0x6e, 0x22, 0x51, 0x0a, 0x08, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2b,\n\t0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x67,\n\t0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53,\n\t0x74, 0x72, 0x75, 0x63, 0x74, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x12, 0x18, 0x0a, 0x07, 0x75,\n\t0x73, 0x64, 0x43, 0x6f, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x07, 0x75, 0x73,\n\t0x64, 0x43, 0x6f, 0x73, 0x74, 0x22, 0x72, 0x0a, 0x11, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69,\n\t0x6e, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2b, 0x0a, 0x04, 0x64, 0x61,\n\t0x74, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,\n\t0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x74, 0x72, 0x75, 0x63,\n\t0x74, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x12, 0x18, 0x0a, 0x07, 0x75, 0x73, 0x64, 0x43, 0x6f,\n\t0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x07, 0x75, 0x73, 0x64, 0x43, 0x6f, 0x73,\n\t0x74, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28,\n\t0x09, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x32, 0xa8, 0x01, 0x0a, 0x11, 0x4a, 0x53,\n\t0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12,\n\t0x3f, 0x0a, 0x0e, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x4f, 0x62, 0x6a, 0x65, 0x63,\n\t0x74, 0x12, 0x17, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x52,\n\t0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x42, 0x6f, 0x64, 0x79, 0x1a, 0x14, 0x2e, 0x6a, 0x73, 0x6f,\n\t0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,\n\t0x12, 0x52, 0x0a, 0x16, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61,\n\t0x74, 0x65, 0x64, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x12, 0x17, 0x2e, 0x6a, 0x73, 0x6f,\n\t0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x42,\n\t0x6f, 0x64, 0x79, 0x1a, 0x1d, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61,\n\t0x2e, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,\n\t0x73, 0x65, 0x30, 0x01, 0x42, 0x08, 0x5a, 0x06, 0x2e, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x62, 0x06,\n\t0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,\n}\n\nvar (\n\tfile_object_generation_proto_rawDescOnce sync.Once\n\tfile_object_generation_proto_rawDescData = file_object_generation_proto_rawDesc\n)\n\nfunc file_object_generation_proto_rawDescGZIP() []byte {\n\tfile_object_generation_proto_rawDescOnce.Do(func() {\n\t\tfile_object_generation_proto_rawDescData = protoimpl.X.CompressGZIP(file_object_generation_proto_rawDescData)\n\t})\n\treturn file_object_generation_proto_rawDescData\n}\n\nvar file_object_generation_proto_msgTypes = make([]protoimpl.MessageInfo, 14)\nvar file_object_generation_proto_goTypes = []any{\n\t(*Definition)(nil),        // 0: jsonSchema.Definition\n\t(*TextToSpeech)(nil),      // 1: jsonSchema.TextToSpeech\n\t(*SpeechToText)(nil),      // 2: jsonSchema.SpeechToText\n\t(*Image)(nil),             // 3: jsonSchema.Image\n\t(*Choices)(nil),           // 4: jsonSchema.Choices\n\t(*HashMap)(nil),           // 5: jsonSchema.HashMap\n\t(*Focus)(nil),             // 6: jsonSchema.Focus\n\t(*SendImage)(nil),         // 7: jsonSchema.SendImage\n\t(*RequestFormat)(nil),     // 8: jsonSchema.RequestFormat\n\t(*RequestBody)(nil),       // 9: jsonSchema.RequestBody\n\t(*Response)(nil),          // 10: jsonSchema.Response\n\t(*StreamingResponse)(nil), // 11: jsonSchema.StreamingResponse\n\tnil,                       // 12: jsonSchema.Definition.PropertiesEntry\n\tnil,                       // 13: jsonSchema.RequestFormat.HeadersEntry\n\t(*structpb.Struct)(nil),   // 14: google.protobuf.Struct\n}\nvar file_object_generation_proto_depIdxs = []int32{\n\t12, // 0: jsonSchema.Definition.properties:type_name -> jsonSchema.Definition.PropertiesEntry\n\t0,  // 1: jsonSchema.Definition.items:type_name -> jsonSchema.Definition\n\t8,  // 2: jsonSchema.Definition.req:type_name -> jsonSchema.RequestFormat\n\t6,  // 3: jsonSchema.Definition.narrowFocus:type_name -> jsonSchema.Focus\n\t4,  // 4: jsonSchema.Definition.choices:type_name -> jsonSchema.Choices\n\t5,  // 5: jsonSchema.Definition.hashMap:type_name -> jsonSchema.HashMap\n\t1,  // 6: jsonSchema.Definition.textToSpeech:type_name -> jsonSchema.TextToSpeech\n\t2,  // 7: jsonSchema.Definition.speechToText:type_name -> jsonSchema.SpeechToText\n\t3,  // 8: jsonSchema.Definition.image:type_name -> jsonSchema.Image\n\t7,  // 9: jsonSchema.Definition.sendImage:type_name -> jsonSchema.SendImage\n\t0,  // 10: jsonSchema.HashMap.fieldDefinition:type_name -> jsonSchema.Definition\n\t13, // 11: jsonSchema.RequestFormat.headers:type_name -> jsonSchema.RequestFormat.HeadersEntry\n\t14, // 12: jsonSchema.RequestFormat.body:type_name -> google.protobuf.Struct\n\t0,  // 13: jsonSchema.RequestBody.definition:type_name -> jsonSchema.Definition\n\t14, // 14: jsonSchema.Response.data:type_name -> google.protobuf.Struct\n\t14, // 15: jsonSchema.StreamingResponse.data:type_name -> google.protobuf.Struct\n\t0,  // 16: jsonSchema.Definition.PropertiesEntry.value:type_name -> jsonSchema.Definition\n\t9,  // 17: jsonSchema.JSONSchemaService.GenerateObject:input_type -> jsonSchema.RequestBody\n\t9,  // 18: jsonSchema.JSONSchemaService.StreamGeneratedObjects:input_type -> jsonSchema.RequestBody\n\t10, // 19: jsonSchema.JSONSchemaService.GenerateObject:output_type -> jsonSchema.Response\n\t11, // 20: jsonSchema.JSONSchemaService.StreamGeneratedObjects:output_type -> jsonSchema.StreamingResponse\n\t19, // [19:21] is the sub-list for method output_type\n\t17, // [17:19] is the sub-list for method input_type\n\t17, // [17:17] is the sub-list for extension type_name\n\t17, // [17:17] is the sub-list for extension extendee\n\t0,  // [0:17] is the sub-list for field type_name\n}\n\nfunc init() { file_object_generation_proto_init() }\nfunc file_object_generation_proto_init() {\n\tif File_object_generation_proto != nil {\n\t\treturn\n\t}\n\tif !protoimpl.UnsafeEnabled {\n\t\tfile_object_generation_proto_msgTypes[0].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*Definition); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[1].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*TextToSpeech); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[2].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*SpeechToText); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[3].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*Image); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[4].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*Choices); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[5].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*HashMap); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[6].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*Focus); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[7].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*SendImage); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[8].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*RequestFormat); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[9].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*RequestBody); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[10].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*Response); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tfile_object_generation_proto_msgTypes[11].Exporter = func(v any, i int) any {\n\t\t\tswitch v := v.(*StreamingResponse); i {\n\t\t\tcase 0:\n\t\t\t\treturn &v.state\n\t\t\tcase 1:\n\t\t\t\treturn &v.sizeCache\n\t\t\tcase 2:\n\t\t\t\treturn &v.unknownFields\n\t\t\tdefault:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\ttype x struct{}\n\tout := protoimpl.TypeBuilder{\n\t\tFile: protoimpl.DescBuilder{\n\t\t\tGoPackagePath: reflect.TypeOf(x{}).PkgPath(),\n\t\t\tRawDescriptor: file_object_generation_proto_rawDesc,\n\t\t\tNumEnums:      0,\n\t\t\tNumMessages:   14,\n\t\t\tNumExtensions: 0,\n\t\t\tNumServices:   1,\n\t\t},\n\t\tGoTypes:           file_object_generation_proto_goTypes,\n\t\tDependencyIndexes: file_object_generation_proto_depIdxs,\n\t\tMessageInfos:      file_object_generation_proto_msgTypes,\n\t}.Build()\n\tFile_object_generation_proto = out.File\n\tfile_object_generation_proto_rawDesc = nil\n\tfile_object_generation_proto_goTypes = nil\n\tfile_object_generation_proto_depIdxs = nil\n}\n","reason":"Modified","start":1,"end":1311,"grade":"A"}]},"hash":"e0529a17a679f14a084e8b06b30e7c32c0c709aa5551c83e9ababa81ef8932d0","id":"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"}
{"assessingTool":"Complexity","filePath":"converison/choices.go","grade":"B+","username":"HLamb","timestamp":"2025-10-12T17:10:09.707Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"cyclomaticComplexity","violatingCode":"The ConvertProtoToChoices and ConvertModelToProtoChoices functions have minimal branching, so cyclomatic complexity is not a concern in this code.\n\n```go\nif protoChoices == nil {\n\treturn nil\n}\n```","codeResolution":"The codeResolution addresses cyclomatic complexity by refactoring the conversion logic into a single, unified abstraction, reducing branching and improving maintainability. Replace the original conversion block with the following streamlined approach:\n\n```go\n// Use the Operation abstraction to handle conversion\nfunc ConvertChoices(src interface{}) interface{} {\n\top := getOperation(src)\n\treturn op.Convert(src)\n}\n```","severity":"Critical","rationale":"## Rationale\n\nThe cyclomatic complexity in this code is low, with each function containing only a single conditional branch. This simplicity enhances maintainability and testability, as there are minimal paths to cover and fewer opportunities for logic errors. By avoiding nested conditionals and keeping each function focused, the code remains easy to understand and modify. If complexity were to increase (e.g., by adding more branches or nested logic), it could lead to harder-to-maintain code and increased risk of bugs. Keeping cyclomatic complexity low is crucial for correctness and long-term maintainability.","lineStart":9,"lineEnd":22,"status":""},{"done":false,"titleTask":"nestingDepth","violatingCode":"The violatingCode does not exhibit excessive nesting, but the use of guard clauses in both conversion functions could be further streamlined for clarity.\n\n```go\nif protoChoices == nil {\n\treturn nil\n}\n```","codeResolution":"The codeResolution for nestingDepth focuses on flattening the control flow in the conversion functions by using early returns and removing unnecessary nesting.\n\n```go\n// Go\n\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\tif protoChoices == nil {\n\t\treturn nil\n\t}\n\treturn &jsonSchema.Choices{\n\t\tNumber:  int(protoChoices.Number),\n\t\tOptions: protoChoices.Options,\n\t}\n}\n\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n\tif modelChoices == nil {\n\t\treturn nil\n\t}\n\treturn &pb.Choices{\n\t\tNumber:  int32(modelChoices.Number),\n\t\tOptions: modelChoices.Options,\n\t}\n}\n```","severity":"Critical","rationale":"### Rationale\n\nThe code adheres well to nesting depth principles, maintaining a maximum depth of 2 (function scope and a single 'if' statement per function). This flat structure improves readability and maintainability, making it easy to follow the logic and reducing the risk of errors introduced by deeply nested conditions. Shallow nesting also facilitates unit testing and future modifications, as each function’s logic is clear and isolated. No excessive nesting is present, so performance and correctness are not negatively impacted.","lineStart":9,"lineEnd":18,"status":""},{"done":false,"titleTask":"functionMethodCounts","violatingCode":"The violatingCode only defines two functions, failing to separate responsibilities and limiting extensibility.\n\n```go\n// ConvertProtoToChoices converts a protobuf Choices to the Go model Choices\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\n// ConvertModelToProtoChoices converts a Go model Choices to a protobuf Choices\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n```","codeResolution":"The conversion logic should be refactored to delegate the transformation to dedicated helper functions, improving separation of concerns and maintainability.\n\n```go\n// Go\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\treturn convertProtoChoicesToModel(protoChoices)\n}\n\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n\treturn convertModelChoicesToProto(modelChoices)\n}\n```","severity":"Critical","rationale":"The code defines only two functions, each handling a distinct conversion between types. While this meets basic separation of concerns, it lacks extensibility and fails to anticipate future changes or additional conversion logic. If either function grows in complexity, the absence of further decomposition will hinder maintainability and testability. For example, validation or error handling is not modularized, so any new requirements would bloat these functions. Increasing the function count by extracting responsibilities (e.g., option validation) would improve clarity and scalability.","lineStart":5,"lineEnd":22,"status":""},{"done":false,"titleTask":"linesOfCode","violatingCode":"The violatingCode unnecessarily duplicates logic across two functions, inflating the linesOfCode count without abstraction.\n\n```go\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\tif protoChoices == nil {\n\t\treturn nil\n\t}\n\n\treturn &jsonSchema.Choices{\n\t\tNumber:  int(protoChoices.Number),\n\t\tOptions: protoChoices.Options,\n\t}\n}\n```","codeResolution":"The codeResolution for linesOfCode focuses on reducing redundancy and improving maintainability by abstracting the conversion logic into a reusable function. This approach streamlines the code and minimizes repetition.\n\n```go\n// Use a generic convertChoices function for both conversions\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\treturn convertChoices(protoChoices)\n}\n\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n\treturn convertChoices(modelChoices)\n}\n```","severity":"Critical","rationale":"The code snippet adheres well to linesOfCode principles, with concise, single-responsibility functions and minimal logic per function. This brevity improves maintainability, making it easier to review and update each conversion function. For example, both `ConvertProtoToChoices` and `ConvertModelToProtoChoices` are under 10 lines, reducing cognitive load and the risk of introducing errors. Keeping LoC low also enhances testability and performance, as there is less code to execute and fewer branches to cover. However, if additional validation or error handling is needed, care should be taken not to bloat these functions, preserving their clarity and maintainability.","lineStart":6,"lineEnd":22,"status":""},{"done":false,"titleTask":"dependenciesModules","violatingCode":"The code violates dependenciesModules principles by tightly coupling the conversion logic to specific external packages, reducing flexibility and maintainability.\n\n```go\nimport (\n\tpb \"github.com/firechimp-org/go-sdk/grpc\"\n\t\"github.com/firechimp-org/go-sdk/jsonSchema\"\n)\n```","codeResolution":"The codeResolution for dependenciesModules demonstrates a clean approach by directly mapping between protobuf and Go model types without introducing unnecessary dependencies. Here is the replacement code for the identified block, assuming all required abstractions are defined elsewhere:\n\n```go\n// Use the generic conversion operation abstraction\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\treturn getOperation(\"ProtoToModelChoices\").Convert(protoChoices)\n}\n\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n\treturn getOperation(\"ModelToProtoChoices\").Convert(modelChoices)\n}\n```","severity":"Critical","rationale":"The code imports two external packages: `pb \"github.com/firechimp-org/go-sdk/grpc\"` and `\"github.com/firechimp-org/go-sdk/jsonSchema\"`. This is appropriate for the conversion logic, as both types are needed. However, tightly coupling the conversion functions to these specific packages can hinder maintainability if the underlying libraries change or if you want to swap implementations. Using interfaces or abstraction layers could reduce dependency rigidity and make future refactoring easier. Over-reliance on external packages also increases the risk of breaking changes and complicates testing, as mocks or stubs may be needed for both dependencies.","lineStart":3,"lineEnd":5,"status":""}],"codeReviewTitle":"Complexity Code Review"}},"gradingDetails":{"grades":{"maintainabilityIndex":"A","qualityDesign":"A+","readability":"A+","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":2,"functionMethodCounts":2,"linesOfCode":31,"nestingDepth":2}},"hash":"85843e8a10d90b82568eddc81e7c0d31aee323d542caae20b362041f7c9551ce","id":"eJyVkzFPwzAQhf/KyQNqqjSRYIvElIEJqERHL4nrJKaxz7IvCFT1vyO3SVuTIsRmv7t7fvdJ3rPKe+m9Mu0GsWcFK1HbXn4q+mIpE7iVJRqShljBbCV2VStBoPmQTnk03HCjtEVHsOCGk62Bs1ZRN9SZQJ03yknRKW1X6Nq8xZXf7vLWWcFZaP+7992jeROd1FWYSMJ7eQ7lMQCtHRJusOxQCenHWOShAhsq9dDAVCME6iQ8IWjcyn7SuWkGI277LY4mk8HS1tl4TmB5iTWJsA8LqQaiqcdHMKo/1Tg5SYMzQQn3Q1jmLN7NLcepl0HX0hUAylCUKTtVkvTU92pJofFFlCAb1XR88RATfA4wNri+znyF8SeugHEON4Z4w3JxNDmTnG+aXOM9k4ym/kHyYnWD4MN9lOY3hlHPnCFLWaN6ua6oYwW7/IdcjCMtssM33io/cw=="}
{"assessingTool":"SOLID","filePath":"converison/choices.go","grade":"C-","username":"HLamb","timestamp":"2025-10-12T17:10:06.230Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The ConvertProtoToChoices and ConvertModelToProtoChoices functions lack interface abstraction, preventing substitutability and violating Liskov Substitution Principle.\n\n```go\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\tif protoChoices == nil {\n\t\treturn nil\n\t}\n\t// ...\n}\n```","codeResolution":"To improve Liskov Substitution Principle adherence, the conversion logic should delegate to an abstraction rather than directly handling struct fields. Replace the original code block with the following:\n\n```go\n// Golang\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\tif protoChoices == nil {\n\t\treturn nil\n\t}\n\top := getOperation(\"ProtoToModel\")\n\treturn op.Convert(protoChoices).(*jsonSchema.Choices)\n}\n```","severity":"High","rationale":"The code violates the Liskov Substitution Principle because it tightly couples conversion logic to specific types (`pb.Choices` and `jsonSchema.Choices`) without using interfaces or abstractions. This rigidity means alternative implementations or extensions cannot be substituted without modifying existing functions, reducing maintainability and flexibility. If requirements change or new types are introduced, the code must be rewritten rather than extended. Adhering to LSP would allow for easier testing, future-proofing, and improved correctness by enabling polymorphic behavior and reducing the risk of breaking changes.","lineStart":1,"lineEnd":22,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code violates dependency inversion by directly depending on concrete types from external packages rather than abstractions.\n\n```go\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n```","codeResolution":"The conversion functions should delegate transformation logic to an abstraction, enabling easier extension and testing.\n\n```go\n// Replace direct conversion logic with abstraction usage\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\treturn operationFactory.GetOperation(\"ProtoToModel\").Convert(protoChoices).(*jsonSchema.Choices)\n}\n\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n\treturn operationFactory.GetOperation(\"ModelToProto\").Convert(modelChoices).(*pb.Choices)\n}\n```","severity":"Critical","rationale":"This code tightly couples the conversion logic to specific protobuf and Go model types, violating dependency inversion principles. By directly referencing concrete types (`pb.Choices`, `jsonSchema.Choices`), it becomes difficult to extend or test the conversion functions in isolation. This approach reduces maintainability, as any changes to the underlying types require updates throughout the codebase. Introducing interfaces or abstraction layers would decouple the conversion logic, improving flexibility and enabling easier unit testing.","lineStart":1,"lineEnd":18,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The code violates openClosed principles by requiring modification of existing conversion functions to support new fields or types, rather than allowing extension.\n\n```go\nreturn &jsonSchema.Choices{\n\tNumber:  int(protoChoices.Number),\n\tOptions: protoChoices.Options,\n}\n```","codeResolution":"The conversion logic is refactored to leverage an abstraction for openClosed compliance, allowing new conversion types to be added without modifying existing functions.\n\n```go\n// Replacement for the original conversion block\nfunc ConvertChoices(src interface{}) interface{} {\n\top := getOperation(src)\n\treturn op.Convert(src)\n}\n```","severity":"Critical","rationale":"Violating the open/closed principle here means any changes to the Choices structure (e.g., adding new fields) require modifying both conversion functions directly. This tightly couples the conversion logic to the data model, making maintenance difficult and error-prone as the codebase evolves. Such rigidity increases the risk of bugs if updates are missed and hinders extensibility, since supporting new fields or types demands manual changes throughout. Refactoring to use interfaces or reflection could allow the code to adapt to model changes without direct modification, improving maintainability and adherence to open/closed principles.","lineStart":13,"lineEnd":19,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"C-","openClosedScore":"F","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package converison\n\nimport (\n\tpb \"github.com/firechimp-org/go-sdk/grpc\"\n\t\"github.com/firechimp-org/go-sdk/jsonSchema\"\n)\n\n// ConvertProtoToChoices converts a protobuf Choices to the Go model Choices\nfunc ConvertProtoToChoices(protoChoices *pb.Choices) *jsonSchema.Choices {\n\tif protoChoices == nil {\n\t\treturn nil\n\t}\n\n\treturn &jsonSchema.Choices{\n\t\tNumber:  int(protoChoices.Number),\n\t\tOptions: protoChoices.Options,\n\t}\n}\n\n// ConvertModelToProtoChoices converts a Go model Choices to a protobuf Choices\nfunc ConvertModelToProtoChoices(modelChoices *jsonSchema.Choices) *pb.Choices {\n\tif modelChoices == nil {\n\t\treturn nil\n\t}\n\n\treturn &pb.Choices{\n\t\tNumber:  int32(modelChoices.Number),\n\t\tOptions: modelChoices.Options,\n\t}\n}\n","reason":"Modified","start":1,"end":31,"grade":"C-"}]},"hash":"cfae6060fb5ce395e4e6f4a5869667d14363d551068722b03ffd683fbbd14051","id":"eJyVkzFrwzAQhf/KoaHYwbGh3QyZUiiFtgkkoxZbkW019p2Q5C4h/70osZOoTindpHd3T+8+0IEV1kprFdZbopblbLN6e31mCRO0k0tCJ9GxnOlC7ItagiD8kkZZQo4cVafJOIg4cqdL4KxWrunLVFCXVcpI0ahOz8nUWU1zu9tntdGCM9/+d++nJdyIRnaFn4j9e1kGy1MAtzbkaEvLhpSQdojlLBSgfaXsKxhrjsA1El4IOtrJdtQ5Vj2K+37RyWQ0mOkyHc4xzK6xRhEOfiFVQTC1WACq9lzjzkjXG/SKvx/9MhfxYWo5TH30XSlNDqDQBZnScyVOzn0r7RShzYME6aAmw4vHkOC7h7Gl9W3mG4w/cXmMU7ghxDuW0cnkQnK6aXyL90IymPoHyavVHYJPj0Ga3xgGPVOGLGGVauW6cA3L2fU/ZGIYqYkdvwHlzDzA"}
{"assessingTool":"SOLID","filePath":"client/processResponse.go","grade":"F","username":"HLamb","timestamp":"2025-10-12T17:10:04.001Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The ResponseProcessor type is tightly coupled to a specific implementation and does not use interface abstraction, violating Liskov Substitution Principle.\n\n```go\n// ResponseProcessor responsible for processing the HTTP response\ntype ResponseProcessor struct{}\n```","codeResolution":"The revised solution introduces an abstraction for response processing, enabling substitutability and adherence to the Liskov Substitution Principle.\n\n```go\n// Go\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n    operation := getOperation(resp)\n    return operation.Execute(resp)\n}\n```","severity":"Critical","rationale":"This implementation tightly couples response processing logic to the `ResponseProcessor` concrete type, violating Liskov Substitution Principle. Without an interface abstraction, alternative response processors cannot be substituted, making the code rigid and difficult to extend or test. This reduces maintainability, as any change requires modifying the core type rather than swapping implementations. It also impacts correctness: if specialized processing is needed (e.g., for different response formats), the lack of substitutability forces unsafe workarounds or code duplication. Introducing a `ResponseProcessor` interface would allow flexible, testable, and robust code that adheres to Liskov Substitution.","lineStart":17,"lineEnd":41,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The ResponseProcessor violates interface segregation by combining response parsing, error handling, and resource management into a single struct, forcing clients to depend on all responsibilities.\n\n```go\ntype ResponseProcessor struct{}\n\n// ProcessResponse processes the response and returns the parsed Response struct\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n\tdefer func(Body io.ReadCloser) {\n\t\terr := Body.Close()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error closing body\")\n\t\t}\n\t}(resp.Body)\n```","codeResolution":"The revised solution applies interface segregation by delegating response parsing to a dedicated abstraction, ensuring ResponseProcessor only depends on the minimal interface it requires.\n\n```go\n// Go\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"received non-200 response code: %d\", resp.StatusCode)\n\t}\n\n\tparser := getResponseParser() // Returns an implementation of ResponseParser\n\treturn parser.Parse(resp.Body)\n}\n```","severity":"Critical","rationale":"This implementation violates interface segregation by combining response parsing, error handling, and resource management into a single struct (ResponseProcessor). This monolithic design forces clients to depend on all processing logic, even if they only need a subset (e.g., just decoding JSON). Such coupling reduces maintainability, as changes to one responsibility can inadvertently affect others. It also complicates testing, since mocking or replacing only the decoding logic is not possible without inheriting unrelated concerns. Adhering to interface segregation would allow more focused, reusable components, improving correctness and flexibility.","lineStart":15,"lineEnd":27,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The ResponseProcessor violates openClosed principles by requiring modification of its core logic to support new response formats or processing behaviors.\n\n```go\nif err := json.NewDecoder(resp.Body).Decode(&response); err != nil {\n    return nil, fmt.Errorf(\"error decoding response: %v\", err)\n}\n```","codeResolution":"The revised solution introduces an abstraction layer for response processing, enabling extension without modifying existing code and thus adhering to the Open/Closed Principle.\n\n```go\n// Go\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n    operation := getOperation(resp.StatusCode)\n    return operation.Execute(resp.Body)\n}\n```","severity":"Critical","rationale":"This implementation violates the Open/Closed Principle because any change to the response format or addition of new response types requires modifying the `ProcessResponse` method directly (lines 15–29). This tightly couples parsing logic to a single struct, making the code harder to extend and maintain. As requirements evolve, such as supporting XML or custom error handling, developers must repeatedly alter core logic, increasing the risk of bugs and regressions. Refactoring to use interfaces or strategy patterns would allow new response types to be added without changing existing code, improving maintainability and correctness.","lineStart":23,"lineEnd":27,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The ResponseProcessor directly depends on concrete types and lacks abstraction, violating dependency inversion principles.\n\n```go\ntype ResponseProcessor struct{}\nfunc NewResponseProcessor() ResponseProcessor {\n\treturn ResponseProcessor{}\n}\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n```","codeResolution":"The revised solution introduces an abstraction layer for response processing, enabling flexible dependency injection and improved testability.\n\n```go\n// Go\ntype ResponseProcessor interface {\n    ProcessResponse(resp *http.Response) (*Response, error)\n}\n\n// Usage with injected abstraction\nfunc HandleResponse(rp ResponseProcessor, resp *http.Response) (*Response, error) {\n    return rp.ProcessResponse(resp)\n}\n```","severity":"Critical","rationale":"This code violates dependency inversion by directly depending on the concrete *http.Response* type within *ProcessResponse* (lines 13–32). This tight coupling makes the code harder to test, extend, or reuse, since any change to the response source or format requires modifying the processor itself. By not abstracting the response handling (e.g., via an interface), maintainability suffers and mocking for unit tests becomes difficult. Refactoring to depend on abstractions would improve flexibility and testability, aligning with dependency inversion principles.","lineStart":13,"lineEnd":41,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"F","liskovSubstitutionScore":"F","openClosedScore":"F","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package client\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n\n// ResponseProcessor responsible for processing the HTTP response\ntype ResponseProcessor struct{}\n\n// NewResponseProcessor initializes a new ResponseProcessor\nfunc NewResponseProcessor() ResponseProcessor {\n\treturn ResponseProcessor{}\n}\n\n// ProcessResponse processes the response and returns the parsed Response struct\nfunc (rp *ResponseProcessor) ProcessResponse(resp *http.Response) (*Response, error) {\n\tdefer func(Body io.ReadCloser) {\n\t\terr := Body.Close()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error closing body\")\n\t\t}\n\t}(resp.Body)\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"received non-200 response code: %d\", resp.StatusCode)\n\t}\n\n\tvar response Response\n\tif err := json.NewDecoder(resp.Body).Decode(&response); err != nil {\n\t\treturn nil, fmt.Errorf(\"error decoding response: %v\", err)\n\t}\n\n\treturn &response, nil\n}\n","reason":"Modified","start":1,"end":38,"grade":"F"}]},"hash":"5084220b86fa051673fce7ba420d3e4965d0c14107a99df322da5c532f28b663","id":"eJx1U0tv2zAM/iucgA524TnFji5yWTpgw4Y2SHPUxbVoR5tDGRKTIAvy3wdJlts12U3i43uI1EnUzqFzmrq1Mb2oxPPTz+8PohCNUbgwxEgsKjHUze+6Q2h6jcSSJOntYCxDJkmyFEiNUZq62S9nSIoYbLecjtqkEyHPNsyDv+ceaDaDFbrBkMOlNQ06ZyzYGNEvPUJrLAwxo6kD3iB8W6+XqQYl8XHAKyCO7a7h03lkecTDZY0mzbru9R90UAPh4RJHUruj5mp7ll+hPXmjFnln6TLr1SRBYzDVJJPogsdkD2pSEOFiYqitQzVBjzZHlZkd4PaCNX/PlXl0uPWDKFMsh2zqLACt9X3BjMIWLXj87ItRR9CmXGGtFr1xmGoko7VQzcFXlCGV5TGhW48GH+ZAuk/Vktstl0uriXvKpPjq+aDpTRjyi1FHKcZ+/158DpJLjx7WJsCG0DPXvHMLo9BTBEsx9PQjkY3TIN0X4GkDWZtJYbFBvUcFZOjT57u711f3+1/BjZKieE8TZJ2jiH1tX3tW00ZOpqs5+C9RPuLhAT2mfeOjjKHsY0LI76+81H/FhxGBwvj1JhkV3Oy9arT2rdIRZuIqPGJYRlGIVve4rHkjKhG/+Gz4d2HKzojzXzDhiYM="}
{"assessingTool":"SOLID","filePath":"converison/map.go","grade":"C","username":"HLamb","timestamp":"2025-10-12T17:10:01.752Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The ConvertMapToStruct and ConvertStructToMap functions do not utilize interface abstraction, violating liskovSubstitution by preventing substitutability and extension.\n\n```go\nfunc ConvertMapToStruct(m map[string]interface{}) (*structpb.Struct, error) {\n\treturn structpb.NewStruct(m)\n}\n```","codeResolution":"The conversion logic is refactored to use an Operation abstraction, enabling substitutability and adherence to the Liskov Substitution Principle.\n\n```go\n// Go\nfunc ConvertMapToStruct(m map[string]interface{}) (*structpb.Struct, error) {\n    op := getOperation(\"mapToStruct\")\n    return op.Execute(m)\n}\n\nfunc ConvertStructToMap(s *structpb.Struct) (map[string]interface{}, error) {\n    op := getOperation(\"structToMap\")\n    return op.Execute(s)\n}\n```","severity":"Critical","rationale":"This implementation does not adhere to Liskov Substitution Principle, as there is no abstraction or interface for conversion operations. Directly coupling the conversion logic to specific types (lines 5–13) makes it impossible to substitute alternative conversion strategies without modifying client code. This rigidity reduces maintainability and testability, since new conversion formats or logic cannot be introduced polymorphically. Introducing an interface for conversion would allow interchangeable implementations, improving extensibility and correctness.","lineStart":0,"lineEnd":13,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The ConvertMapToStruct and ConvertStructToMap functions directly depend on the concrete structpb package, violating dependency inversion by not abstracting external dependencies.\n\n```go\nimport \"google.golang.org/protobuf/types/known/structpb\"\n```","codeResolution":"The conversion logic should delegate to an abstraction for map-struct operations, enabling easier testing and extension.\n\n```go\n// Go\nfunc ConvertMapToStruct(m map[string]interface{}) (*structpb.Struct, error) {\n\treturn getOperation(\"mapToStruct\").Execute(m)\n}\n\nfunc ConvertStructToMap(s *structpb.Struct) (map[string]interface{}, error) {\n\treturn getOperation(\"structToMap\").Execute(s)\n}\n```","severity":"Critical","rationale":"This code tightly couples conversion logic to the external structpb package, violating dependency inversion principles. By directly depending on a concrete implementation, any changes in structpb or a need to swap out the serialization format would require significant refactoring throughout the codebase. This approach reduces maintainability and testability, as mocking or substituting the conversion logic is difficult. Introducing an abstraction layer (e.g., an interface for conversion) would decouple the code, making it easier to extend, test, and adapt to future changes.","lineStart":1,"lineEnd":9,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"F","openClosedScore":"A+","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package converison\n\nimport \"google.golang.org/protobuf/types/known/structpb\"\n\n// Convert map[string]interface{} to *structpb.Struct\nfunc ConvertMapToStruct(m map[string]interface{}) (*structpb.Struct, error) {\n\treturn structpb.NewStruct(m)\n}\n\n// Convert *structpb.Struct to map[string]interface{}\nfunc ConvertStructToMap(s *structpb.Struct) (map[string]interface{}, error) {\n\treturn s.AsMap(), nil\n}\n","reason":"Modified","start":1,"end":14,"grade":"C"}]},"hash":"5087c656df5f53ff3db70bda90c5f70cc707a11d9b04868bffa94c4180c07605","id":"eJx1kcFKxEAMhl9lyKmV0rn3JutFcFXY3hwPszUdh22TYSZ1kaXvLu1SxVpvgfz/lw9yAZsSpuTJ1cwdVHB4eri/gwIafsMdkyAJVBBsc7IOVcP0gdEnJkOGfB84ijLgmF2HpePOkis5Oh0iCx+HVstnwKRPxGfSSeLQSDgamNpaq92ME9Xb8JIkenKvngRjaxu8jEpY3Syd8jAPhtqBmqW4t6Hm6yLr/6HkKltDCoUxcszVxZCRiDJEUt+ZRzwvyNzQuFJdsybJ7cO/Va/pmvc2ZOkPJVfZNmRbtbxNEycvFPludoQCWt/hs5V3qODnTbq3oXQM4xdx5bd7"}
{"assessingTool":"SOLID","filePath":"converison/grpcConverison.go","grade":"B","username":"HLamb","timestamp":"2025-10-12T17:09:59.264Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code tightly couples conversion logic directly to concrete types from external packages, violating dependency inversion and reducing flexibility.\n\n```go\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n\tif protoDef == nil {\n\t\treturn nil\n\t}\n\t// ...\n}\n```","codeResolution":"The solution for dependency inversion restructures the conversion logic to depend on an abstract Operation interface, allowing flexible injection of conversion strategies. Replace the original conversion block with the following:\n\n```go\n// Golang\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n\tif protoDef == nil {\n\t\treturn nil\n\t}\n\top := getOperation(\"protoToModel\")\n\treturn op.Execute(protoDef).(*jsonSchema.Definition)\n}\n```","severity":"High","rationale":"The code tightly couples conversion logic to specific protobuf and model types (e.g., `pb.Definition`, `jsonSchema.Definition`) without using interfaces or abstractions. This direct dependency makes it difficult to extend or test conversion logic for new types or schemas, as every change requires modifying the core functions. For example, both `ConvertProtoToModel` and `ConvertModelToProto` directly reference concrete types on nearly every line, violating the Dependency Inversion Principle. This reduces maintainability and flexibility, as the code cannot easily support alternative serialization formats or mock implementations for testing. Introducing interfaces for conversion would decouple the logic, improving testability and future extensibility.","lineStart":3,"lineEnd":67,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The conversion functions in this code violate interfaceSegregation by combining multiple unrelated responsibilities into single, monolithic functions rather than delegating to focused interfaces.\n\n```go\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n\t// ... handles many unrelated fields and conversions in one place ...\n}\n```","codeResolution":"The solution restructures the conversion logic to delegate each nested conversion to specialized operation abstractions, ensuring each concern is handled by a focused interface.\n\n```go\n// Go\nmodelDef.Items = getOperation(\"items\").Convert(protoDef.GetItems())\nmodelDef.HashMap = getOperation(\"hashMap\").Convert(protoDef.GetHashMap())\nmodelDef.NarrowFocus = getOperation(\"focus\").Convert(protoDef.GetNarrowFocus())\nmodelDef.Req = getOperation(\"request\").Convert(protoDef.GetReq())\nmodelDef.Choices = getOperation(\"choices\").Convert(protoDef.GetChoices())\nmodelDef.SpeechToText = getOperation(\"speechToText\").Convert(protoDef.GetSpeechToText())\nmodelDef.TextToSpeech = getOperation(\"textToSpeech\").Convert(protoDef.GetTextToSpeech())\nmodelDef.SendImage = getOperation(\"sendImage\").Convert(protoDef.GetSendImage())\n```","severity":"High","rationale":"The code violates the Interface Segregation Principle by tightly coupling conversion logic for multiple distinct types (e.g., SpeechToText, TextToSpeech, SendImage) into a single package without using focused interfaces. This approach forces clients to depend on all conversion functions, even if they only need one, reducing modularity and making future changes riskier. For example, lines like `func ConvertProtoToModel(protoDef *pb.Definition)` and the various `convertProto...` helpers are all exposed together, rather than behind minimal, type-specific interfaces. This can negatively impact maintainability, as changes to one conversion may inadvertently affect others, and it complicates testing and extension. Introducing fine-grained interfaces for each conversion concern would improve separation and adherence to ISP.","lineStart":1,"lineEnd":67,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"C-","interfaceSegregationScore":"C-","liskovSubstitutionScore":"A+","openClosedScore":"A-","singleResponsibilityScore":"A"},"codeDiff":{"changes":[{"newCode":"package converison\n\nimport (\n\tpb \"github.com/firechimp-org/go-sdk/grpc\"\n\t\"github.com/firechimp-org/go-sdk/jsonSchema\"\n)\n\n// ConvertProtoToModel converts a protobuf Definition to your Go model Definition\nfunc ConvertProtoToModel(protoDef *pb.Definition) *jsonSchema.Definition {\n\tif protoDef == nil {\n\t\treturn nil\n\t}\n\n\tmodelDef := &jsonSchema.Definition{\n\t\tType:               jsonSchema.DataType(protoDef.Type),\n\t\tInstruction:        protoDef.Instruction,\n\t\tProperties:         make(map[string]jsonSchema.Definition),\n\t\tItems:              ConvertProtoToModel(protoDef.GetItems()), // Use Getters to handle nil cases\n\t\tModel:              protoDef.Model,\n\t\tProcessingOrder:    protoDef.ProcessingOrder,\n\t\tSystemPrompt:       getStringPointer(protoDef.GetSystemPrompt()), // Safe getter for pointers\n\t\tImprovementProcess: protoDef.ImprovementProcess,\n\t\tSelectFields:       protoDef.SelectFields,\n\t\tVoters:             protoDef.Voters,\n\t\tHashMap:            ConvertProtoToHashMap(protoDef.GetHashMap()),   // Check with Getters\n\t\tNarrowFocus:        ConvertProtoToFocus(protoDef.GetNarrowFocus()), // Handle nil safely\n\t\tReq:                ConvertProtoToRequestFormat(protoDef.GetReq()),\n\t\tChoices:            ConvertProtoToChoices(protoDef.GetChoices()),\n\t\tSpeechToText:       convertProtoSpeechToText(protoDef.GetSpeechToText()), // Safely handle nested structs\n\t\tTextToSpeech:       convertProtoTextToSpeech(protoDef.GetTextToSpeech()),\n\t\tSendImage:          convertProtoSendImage(protoDef.GetSendImage()), // Handle nil structs\n\t\tStream:             protoDef.Stream,\n\t}\n\n\t// Handle Properties map\n\tif protoDef.Properties != nil {\n\t\tfor key, protoProperty := range protoDef.Properties {\n\t\t\tmodelDef.Properties[key] = *ConvertProtoToModel(protoProperty)\n\t\t}\n\t}\n\n\treturn modelDef\n}\n\n// Helper function to safely get string pointers\nfunc getStringPointer(val string) *string {\n\tif val == \"\" {\n\t\treturn nil\n\t}\n\treturn &val\n}\n\n// ConvertModelToProto converts your Go model Definition to a protobuf Definition\nfunc ConvertModelToProto(modelDef *jsonSchema.Definition) *pb.Definition {\n\tif modelDef == nil {\n\t\treturn nil\n\t}\n\n\tsystemPrompt := \"\"\n\tif modelDef.SystemPrompt != nil {\n\t\tsystemPrompt = *modelDef.SystemPrompt\n\t}\n\n\tprotoDef := &pb.Definition{\n\t\tType:               string(modelDef.Type),\n\t\tInstruction:        modelDef.Instruction,\n\t\tProperties:         make(map[string]*pb.Definition),\n\t\tItems:              ConvertModelToProto(modelDef.Items),\n\t\tModel:              modelDef.Model,\n\t\tProcessingOrder:    modelDef.ProcessingOrder,\n\t\tSystemPrompt:       systemPrompt,\n\t\tImprovementProcess: modelDef.ImprovementProcess,\n\t\tSelectFields:       modelDef.SelectFields,\n\t\tVoters:             modelDef.Voters,\n\t\tHashMap:            ConvertModelToProtoHashMap(modelDef.HashMap),\n\t\tNarrowFocus:        ConvertModelToProtoFocus(modelDef.NarrowFocus),\n\t\tReq:                ConvertModelToProtoRequestFormat(modelDef.Req),\n\t\tChoices:            ConvertModelToProtoChoices(modelDef.Choices),\n\t\tImage:              convertModelImage(modelDef.Image),\n\t\tSpeechToText:       convertModelSpeechToText(modelDef.SpeechToText),\n\t\tTextToSpeech:       convertModelTextToSpeech(modelDef.TextToSpeech),\n\t\tSendImage:          convertModelSendImage(modelDef.SendImage),\n\t\tStream:             modelDef.Stream,\n\t}\n\n\t// Handle Properties map\n\tif modelDef.Properties != nil {\n\t\tfor key, modelProperty := range modelDef.Properties {\n\t\t\tprotoDef.Properties[key] = ConvertModelToProto(&modelProperty)\n\t\t}\n\t}\n\n\treturn protoDef\n}\n\n// Helper functions for SpeechToText, TextToSpeech, and other nested structs\n\nfunc convertProtoSpeechToText(speechToText *pb.SpeechToText) *jsonSchema.SpeechToText {\n\tif speechToText == nil {\n\t\treturn nil\n\t}\n\treturn &jsonSchema.SpeechToText{\n\t\tModel:             jsonSchema.SpeechToTextModel(speechToText.Model),\n\t\tAudioToTranscribe: speechToText.AudioToTranscribe,\n\t\tLanguage:          speechToText.Language,\n\t\tToString:          speechToText.ToString,\n\t\tToCaptions:        speechToText.ToCaptions,\n\t\tFormat:            jsonSchema.AudioFormat(speechToText.Format),\n\t}\n}\n\nfunc convertProtoTextToSpeech(textToSpeech *pb.TextToSpeech) *jsonSchema.TextToSpeech {\n\tif textToSpeech == nil {\n\t\treturn nil\n\t}\n\treturn &jsonSchema.TextToSpeech{\n\t\tModel:         jsonSchema.TextToSpeechModel(textToSpeech.Model),\n\t\tVoice:         jsonSchema.Voice(textToSpeech.Voice),\n\t\tStringToAudio: textToSpeech.StringToAudio,\n\t\tFormat:        jsonSchema.AudioFormat(textToSpeech.Format),\n\t}\n}\n\nfunc convertProtoSendImage(sendImage *pb.SendImage) *jsonSchema.SendImage {\n\tif sendImage == nil {\n\t\treturn nil\n\t}\n\treturn &jsonSchema.SendImage{\n\t\tImagesData: sendImage.ImagesData,\n\t}\n}\n\nfunc convertModelSpeechToText(speechToText *jsonSchema.SpeechToText) *pb.SpeechToText {\n\tif speechToText == nil {\n\t\treturn nil\n\t}\n\treturn &pb.SpeechToText{\n\t\tModel:             string(speechToText.Model),\n\t\tAudioToTranscribe: speechToText.AudioToTranscribe,\n\t\tLanguage:          speechToText.Language,\n\t\tToString:          speechToText.ToString,\n\t\tToCaptions:        speechToText.ToCaptions,\n\t\tFormat:            string(speechToText.Format),\n\t}\n}\n\nfunc convertModelTextToSpeech(textToSpeech *jsonSchema.TextToSpeech) *pb.TextToSpeech {\n\tif textToSpeech == nil {\n\t\treturn nil\n\t}\n\treturn &pb.TextToSpeech{\n\t\tModel:         string(textToSpeech.Model),\n\t\tVoice:         string(textToSpeech.Voice),\n\t\tStringToAudio: textToSpeech.StringToAudio,\n\t\tFormat:        string(textToSpeech.Format),\n\t}\n}\n\nfunc convertModelSendImage(sendImage *jsonSchema.SendImage) *pb.SendImage {\n\tif sendImage == nil {\n\t\treturn nil\n\t}\n\treturn &pb.SendImage{\n\t\tImagesData: sendImage.ImagesData,\n\t}\n}\n\nfunc convertModelImage(image *jsonSchema.Image) *pb.Image {\n\tif image == nil {\n\t\treturn nil\n\t}\n\treturn &pb.Image{\n\t\tModel: string(image.Model),\n\t\tSize:  string(image.Size),\n\t}\n}\n","reason":"Modified","start":1,"end":177,"grade":"B"}]},"hash":"06d8c3f79781256f5d6ff40428b3cc68985ace998b2684030cb7e49ed019e5a9","id":"eJzlWU1v2zgQ/StcHYI4cO27AB8WCfIBtNsg9vZS98DIY1lri1RIOl1vkP++4KeGMmU7SW/NKeLMPM5whu8RyUtGpQQpK1bOON9keTb9+vnuKhtmBV/AJWcKmMryrKHFmpZACs6eQVSSszmbs6puuFDkfM7mqnkk86ys1Gr7OCp4PV5WAopVVTefuCjHJf8kF+txKZpinmn3477/SM6mxQpqqiMGer/xmFyaBNS94IrP+Be+gI1LSklCSaPXH7dLcgXLilWq4owoTnZ8K8gNJ7Xxb21zttyyIgV6bpCuYEkumsdRGzEgF21iaJ286KqqJQlxkwlh1cauz5UAtRVMr+jvV13NXJl0tG8+IWdJWBc92zWQk/gH+1NFtUtIeqS/BkMbfMekEttCwwWM4IiMzv1e8AaEqkC2O9Z0Dec1bb5LJSpW/kjmGvZTUMtOtodOeHQDNuZ8MBiS8Zj8LYHcgFIgpG7eirLFBsxhFlSCtLsYjM4uAdEY23oKO+FfxQJEHjl2jC5kupMK6nvB60b5LUpQU1P8Pa+YAhGljwN8FVO6BB2lQJAlF6SxcS79u7oR/BlqYD7BHDVlz+gTgw0U6rqCzSKccIjCRuf/jesd8/QhWaPzvKVy9YU2kWvcNOcR1e3XdMlEF325gmJNflZq5Tto4f+iQvCf17zYttnE8MYWgaMYf6a37ShIuoTNzqI/wFP3dnTQH+BpC1Jdc1FTFe3yAE8a3QJdrnhVgDxwCs4jgvBrAWbaABSrGZ/Bv2F+CgSD7fEcYQOao80u3AKQChbEXlp3uNp75kBT22F7tF1kaLMHtriraYkZJ8re2+PUw2qiVzjbqRJA656ZtMYh4sgWqSUmUtOmQ7cjZP0jYl5999awG1pX57bTlCsoKyGJ4EJbhkbG72vY/SATctHLaX6PgUV5RdU4GfCwc/bqdO0WNo0mii0rvGjZCdcUQiztIgoxsrVHSc9041wH5MLFeF3StsmEzLN51q9JfunsmW7a3FyhpsIZN/W2mtsnrbqCpB7HmotBz4MepjV20NHiUFuIO0FzJaJqPQT6QDowI0znnWmKwifkIhmDtgvPAS3xUfYHpN22LhzHUTUPju9T884L57iMJ5s2MgE+OiXPwfOYPONbd6I84774AhIS2yb7Foltm3yaxAb/UyUWH6jX1ADiFvzJHpBSDGN1M4CgKA90QDUxUCydAfABnk5QTQzkZTJAuIUwcB3NQbpjYKy6oA7SEk5QXBMbCWvbTrTqkQ6IqS0Ga2Z7Q9HqCTpqcwqKiebLLQWMhFi23m8Vy4Sa9Ymlcd0XyxRCEMuEknqxTBHHWbRHv1h62F6xlOZ9jZs5JLghQ0LZgnC1ArH/frJq1Ps6k+jDyE80M5FQYUuQpij+mDwF+e1Bfenl1p4A+yjBOVju9eP153ZR8RmfCcpkIapHyKOER3t2F/eZsnIbT3YU5+3+TnH7Tulz9/bgfkkb09i8x93bXYDlprznQEwRjr4iHLs28BfoNTkN0X1X6MNMQ3Tvo2nAljANUfx7pgGjpqehx9lOAt4/noRvmoqTKMYSR5olRFHmr0fmmPOoxFFkSzerp1ERzEmNaulU+t/shQ2cGt/W4BSualh51z310S9IzaT+y0zeIo/a1d5i9vUq5qCeqz7YY6cPclAHrZ973Gv1d2SZVOnHhnX/FRGzSs8FHuzxzQdZpYOW7q8r8GTeSPn/SrZI4Z904El2SF3fQUwaH2EHjPNLWMEWUO0ljxKPk67enDBO1s2CO3ODFTd/Wv2nex856DXci2yYLasN3FO1yvKs/f+B+V/AZfgclTx7/R/mdror"}
{"assessingTool":"Complexity","filePath":"client/gzipRequestSender.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:09:58.829Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":5,"dependenciesModules":6,"functionMethodCounts":2,"linesOfCode":67,"nestingDepth":2}},"hash":"108e9c8181688efe13809e4c427ed98d5c41775deccbce6f99cea027e059369d","id":"eJydVVFP2zAQ/is3S0MJlPS9Eg+jINC0AaKdJk2RJje5pIbUDvaFrkz89+lsp7RrYRNPrS9393333fn8W0jn0Dml66kxjRiJsVm0Df5StBIDUZgSx0YTahIj0criXtYIRaNQU65zrRatsQRJrnPKxWxF6HIRDoVZtBadG9ZPqu2NqAtTKl0P75zRvbFaUP9XIw3nRN4/ZYDhEC5+qPYWHzp0NEFdogXlQIINJnDBRnNJ0GOiA5rj2mVmyhV0XCN4MppWLe7J68h2Bf1mKqFEOGQy2TjW+xwZXeFyDymtSMlGPSGz07jcBch11elib3iyBzCFw10Yz84idVbDwc5n/7VnP4qNGrDx+YU+u8aoU1aGFWTOrM3xWsISPk+ur9YaSl1CgA3iu9Zoh7GipLZuD9n0b6hkJh1+u/0yADL3qFlwpetBD+LZHG74p5AEQW4j3gDQWmPTIENnGxidQEwKR5CLoWzV0MzusKALDBOmc/JF29Cd3ckg40tlRx7LM0nS43BuNmRfpXVz2SQbNHk4SVXe7cMJaNVA1D72RqtmANWCsnMmXCW58MxhEXI1PIybLEbw8TEXHjeN/YrMx7EjnrjvSSlJbs1zTo/Svkx/ySWAv43ZaVdVPHk5set3qwh9YXzKrnAZLMnBdnAa0H8GHYJ38Mz8T9IL9boOGyHjxjhM0v/SZ2kVcWFkPKg/o31FnR1yG0jvaU7RmLWqbyNzXyxKQpAaLqfTm3Uzl4rmvlUbN4kbFu7tw3qy/Fxf4TKOe5KLm+vJlKE62wxgT0PeVxKz3Bi21+uZIMEcZYnWwTEoXTRduRajX9yxiuzSO2YTZOLxhTierlrk3LmQbduoQpIyOq769M3I8z69jw4vxv6ITx3NjVVPPndwP0Vp0UIujvxWSTcq0uXWdX9ZYtHcbzEGcu26N7V1Wdid2Znha/9u+Xm3/lv9mCRw0Krxu1oMRKUavJE0FyMR6PjHdGvHZrURz38ASFfPtQ=="}
{"assessingTool":"SOLID","filePath":"client/model.go","grade":"B-","username":"HLamb","timestamp":"2025-10-12T17:09:55.614Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependencyInversion","violatingCode":"The RequestBody struct directly depends on the concrete jsonSchema.Definition type, violating dependency inversion by coupling to a specific implementation.\n\n```go\ntype RequestBody struct {\n\tPrompt     string                 `json:\"prompt\"`\n\tDefinition *jsonSchema.Definition `json:\"definition\"`\n}\n```","codeResolution":"The solution introduces an abstraction layer for operation handling, ensuring the client code depends on interfaces rather than concrete implementations.\n\n```go\n// Go\nfunc ProcessRequest(req *RequestBody) (*Response, error) {\n    op := getOperation(req.Definition) // Returns an Operation interface\n    result, err := op.Execute(req.Prompt)\n    if err != nil {\n        return nil, err\n    }\n    return &Response{Data: result, UsdCost: calculateCost(result)}, nil\n}\n```","severity":"Critical","rationale":"This code tightly couples the RequestBody struct to the concrete jsonSchema.Definition type, violating dependency inversion principles. Such direct dependency on an external implementation makes the code harder to maintain and test, as changes in the jsonSchema package could ripple through client code. It also limits extensibility, since swapping out or mocking Definition for testing or future requirements becomes difficult. Introducing an interface or abstraction for Definition would decouple client from jsonSchema, improving maintainability and testability.","lineStart":6,"lineEnd":7,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The RequestBody struct violates the Open/Closed Principle because adding new request fields requires modifying the existing struct.\n\n```go\ntype RequestBody struct {\n\tPrompt     string                 `json:\"prompt\"`\n\tDefinition *jsonSchema.Definition `json:\"definition\"`\n}\n```","codeResolution":"The current code can be improved for openClosed by delegating the resolution logic to an abstraction, allowing new operations to be added without modifying existing code. Replace the violating block with the following:\n\n```go\n// Golang\nfunc codeResolution(request *RequestBody) (*Response, error) {\n\top := getOperation(request.Definition)\n\tresult, err := op.Resolve(request.Prompt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Response{Data: result.Data, UsdCost: result.UsdCost}, nil\n}\n```","severity":"High","rationale":"The current code tightly couples the RequestBody struct to a specific jsonSchema.Definition type, violating the Open/Closed Principle. This design means that any new schema type or extension requires modifying the RequestBody definition directly, reducing maintainability and making future enhancements error-prone. Such coupling can also hinder scalability, as adding support for new schema formats or validation logic would necessitate changes throughout the codebase. Adhering to openClosed would allow new schema types to be introduced via interfaces or abstractions, minimizing code changes and improving long-term flexibility.","lineStart":20,"lineEnd":13,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"C-","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package client\n\nimport \"github.com/firechimp-org/go-sdk/jsonSchema\"\n\ntype RequestBody struct {\n\tPrompt     string                 `json:\"prompt\"`\n\tDefinition *jsonSchema.Definition `json:\"definition\"`\n}\n\n// Create a response struct\ntype Response struct {\n\tData    map[string]any `json:\"data\"` //this data can then be marshalled into the apprioate object type.\n\tUsdCost float64        `json:\"usdCost\"`\n}\n","reason":"Modified","start":1,"end":15,"grade":"B-"}]},"hash":"e47d4062cd046d074d173a2343099dfad5262c9da25b437066cf41977041154a","id":"eJxdkUFPwzAMhf+K5SPa2gvi0CPbBQmJicGJIM1L3TZbG4fEPUzT/jvKyjbAtzzn+X2Jj0gpcUrOt28iPVa4fnl+WuIMrdS8EK/sFSsMZPfUMtjesVfjjXdDkKhgsHXajdvCylA2LrLt3BDmEtuylXmq9+UuiV/bjgcymI16CAyv/DVy0kepD5A0jlbhaLzRVZQhKORKGp1v4X9t8rzKYDjfNLjJtiU3zjt14uHullf8ki+2+iqdradMVJawiEzKQBA5BfGJf6iuuH/UiXVJSplooPAxwX6SP9ySSMngBspSO5cgH8GSB+3Yw5ZhoJg66nuuwXmVrAOFEJ1kEtnu2Crk9CKHvad6IUmh6YX04f7/b4xT+/ImnGHjel6RdljhtLRykJr7ohU8fQO/wbEg"}
{"assessingTool":"SOLID","filePath":"converison/focus.go","grade":"D","username":"HLamb","timestamp":"2025-10-12T17:09:54.465Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"openClosed","violatingCode":"The conversion functions violate openClosed principles by requiring modification for every new Focus field added.\n\n```go\nreturn &jsonSchema.Focus{\n    Prompt:       protoFocus.Prompt,\n    Fields:       protoFocus.Fields,\n    KeepOriginal: protoFocus.KeepOriginal,\n}\n```","codeResolution":"The conversion functions are currently tightly coupled to specific types, making extension difficult. Refactoring to use an abstraction for conversion operations enables open/closed compliance and easier future extension.\n\n```go\n// Go\nfunc ConvertProtoToFocus(protoFocus *pb.Focus) *jsonSchema.Focus {\n\treturn getOperation(\"ProtoToModel\").Convert(protoFocus).(*jsonSchema.Focus)\n}\n\nfunc ConvertModelToProtoFocus(modelFocus *jsonSchema.Focus) *pb.Focus {\n\treturn getOperation(\"ModelToProto\").Convert(modelFocus).(*pb.Focus)\n}\n```","severity":"Critical","rationale":"### Rationale\n\nThis code tightly couples the conversion logic to specific types (`pb.Focus` and `jsonSchema.Focus`), violating the Open/Closed Principle. Any future changes—such as supporting new focus types or conversion rules—will require modifying these functions directly, increasing the risk of bugs and regressions. This approach reduces maintainability and extensibility, as developers cannot add new conversion behaviors without altering existing code. Adhering to open/closed would allow new conversions to be added via interfaces or extension points, improving testability and long-term flexibility.","lineStart":1,"lineEnd":24,"status":""},{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The code violates Liskov Substitution Principle by directly coupling conversion logic to concrete types, preventing substitutability or extension via interfaces.\n\n```go\nfunc ConvertProtoToFocus(protoFocus *pb.Focus) *jsonSchema.Focus {\n\tif protoFocus == nil {\n\t\treturn nil\n\t}\n```","codeResolution":"The solution introduces an abstraction layer for conversion operations, enabling substitutability and adherence to the Liskov Substitution Principle.\n\n```go\n// Go\nfunc ConvertProtoToFocus(protoFocus *pb.Focus) *jsonSchema.Focus {\n    return getOperation(\"ProtoToModel\").Convert(protoFocus)\n}\n\nfunc ConvertModelToProtoFocus(modelFocus *jsonSchema.Focus) *pb.Focus {\n    return getOperation(\"ModelToProto\").Convert(modelFocus)\n}\n```","severity":"Critical","rationale":"The provided code snippet demonstrates a lack of adherence to the Liskov Substitution Principle (LSP) due to the absence of interface abstractions. The functions `ConvertProtoToFocus` and `ConvertModelToProtoFocus` are tightly coupled to specific types (`pb.Focus` and `jsonSchema.Focus`), making it difficult to substitute these implementations with alternative types without modifying the existing code. This rigidity can lead to maintainability issues, as any changes to the underlying types require updates across multiple functions. \n\nTo improve LSP adherence, consider defining interfaces for the focus types and using those interfaces in the conversion functions. This would allow for greater flexibility and easier testing, as different implementations could be substituted without altering the core logic, enhancing both maintainability and correctness.","lineStart":1,"lineEnd":22,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code directly depends on concrete types from external packages, violating dependency inversion by not abstracting these dependencies.\n\n```go\nfunc ConvertProtoToFocus(protoFocus *pb.Focus) *jsonSchema.Focus {\n```","codeResolution":"The conversion logic should delegate to an abstracted Operation interface, enabling flexible extension and improved testability.\n\n```go\n// Go\nfunc ConvertProtoToFocus(protoFocus *pb.Focus) *jsonSchema.Focus {\n    return getOperation(\"ProtoToFocus\").Execute(protoFocus)\n}\n\nfunc ConvertModelToProtoFocus(modelFocus *jsonSchema.Focus) *pb.Focus {\n    return getOperation(\"ModelToProtoFocus\").Execute(modelFocus)\n}\n```","severity":"Critical","rationale":"This code tightly couples the conversion logic to specific concrete types from external packages (`pb.Focus` and `jsonSchema.Focus`), violating dependency inversion principles. Such direct dependencies make the code harder to maintain and test, as any change in the external types or their structure requires changes throughout the conversion functions. Introducing abstractions or interfaces for the conversion process would decouple the implementation, improving flexibility and enabling easier mocking for unit tests. This would enhance maintainability and correctness, especially as the codebase grows or external dependencies evolve.","lineStart":1,"lineEnd":22,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"A+","liskovSubstitutionScore":"F","openClosedScore":"F","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package converison\n\nimport (\n\tpb \"github.com/firechimp-org/go-sdk/grpc\"\n\t\"github.com/firechimp-org/go-sdk/jsonSchema\"\n)\n\n// ConvertProtoToFocus converts a protobuf Focus to the Go model Focus\nfunc ConvertProtoToFocus(protoFocus *pb.Focus) *jsonSchema.Focus {\n\tif protoFocus == nil {\n\t\treturn nil\n\t}\n\n\treturn &jsonSchema.Focus{\n\t\tPrompt:       protoFocus.Prompt,\n\t\tFields:       protoFocus.Fields,\n\t\tKeepOriginal: protoFocus.KeepOriginal,\n\t}\n}\n\n// ConvertModelToProtoFocus converts a Go model Focus to a protobuf Focus\nfunc ConvertModelToProtoFocus(modelFocus *jsonSchema.Focus) *pb.Focus {\n\tif modelFocus == nil {\n\t\treturn nil\n\t}\n\n\treturn &pb.Focus{\n\t\tPrompt:       modelFocus.Prompt,\n\t\tFields:       modelFocus.Fields,\n\t\tKeepOriginal: modelFocus.KeepOriginal,\n\t}\n}\n","reason":"Modified","start":1,"end":33,"grade":"D"}]},"hash":"6d45c36b41ac83bd667288128cc1208056ed48ed4887906462e6d54b353c69df","id":"eJyVk8FugzAQRH9l5UOVRCTckXJK1apqqyAlR1/AGOMGvJZteony75UxDU6apionmJ0Zr5/EkRTWcmulEnvElmRkt317eSQJYVjxDSrHlSMZ0QU7FIIDQ/XJjbSoqKJKdhqNgxlV1OkSKBHSNX25YtiltTScNbLTSzQiFbi01SEVRjNKvP1v74dFtWMN7wqfmPvz0hQ2wwIuN+hwj0/Iejsu5SwUoL1e9jWEiUNwDYdnhA4r3gaVqrpX7FbTbIiH6EKXq+FtDotplSDB0V9B1hD512tQsg0T6gx3vVFe8d8nv/xZfLiuGzO5wU67DMIzVa/CIAmuJ8nbyt5whcHoeuVcb40UUhVtFrviQTLudrpk++5R7TGf7hYBvkTpAV9Dv8T7o2w2xEfG1yTmE/Yz48j/D8bfNTfZTpX32EauO2wj1y9sSUJq2fK8cA3JyPQHpfWQEkhOX9uSSko="}
{"assessingTool":"SOLID","filePath":"client/requestSender.go","grade":"D","username":"HLamb","timestamp":"2025-10-12T17:09:53.938Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"openClosed","violatingCode":"The DefaultRequestSender violates openClosed principles by requiring modification of its SendRequestBody method to support new request types or endpoints.\n\n```go\n// SendRequestBody sends a JSON request and returns a response\nfunc (rs *DefaultRequestSender) SendRequestBody(baseURL, token string, requestBody *RequestBody) (*http.Response, error) {\n    url := baseURL + \"/api/objectGen\"\n    // ...\n}\n```","codeResolution":"The solution for openClosed refactors the request sending logic to depend on an abstraction, allowing new request types or sending strategies to be added without modifying existing code.\n\n```go\n// SendRequestBody delegates to the injected Operation abstraction\nfunc (rs *DefaultRequestSender) SendRequestBody(baseURL, token string, requestBody *RequestBody) (*http.Response, error) {\n\toperation := getOperation(\"objectGen\") // Factory returns appropriate Operation\n\treturn operation.Execute(rs.client, baseURL, token, requestBody)\n}\n```","severity":"Critical","rationale":"This implementation violates the Open/Closed Principle because any change to the request format, endpoint, or headers requires direct modification of the `SendRequestBody` method (lines 15–49). This tightly couples the logic, making it difficult to extend for new request types or authentication schemes without editing existing code. Such rigidity hampers maintainability and increases the risk of introducing bugs when requirements evolve. Adhering to openClosed would allow new behaviors (e.g., custom headers or endpoints) to be added via extension—such as interfaces or strategy patterns—rather than modification, resulting in more robust and scalable code.","lineStart":20,"lineEnd":38,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The DefaultRequestSender directly depends on the concrete *http.Client type, violating dependency inversion by not relying on an abstraction.\n\n```go\ntype DefaultRequestSender struct{\n\tclient *http.Client\n}\n```","codeResolution":"The solution introduces an abstraction for sending requests, allowing the client code to depend on an interface rather than a concrete implementation, thus achieving proper dependency inversion.\n\n```go\n// Replace direct usage of DefaultRequestSender with the RequestSender interface\nfunc SendRequestBody(sender RequestSender, baseURL, token string, requestBody *RequestBody) (*http.Response, error) {\n    return sender.SendRequestBody(baseURL, token, requestBody)\n}\n```","severity":"Critical","rationale":"The code directly depends on the concrete *http.Client* type within *DefaultRequestSender*, violating dependency inversion. This tight coupling makes it difficult to substitute alternative HTTP clients (e.g., for testing or extending functionality), reducing maintainability and flexibility. Without abstraction, changes to the HTTP layer require modifications throughout the codebase, increasing the risk of bugs and making unit testing challenging. Introducing an interface for the HTTP client would decouple dependencies, improving testability and future extensibility.","lineStart":13,"lineEnd":38,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The DefaultRequestSender violates interface segregation by combining request creation, serialization, and sending logic into a single method, forcing clients to depend on all responsibilities.\n\n```go\nfunc (rs *DefaultRequestSender) SendRequestBody(baseURL, token string, requestBody *RequestBody) (*http.Response, error) {\n    // ... handles serialization, request creation, and sending ...\n}\n```","codeResolution":"The current DefaultRequestSender implementation can be improved by delegating request sending to a more focused abstraction, ensuring better adherence to the interface segregation principle:\n\n```go\n// Go\nfunc (rs *DefaultRequestSender) SendRequestBody(baseURL, token string, requestBody *RequestBody) (*http.Response, error) {\n\tsender := getRequestSender(rs.client)\n\treturn sender.SendJSON(baseURL+\"/api/objectGen\", token, requestBody)\n}\n```","severity":"High","rationale":"The current implementation violates the Interface Segregation Principle by combining request creation, serialization, and sending logic into a single method (`SendRequestBody`). This monolithic approach forces clients to depend on all aspects of the request process, even if they only need a subset of the functionality. Such tight coupling reduces maintainability, as changes to one responsibility (e.g., serialization) can impact unrelated consumers. It also hinders testability and flexibility, making it harder to swap out or mock specific behaviors. Refactoring into smaller, focused interfaces would improve modularity and adherence to interface segregation.","lineStart":17,"lineEnd":38,"status":""},{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The DefaultRequestSender violates Liskov Substitution Principle because it does not use an interface abstraction, preventing substitutability with other implementations.\n\n```go\ntype DefaultRequestSender struct{\n\tclient *http.Client\n}\n```","codeResolution":"To improve Liskov Substitution Principle adherence, the SendRequestBody logic should delegate to a RequestSender abstraction, allowing interchangeable implementations:\n\n```go\ngo\n// Replace direct usage of DefaultRequestSender with the RequestSender interface\nfunc SendRequestBody(sender RequestSender, baseURL, token string, requestBody *RequestBody) (*http.Response, error) {\n    return sender.SendRequestBody(baseURL, token, requestBody)\n}\n```","severity":"High","rationale":"The current implementation tightly couples the DefaultRequestSender to its own methods, lacking an interface abstraction. This violates the Liskov Substitution Principle because other request sender implementations cannot be substituted without changing client code. As a result, maintainability suffers—future enhancements or alternative senders (e.g., for testing or different protocols) require refactoring across the codebase. This rigidity also impacts correctness, as consumers cannot rely on polymorphic behavior. Introducing a RequestSender interface would allow seamless substitution, improving extensibility and adherence to LSP.","lineStart":9,"lineEnd":38,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"C-","liskovSubstitutionScore":"C-","openClosedScore":"F","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package client\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// DefaultRequestSender is a default implementation of RequestSender\ntype DefaultRequestSender struct{\n\tclient *http.Client\n}\n\n// NewDefaultRequestSender initializes a new DefaultRequestSender\nfunc NewDefaultRequestSender(client *http.Client) *DefaultRequestSender {\n\treturn &DefaultRequestSender{\n\t\tclient: client,\n\t}\n}\n\n// SendRequestBody sends a JSON request and returns a response\nfunc (rs *DefaultRequestSender) SendRequestBody(baseURL, token string, requestBody *RequestBody) (*http.Response, error) {\n\turl := baseURL + \"/api/objectGen\"\n\n\t// Serialize the request body to JSON\n\tjsonData, err := json.Marshal(requestBody)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error marshalling request body: %v\", err)\n\t}\n\n\t// Create an HTTP request\n\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating request: %v\", err)\n\t}\n\n\t// Set headers\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Authorization\", \"Bearer \"+token)\n\n\t// Send the request and return the response\n\tresp, err := rs.client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error sending request: %v\", err)\n\t}\n\n\treturn resp, nil\n}\n","reason":"Modified","start":1,"end":50,"grade":"D"}]},"hash":"d3b07376b505f35ebf98d592e4a59d7ec723c838816fa0d18279ecab5b940123","id":"eJydVEtP3DAQ/itTS60SSLP3lXoobFVaUUDs9uaLN5nsGrzjYE+KFsR/r/wILFVQJW6xZ/w95pFHobxH7zVtVtYaMRfLy/MfC1GJxrZ4aomRWMxFr5pbtUFojEZiSZL0rreOoZAkWYr1ntFLkQ5IjW01bWY33tJ42e14/CTk2Za5D+cyYM1msMBODYav8W5Az0ukFh1oDwraFAG96w3ukFixtgS2g1fJknjf4zSOZzc0/BjYkwE4Cvz1aXbzlEVc4P20DtKsldEPGAQR3k/SSOoGat4CKSaYSzia5ItKHfLgCD5NZcSE0cw8d6UKl08vbkJqfnVi2z14pDbo/7m8vACXAqCohcQUQg59b8ljtlI4P62w/Be8WCuPv6/PK2B7ixQqrmlTjTSR/+ggv4QiFeI6M1aAzllXJu+DMzD/AhkUjkGKmer1zK5vsOHvmKaKJEebLvUGeIvPvtaBkW00GxLDKC4Uq8gTsMNF/Us5v1WmOJAZBpJ1F9M+fAHSBnK1c0NImwq6HdffguCukCIqh13CMpo2r1TM4eMfKSJvmTuUlZ86VIygCM5Wq6vxUer93bPQWKYLvM/VK6S4ulyuAuLgTAVx80L8ZOg6dMVotHy3kSbIOnDxtoElMmxRteh8Vl2fxWO9xCA0/z8+r/Y9BgQpVN8b3cQNzn+HcvLl14G31umHmJmenqBy6ECK4zhi5YEKal/1/mWm8/U41IHI98+Vdb5Om1MvbBiBd1csbNb/C5ZBkgTSJm6qqESnDV4p3oq5SHJm7nDX6o0VT38B1o4LvA=="}
{"assessingTool":"SOLID","filePath":"client/grpcGenerateObject.go","grade":"C-","username":"HLamb","timestamp":"2025-10-12T17:09:53.593Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"singleResponsibility","violatingCode":"The GrpcGenerateObject method is responsible for both managing gRPC connection lifecycle and handling request/response logic, violating the single responsibility principle.\n\n```go\nconn, err := grpc.NewClient(c.BaseURL, grpc.WithInsecure(), grpc.WithBlock())\n...\ndefer func(conn *grpc.ClientConn) {\n    err = conn.Close()\n    if err != nil { }\n}(conn)\n```","codeResolution":"The solution applies the single responsibility principle by delegating the gRPC request logic to a dedicated abstraction, ensuring the client method only coordinates the operation.\n\n```go\n// Go\nfunc (c *Client) GrpcGenerateObject(prompt string, definition *pb.Definition) (*Response, error) {\n    op := getOperation(\"GenerateObject\", c.BaseURL, c.Password)\n    result, err := op.Execute(prompt, definition)\n    if err != nil {\n        return nil, err\n    }\n    return result, nil\n}\n```","severity":"High","rationale":"The method `GrpcGenerateObject` violates the Single Responsibility Principle by handling connection setup, authentication, request construction, RPC invocation, and response conversion all within a single function. This tightly coupled design makes the code harder to maintain and test, as changes to any one concern (e.g., authentication or connection logic) require modifications to the entire method. It also increases the risk of introducing bugs and reduces code clarity. Separating these responsibilities into distinct functions or types would improve maintainability, enable easier unit testing, and enhance overall code correctness.","lineStart":17,"lineEnd":36,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The GrpcGenerateObject method violates the Open/Closed Principle by hardcoding the gRPC method call, making it difficult to extend for other RPC methods without modifying the function.\n\n```go\nresponse, err := client.GenerateObject(ctx, request) // Replace 'GenerateObject' with the actual RPC method name\n```","codeResolution":"The current GrpcGenerateObject implementation can be improved for openClosed compliance by delegating the RPC method selection to an abstraction, allowing new operations without modifying this function.\n\n```go\n// SendRequestToServer sends a request to the gRPC server with authorization headers\nfunc (c *Client) GrpcGenerateObject(prompt string, definition *pb.Definition, op Operation) (*Response, error) {\n\t// ... (setup code as before) ...\n\trequest := &pb.RequestBody{\n\t\tPrompt:     prompt,\n\t\tDefinition: definition,\n\t}\n\tresponse, err := op.Execute(ctx, client, request)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"operation failed: %v\", err)\n\t}\n\tdata, err := converison.ConvertStructpbToMap(response.Data)\n\tres := &Response{\n\t\tData:    data,\n\t\tUsdCost: response.UsdCost,\n\t}\n\treturn res, nil\n}\n```","severity":"High","rationale":"The current implementation violates the Open/Closed Principle because any change to the request or response handling, such as supporting a new gRPC method or modifying metadata, requires direct modification of the `GrpcGenerateObject` function (lines 10–56). This tightly couples the logic to a specific RPC and request structure, making future extensions error-prone and harder to maintain. As new features or RPCs are added, developers must repeatedly alter the same function, increasing the risk of introducing bugs and regressions. Refactoring to use abstractions or interfaces for request construction and RPC invocation would allow the code to be extended without modifying existing logic, improving maintainability and scalability.","lineStart":22,"lineEnd":38,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code violates dependency inversion by directly instantiating and depending on the concrete gRPC client within the method, rather than relying on abstractions.\n\n```go\nclient := pb.NewJSONSchemaServiceClient(conn)\nresponse, err := client.GenerateObject(ctx, request)\n```","codeResolution":"The solution introduces an abstraction layer for gRPC operations, allowing the client to depend on an interface rather than a concrete implementation, which improves testability and flexibility.\n\n```go\n// Replace direct usage of pb.JSONSchemaServiceClient with an injected Operation abstraction\noperation := getOperation(conn) // Returns an Operation interface implementation\nresponse, err := operation.GenerateObject(ctx, request)\nif err != nil {\n    return nil, fmt.Errorf(\"failed to call GenerateObject: %v\", err)\n}\n```","severity":"Critical","rationale":"This code violates dependency inversion by directly instantiating and managing the gRPC connection and service client within the GrpcGenerateObject method (lines 10–24). This tight coupling to concrete implementations makes the code harder to test, maintain, and extend. For example, swapping out the gRPC client for a mock or alternative transport would require modifying this method, rather than simply injecting an abstraction. Adhering to dependency inversion would allow for easier unit testing, improved flexibility, and better separation of concerns.","lineStart":22,"lineEnd":44,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The GrpcGenerateObject method violates interface segregation by directly depending on the concrete pb.JSONSchemaServiceClient rather than an abstract, minimal interface.\n\n```go\nclient := pb.NewJSONSchemaServiceClient(conn)\nresponse, err := client.GenerateObject(ctx, request)\n```","codeResolution":"The current GrpcGenerateObject implementation can be improved by delegating the object generation logic to an Operation abstraction, promoting better interface segregation:\n\n```go\ngo\n// Replace direct gRPC call with Operation abstraction\noperation := getOperation(\"generateObject\")\nresult, err := operation.Execute(ctx, prompt, definition)\nif err != nil {\n    return nil, fmt.Errorf(\"operation failed: %v\", err)\n}\nreturn result, nil\n```","severity":"High","rationale":"The current implementation violates the Interface Segregation Principle by tightly coupling the `GrpcGenerateObject` method to the entire gRPC client and connection setup (lines 10–44). This monolithic approach forces consumers to depend on all aspects of request creation, connection management, and response handling, even if they only need a subset of this functionality. Such coupling reduces maintainability, as changes to connection logic or metadata handling will ripple through unrelated code. Splitting responsibilities into smaller, focused interfaces would allow for easier testing, extension, and reuse, improving both correctness and long-term code quality.","lineStart":17,"lineEnd":38,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"C-","liskovSubstitutionScore":"A+","openClosedScore":"C-","singleResponsibilityScore":"C-"},"codeDiff":{"changes":[{"newCode":"package client\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/firechimp-org/go-sdk/converison\"\n\tpb \"github.com/firechimp-org/go-sdk/grpc\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"time\"\n)\n\n// SendRequestToServer sends a request to the gRPC server with authorization headers\nfunc (c *Client) GrpcGenerateObject(prompt string, definition *pb.Definition) (*Response, error) {\n\t// Set up a connection to the gRPC server\n\tconn, err := grpc.NewClient(c.BaseURL, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect to server: %v\", err)\n\t}\n\tdefer func(conn *grpc.ClientConn) {\n\t\terr = conn.Close()\n\t\tif err != nil {\n\n\t\t}\n\t}(conn)\n\n\t// Create a new client from the gRPC service\n\tclient := pb.NewJSONSchemaServiceClient(conn)\n\n\t// Create a context with a timeout\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*10)\n\tdefer cancel()\n\n\t// Set up metadata with the authorization token\n\tmd := metadata.New(map[string]string{\"x-api-key\": c.Password})\n\tctx = metadata.NewOutgoingContext(ctx, md)\n\n\t// Create the request object\n\trequest := &pb.RequestBody{\n\t\tPrompt:     prompt,\n\t\tDefinition: definition,\n\t}\n\n\t// Call the gRPC method on the client\n\tresponse, err := client.GenerateObject(ctx, request) // Replace 'GenerateObject' with the actual RPC method name\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to call GenerateObject: %v\", err)\n\t}\n\n\tdata, err := converison.ConvertStructpbToMap(response.Data)\n\n\tres := &Response{\n\t\tData:    data,\n\t\tUsdCost: response.UsdCost,\n\t}\n\n\treturn res, nil\n}\n","reason":"Modified","start":1,"end":59,"grade":"C-"}]},"hash":"172a30e28a4bff4002054a70600a6c0dc841783a5acb5552409ccbb3a1903f14","id":"eJylVE2P4zYM/SusgHbtwGO3VwO5TKZYbLHdGSSz6KHuQZFpW40tuhI9M9tB/vtCkp2PzgJ7aA6JQlLke4+kXoV0Dp3Tpn0k6kUpdvcfP9yJTCiqcUOG0bAoxSjVQbYIqtdouDKV0cNIliGpTMWVUD7yhSsR/zbD6dhq7qZ9rmgoGm1RdXoYb8i2RUs3rj4UiswTWu3IxBvjHr5/qbWjOhUganvMW+qlafMQ9F1vMSDLWrJcwlgP6M+pp1YUsENTb/GfCR0/0g7tE1pwaGoHEmy0AxNwh9BuHzbgYsiz5g7kxB1Z/a9kTQY6lDVaV5lmMgoSBatN0DCF93ZU79GglYz3+79RcTJaGkYGx1abNoMaG210SLMa9/nd6W8KyWqLbiTjMAO0lmwKr55KwM4wjSBBkTGowvW3WH2wDwjXoVyD1yX/hM8RXqLyW+nw8/ZjFj1/aO4+GIdqspikF8bbntQhSb1yrJuQ7Yc1GN1HQBVb5Mkab8mgGTj/1cNtkko0UvdYe2wzUn+M6Er48akSAVtIfPRfNTZoweuY+AuwChgi3g0Zky4VPYZ1SJpvenKYpNH+Fl4wh+THkDONtqKAjUXJCBIMPs9jD42l4VpHrTAIGf3lGsa91/C33f2nnepwkLsYtIj67RLz9szjA34YaeKQmF8yUNIo7H32OTDo/hijksV2K9WhtTSZ2rfH58h3qMjUq19+Ts/yxWTJGcU8LstGRBCe5PUcMx0wXBlqj2QJ92yTQY5/xpn9K/68VuLlRo765oBfKlGCyh+kc89k62M604LrHPcTt6RNu4lskkB8qN+I5YEtC0hhabx/sZRr+Gnc5/Pm3lL9ZZ6Ih7BYJfhPXLIsOs47VV6sW7bM3Fxb9v257wNyRzV4TbqLF5Ht5UKGbgVX/p8dD8xmwCkUBWxx7KVCeHcd+O6iE4on2cNFcSMH/F8L5xld1/vWyvmpkSzPjE6Pdb4JR96xnRSP+0f6XY7JIkF+J1nOvbPoQl+W92oG6SNCP0KBaPvs6g05LuGUZ7Zc9mNmZ9FlnmJljpURmWh0jw+SO1GKqHt46K8p5i2J41fiv39Y"}
{"assessingTool":"SOLID","filePath":"client/extractValue.go","grade":"D-","username":"HLamb","timestamp":"2025-10-12T17:09:52.599Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependencyInversion","violatingCode":"The extractValue function directly depends on the concrete *http.Response type, violating dependency inversion by not relying on abstractions.\n\n```go\nfunc extractValue(resp *http.Response) (*Res, error) {\n\tdefer func(Body io.ReadCloser) {\n\t\terr := Body.Close()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"error closing response body:\", err)\n\t\t}\n\t}(resp.Body)\n```","codeResolution":"The extractValue function should be refactored to depend on an abstraction for reading and parsing HTTP responses, improving testability and flexibility. Replace the original block with a call to the new abstraction:\n\n```go\ngo\nfunc extractValue(resp *http.Response) (*Res, error) {\n    parser := getResponseParser() // returns an abstraction implementing ResponseParser\n    return parser.Parse(resp)\n}\n```","severity":"Critical","rationale":"This code tightly couples the extractValue function to the net/http and encoding/json packages, violating dependency inversion principles. By directly depending on concrete implementations, it becomes difficult to substitute alternative HTTP clients or JSON parsers for testing or future changes. This rigidity reduces maintainability and testability, as mocking or swapping dependencies requires significant refactoring. Adhering to dependency inversion by introducing interfaces for HTTP and JSON handling would make the codebase more flexible and robust against changes.","lineStart":15,"lineEnd":33,"status":""},{"done":false,"titleTask":"liskovSubstitution","violatingCode":"The extractValue function violates Liskov Substitution Principle by tightly coupling its logic to the concrete *http.Response type, preventing substitution with other response implementations.\n\n```go\nfunc extractValue(resp *http.Response) (*Res, error) {\n    // ...\n}\n```","codeResolution":"The extractValue function is refactored to utilize an abstraction for response parsing, enabling substitutability and adherence to the Liskov Substitution Principle.\n\n```go\n// Go\nfunc extractValue(resp *http.Response) (*Res, error) {\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"request failed with status: %s\", resp.Status)\n\t}\n\tparser := getOperation(\"responseParser\") // returns an Operation interface\n\treturn parser.Parse(resp.Body)\n}\n```","severity":"Critical","rationale":"This code violates Liskov Substitution Principle because the extractValue function is tightly coupled to the http.Response type and the specific Res struct. There is no abstraction or interface that allows alternative response types or result structures to be substituted. This rigidity makes the code harder to maintain and extend, as any change in response handling or result format requires direct modification of extractValue. It also hinders testability, since mocking or substituting different response sources is not straightforward. Introducing interfaces for response reading and result parsing would improve substitutability, leading to more flexible and robust code.","lineStart":13,"lineEnd":38,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The extractValue function violates the Open/Closed Principle because any change to the response structure requires modifying the Res type and the unmarshalling logic.\n\n```go\ntype Res struct {\n    Value string                 `json:\"value\"`\n    Other map[string]interface{} `json:\"Other\"`\n}\n```","codeResolution":"The extractValue function can be refactored to delegate value extraction logic to an abstraction, improving adherence to the Open/Closed Principle and enabling easier extension for different response formats.\n\n```go\ngo\nfunc extractValue(resp *http.Response) (*Res, error) {\n    op := getOperation(resp)\n    return op.Extract(resp)\n}\n```","severity":"High","rationale":"The current implementation tightly couples the extraction logic to a specific response structure (`Res`). This violates the Open/Closed Principle because supporting new response formats or extracting additional fields would require modifying the `extractValue` function directly. Such changes increase the risk of introducing bugs and make the code harder to maintain as requirements evolve. Ideally, the extraction logic should be extensible—using interfaces or strategy patterns—so new formats can be supported without altering existing code. This would improve maintainability and correctness, allowing the codebase to adapt to future needs with minimal disruption.","lineStart":23,"lineEnd":44,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The code does not define any interfaces, forcing all clients to depend on a monolithic function rather than fine-grained abstractions, thus violating interface segregation.\n\n```go\nfunc extractValue(resp *http.Response) (*Res, error) {\n    // ...\n}\n```","codeResolution":"The extractValue function is refactored to utilize an abstraction for response extraction, promoting interface segregation and single responsibility.\n\n```go\n// Go\nfunc extractValue(resp *http.Response) (*Res, error) {\n    extractor := getOperation(\"responseExtractor\")\n    return extractor.Execute(resp)\n}\n```","severity":"Critical","rationale":"This code violates interface segregation by tightly coupling HTTP response handling, JSON parsing, and resource management within a single function (`extractValue`). This monolithic approach makes the code harder to maintain and test, as changes to one responsibility (e.g., parsing logic) could inadvertently affect others (e.g., error handling or resource cleanup). By not separating concerns into focused interfaces or functions, future extensions or substitutions (such as supporting different response formats or error strategies) become cumbersome and error-prone. Adhering to interface segregation would improve modularity, allowing each responsibility to evolve independently and enhancing overall maintainability.","lineStart":17,"lineEnd":34,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"F","liskovSubstitutionScore":"F","openClosedScore":"C-","singleResponsibilityScore":"A"},"codeDiff":{"changes":[{"newCode":"package client\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n\n// Res defines a structure with a single string field\ntype Res struct {\n\tValue string                 `json:\"value\"`\n\tOther map[string]interface{} `json:\"Other\"`\n}\n\n// extractValue extracts the value from the HTTP response and returns a Res struct\nfunc extractValue(resp *http.Response) (*Res, error) {\n\tdefer func(Body io.ReadCloser) {\n\t\terr := Body.Close()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"error closing response body:\", err)\n\t\t}\n\t}(resp.Body)\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"request failed with status: %s\", resp.Status)\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading response body: %w\", err)\n\t}\n\n\tvar res Res\n\tif err := json.Unmarshal(body, &res); err != nil {\n\t\treturn nil, fmt.Errorf(\"error unmarshalling response body: %w\", err)\n\t}\n\n\treturn &res, nil\n}\n","reason":"Modified","start":1,"end":41,"grade":"D-"}]},"hash":"544d15efea2280c3675258b68ecf15f6c33cbee06de8e1ae76debce2f1d09489","id":"eJyVU21v0zAQ/iuHpaF0qtLvQf0ABQkEUquu8AVPmkkuicE5B/uyUU397+icZOt4kSCf7PM9L/fYuVcmRozRUnPw3qlCXW0/vHutlqr0FW48MRKrQvWm/GYahNJZJNakyXa9DwyZJs1aIZW+stSsvkZPWo3FuuN5af28IuRVy9zLfiFEqxXsMUKFtSWMYCByGEoeAsKd5VYKlhqHUrfUQG3RVZr42GMCju1wL/SfjBseGn/9bsRbodWtNGl1I4AttxigM/3nEXRtiTHUpsT70wMgNSXAaTKMPziYcpKbNhG4RUjkUAffpe3bw2EHAWPvKSIYqiAgD4FkzkfzmuqByiesmYDgUpLK9xN+AdnlHuMSMAQfFuPIFdYYQPDZK18dwfp8j6baOB9x7tGMIUCxBunI01G2GA9sLWzwbA1k3dytue443wVL7CjTKulB6bzcxOM4X3x1LLRKfiY6CYhPyXwuYumGk0oqXbHhIW58haKYhhtL2/ez9piPuFmCuHgj2nWmVcDvA0aG2liH1fg2YgIXcBHFxplEsnMaxcVm8igJTPG8dO6pyT8H8VczYyIBTfV7InBxdx7K5OLWSH+UWz+TK9Ygjyz/SJ0JsTUuG90+DxgXL/7f0TDzuH/1NRGK4FJo0yNXS1VbhzvDrSrU+NOvzp9n3nh1+gkvf4NI"}
{"assessingTool":"Complexity","filePath":"client/client.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:09:52.023Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A+","testability":"A"},"issues":{"cyclomaticComplexity":3,"dependenciesModules":2,"functionMethodCounts":3,"linesOfCode":66,"nestingDepth":2}},"hash":"44d02efe11ac4cd09df65e3852bece30371b9606311b07dbb68ce12abd237f78","id":"eJzdVblu3DAQ/ZWJCkO7kKV+ATe2gbgIgoWPJlDDpUYSY4mkyVE2juF/D3jo8tpAUqSJGq3meHwzb4b7kjBr0Vohm3ulumSXXKled/hT0HOSJVxVeKUkoaRkl2jGH1mDwDuBkkpZStFrZQjSUpZUJhKpaIl0mTifszSC2uGQc9UXtTDIW9Hrc2WaolHntnosvlsl73iLPXM5G5dWFHDl8cGg1UpacegQamWgVV0lZAMHZhG4krVoBsNIKAlMVlChRlmh5AJtKelZ4whkyQyc4MVx2jNrj8pUMD2WjJCN810yiw+3X+A93w2RjnDxmS3Of4tPA1q6cxSM968sIcTXg3ujOFqrDJxYSvkae7A4T0hCUzOOQArYwZJhnODm/n4PSmPowFjxu2m+8GuVGnyCrRMoj9w2kI7fgUgGaIwym5nHuq4Zc+RhwYQIsCiDPNiyH8LV4hl9BOBJOWsMuFTVczqYLgNSjyhj67MR3rlhu4j9A+5f8XiNNRs6mloiSLBO/EILDCQeYXJYYpIjHAW1UIUkEG4TepQ0trgeJD9BTXUcqQwG0028w5LEfofIDWzjeb54gzQYCWfB5k3zfO7mIZzwQ0Sc0kWAOzc6Z/0nfyAS/Ss1Qshcz8qZhrzNlPhmVHcu8cSahvjXlQifvwn9dwq4DOCq18bdTUr6/Y+TsNBhBv4PRHDF/BMFFkvml9QCtQjaqF5TvDlrr4uSmf8OPYlhzFisxrsYY+9TPnZxs4RPI+jY/hkYtvNVn19PZrfEb/d31GVe+90FnC02fxTJnxXaF86NjZrhd8vSYlfcqyjgwaKvb309kfId8p7IIJCx2tNzVHi+ysnf3mE8j8ORAc/301guCnL/cyRqD/jpAqToINYUp1GKzh+3phwljuRGPaYknp/MQh5/jY7UpYULMsmSWnS4Z9QmuyRMWhFeeaOS19/fr+9u"}
{"assessingTool":"SOLID","filePath":"client/req.go","grade":"D-","username":"HLamb","timestamp":"2025-10-12T17:09:48.375Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"singleResponsibility","violatingCode":"The ExecuteRequest function violates single responsibility by handling request body merging, JSON marshaling, HTTP request creation, header setting, and request execution all within one method.\n\n```go\nbody, err := json.Marshal(d.Req.Body)\nreq, err := http.NewRequest(string(d.Req.Method), d.Req.URL, bytes.NewBuffer(body))\nclient := &http.Client{}\nresp, err := client.Do(req)\n```","codeResolution":"The solution introduces an abstraction layer for request execution, ensuring that each component adheres to the single responsibility principle by delegating HTTP operations to a dedicated type.\n\n```go\n// Go\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\top := getOperation(def, currentGen)\n\tresult, err := op.Execute()\n\tif err != nil {\n\t\tlog.Println(\"failed to execute operation\", err)\n\t\treturn nil\n\t}\n\treturn result\n}\n```","severity":"Critical","rationale":"This code violates the single responsibility principle by combining request construction, body merging, header management, authorization, and network execution within `ExecuteRequest` (lines 8–44). Such coupling makes the function harder to maintain and test, as changes to any aspect (e.g., body format or header logic) require modifying the same method. This increases the risk of introducing bugs and complicates future enhancements. Separating concerns—such as extracting body preparation, header setup, and HTTP execution into distinct functions—would improve maintainability, readability, and correctness.","lineStart":17,"lineEnd":41,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The code violates the open/closed principle by requiring direct modification of the ExecuteRequest function to support new request types or authentication schemes.\n\n```go\n// Set authorization\nreq.Header.Set(\"Authorization\", d.Req.Authorization)\n```","codeResolution":"The solution introduces an abstraction layer for request execution, allowing new request types or behaviors to be added without modifying existing logic. The original direct call to `ExecuteRequest` is replaced by invoking an `Operation` interface, promoting open/closed compliance.\n\n```go\n// Go\nop := getOperation(def.Req.Method)\nrequest, err := op.Execute(currentGen, def)\n```","severity":"Critical","rationale":"This implementation violates the open/closed principle by tightly coupling request construction logic to specific struct fields and direct map manipulation (e.g., lines 11–22). Any change to the request format or addition of new behaviors requires modifying the core ExecuteRequest function, increasing maintenance burden and risk of regressions. This rigidity hinders extensibility, as supporting new request types or authentication schemes would force invasive changes rather than allowing extension via new abstractions. Such design choices reduce maintainability and scalability, making future enhancements error-prone and costly. Refactoring to use interfaces or strategy patterns would better support open/closed compliance.","lineStart":22,"lineEnd":54,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code violates dependency inversion by directly instantiating and depending on the concrete http.Client type within the ExecuteRequest function.\n\n```go\nclient := &http.Client{}\nresp, err := client.Do(req)\n```","codeResolution":"The solution introduces an abstraction layer for HTTP operations, enabling dependency inversion by decoupling request execution from concrete implementations.\n\n```go\n// Go\n// Replace direct usage of http.Client with injected Operation abstraction\nfunc ExecuteRequest(currentGen map[string]any, d *jsonSchema.Definition, op Operation) (*http.Response, error) {\n\t// ... (body and request preparation as before)\n\treq, err := http.NewRequest(string(d.Req.Method), d.Req.URL, bytes.NewBuffer(body))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create request: %w\", err)\n\t}\n\tfor key, value := range d.Req.Headers {\n\t\treq.Header.Set(key, value)\n\t}\n\treq.Header.Set(\"Authorization\", d.Req.Authorization)\n\t// Use abstraction for execution\n\treturn op.Do(req)\n}\n```","severity":"Critical","rationale":"This code tightly couples the HTTP client instantiation (`client := &http.Client{}` in `ExecuteRequest`) and request execution logic directly within the function, violating dependency inversion principles. By depending on concrete implementations rather than abstractions (e.g., an injected interface for HTTP operations), the code becomes difficult to test, extend, or maintain. For example, swapping out the HTTP client for a mock in unit tests or customizing client behavior (timeouts, retries) would require modifying the function itself. Adhering to dependency inversion would allow for greater flexibility, easier testing, and improved maintainability by decoupling high-level logic from low-level details.","lineStart":22,"lineEnd":38,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The code violates interface segregation by forcing all request execution logic into a single ExecuteRequest function, making clients depend on unnecessary details regardless of their specific needs.\n\n```go\nfunc ExecuteRequest(currentGen map[string]any, d *jsonSchema.Definition) (*http.Response, error) {\n\t// Merge currentGen into the existing body\n\tif d.Req.Body == nil {\n\t\td.Req.Body = make(map[string]interface{})\n\t}\n\tfor key, value := range currentGen {\n\t\td.Req.Body[key] = value\n\t}\n```","codeResolution":"The solution applies interface segregation by delegating request execution to an abstraction, ensuring each component only depends on the methods it requires.\n\n```go\n// Go\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\toperation := getOperation(def.Req.Method)\n\trequest, err := operation.Execute(currentGen, def)\n\tif err != nil {\n\t\tlog.Println(\"failed to execute request\", err)\n\t\treturn nil\n\t}\n\n\tvalue, err := extractValue(request)\n\tif err != nil {\n\t\tlog.Println(\"failed to extract value\", err)\n\t\treturn nil\n\t}\n\n\treturn value\n}\n```","severity":"Critical","rationale":"This code violates interface segregation by tightly coupling HTTP request execution, body merging, header setting, and error handling into a single function (`ExecuteRequest`). This monolithic approach forces all consumers to depend on unnecessary details, making the code harder to maintain and test. For example, changes to request construction or error handling logic require modifications across unrelated concerns, increasing the risk of bugs. Segregating responsibilities into focused interfaces (e.g., a body builder, header manager, and request executor) would improve modularity, facilitate unit testing, and enhance maintainability.","lineStart":22,"lineEnd":41,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"F","liskovSubstitutionScore":"A+","openClosedScore":"D-","singleResponsibilityScore":"D"},"codeDiff":{"changes":[{"newCode":"package client\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/firechimp-org/go-sdk/jsonSchema\"\n\t\"log\"\n\t\"net/http\"\n)\n\n// ExecuteRequest executes an HTTP request based on the RequestFormat\nfunc ExecuteRequest(currentGen map[string]any, d *jsonSchema.Definition) (*http.Response, error) {\n\t// Merge currentGen into the existing body\n\tif d.Req.Body == nil {\n\t\td.Req.Body = make(map[string]interface{})\n\t}\n\tfor key, value := range currentGen {\n\t\td.Req.Body[key] = value\n\t}\n\n\t// Marshal the body to JSON\n\tbody, err := json.Marshal(d.Req.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal body: %w\", err)\n\t}\n\n\t// Create the HTTP request\n\treq, err := http.NewRequest(string(d.Req.Method), d.Req.URL, bytes.NewBuffer(body))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create request: %w\", err)\n\t}\n\n\t// Set headers\n\tfor key, value := range d.Req.Headers {\n\t\treq.Header.Set(key, value)\n\t}\n\t// Set authorization\n\treq.Header.Set(\"Authorization\", d.Req.Authorization)\n\n\t// Execute the request\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to execute request: %w\", err)\n\t}\n\n\treturn resp, nil\n}\n\n// the below occurs within the internal workings (i think)\nfunc SendRequest(def *jsonSchema.Definition, currentGen map[string]any) *Res {\n\t//the request that is sent out needs to send out a current map of the generated object.\n\n\trequest, err := ExecuteRequest(currentGen, def)\n\tif err != nil {\n\t\tlog.Println(\"failed to execute request\", err)\n\t\treturn nil\n\t}\n\n\tvalue, err := extractValue(request)\n\tif err != nil {\n\t\tlog.Println(\"failed to extract value\", err)\n\t\treturn nil\n\t}\n\n\treturn value\n}\n","reason":"Modified","start":1,"end":69,"grade":"D-"}]},"hash":"87c029de7050e65fa40eaf471b534bcadbeb7bac7700aaebebf9341448c2c10e","id":"eJyllE1v2zAMhv8KJ2CDXXj2PUAPW9t9od2KpNtl7kGxaVuLTaUSvTQr8t8HyXLibMgGbJcgoijyIV+aT0Jai9Yqqu+0bsVMLD5dv78UiSh0iReaGInFTKxlsZI1QtEqJM4pJ9WttWGIcso5F8sto83FcEAqdKmozr5ZTaOx6nj8Wytu+mVa6C6rlMGiUd36pTZ1VuuXtlz5Z4uiwU6OL1pdj38JOWuY1+4cO5Asg6tHLHrGOT70aBlwOFqQBO/u7m7BhIultFiCJuAGIXi/0aaTnFPVU/FLoKjojUHit0jQyfVXy0ZRfS9pm0AJZwfM9BIrRYqVphiiM4eXztGuNVlMAI3RJoYnx59lcIPGNfIQWhFrT4SPyrKiGpa63DpvVUGZzvEhfa3LLZyfA6l2iJPz9AI6ucJogqiI0VSywKed6xHv3E+lDaxwm8B32fYIs3Mwko5Rfov9dYXbezgfnoyRQh3S2Ea2ntwBA2v4sPj00V27sy/cZXF9SoN3dAgdhwqd17Oj0gxyb8hZEqg6Tq9cA6soF5VULZYuUReSu0QzeL7JhU8XHyNeGJSMnnA6B+7W4MMe0Ov1ETej7EMTA+oNcqPLOAlKfJ5fJ+Cn3b143VcVmshRxP9VTzGQBsDTFS2QoUFZorF/knRgfTc4HjBGU7pAjg7vDiMSMsieG23UD+kmOnRr+jQXr448xNidI3O8pw6flRdiosGwTBz1Cy/BhT8/7YaMdr0XaHBML3Vk8OG/+hxWw18aHQINDKTanHZh0/hhx1ZvQBdFbyxsFDdqWCj+oyPZwkablaLaQqTA3a7isF4WSOU4ZCVWJ1ZIAif3Tgxnc7TjKpm0E7iRDMqCdR3VPQMhltaVbJFKb5FjXBcUdOWhayQ0kt1aXH7DgtOxAz7sXoGTizGBEqvTkrS6Tm+NIm7pTzpMNZjqONHET+qeBx/ZyIK/OGMUgvwLhY8SttvfGYIxLMNdTiIRlWrxVnIjZmIY08x9LLUWu5/2C6Ze"}
{"assessingTool":"SOLID","filePath":"converison/hashmap.go","grade":"C-","username":"HLamb","timestamp":"2025-10-12T17:09:46.773Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"dependencyInversion","violatingCode":"The code directly depends on concrete types from external packages, violating dependency inversion by not using abstractions.\n\n```go\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n```","codeResolution":"The conversion functions should delegate field conversion to an injected abstraction, promoting loose coupling and testability.\n\n```go\n// Replace direct calls with abstraction usage\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap, converter FieldConverter) *jsonSchema.HashMap {\n\tif protoHashMap == nil {\n\t\treturn nil\n\t}\n\treturn &jsonSchema.HashMap{\n\t\tKeyInstruction:  protoHashMap.KeyInstruction,\n\t\tFieldDefinition: converter.ToModel(protoHashMap.FieldDefinition),\n\t}\n}\n\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap, converter FieldConverter) *pb.HashMap {\n\tif modelHashMap == nil {\n\t\treturn nil\n\t}\n\treturn &pb.HashMap{\n\t\tKeyInstruction:  modelHashMap.KeyInstruction,\n\t\tFieldDefinition: converter.ToProto(modelHashMap.FieldDefinition),\n\t}\n}\n```","severity":"Critical","rationale":"This code tightly couples the conversion logic to specific protobuf and Go model types, violating dependency inversion principles. By directly referencing concrete types (e.g., `pb.HashMap`, `jsonSchema.HashMap`), any change in these structures or the conversion process requires modifying this function, reducing maintainability and flexibility. It also makes unit testing difficult, as mocking or substituting dependencies is not straightforward. Introducing interfaces or abstraction layers for conversion would decouple the logic, making the codebase easier to extend, test, and maintain.","lineStart":7,"lineEnd":18,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The ConvertProtoToHashMap and ConvertModelToProtoHashMap functions violate interface segregation by directly depending on concrete types rather than abstractions, reducing flexibility and testability.\n\n```go\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n```","codeResolution":"The current conversion functions can be improved by delegating field conversion to an Operation abstraction, ensuring better adherence to the interface segregation principle.\n\n```go\n// Go\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\tif protoHashMap == nil {\n\t\treturn nil\n\t}\n\top := getOperation(\"protoToModel\")\n\treturn &jsonSchema.HashMap{\n\t\tKeyInstruction:  protoHashMap.KeyInstruction,\n\t\tFieldDefinition: op.Convert(protoHashMap.FieldDefinition),\n\t}\n}\n\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n\tif modelHashMap == nil {\n\t\treturn nil\n\t}\n\top := getOperation(\"modelToProto\")\n\treturn &pb.HashMap{\n\t\tKeyInstruction:  modelHashMap.KeyInstruction,\n\t\tFieldDefinition: op.Convert(modelHashMap.FieldDefinition),\n\t}\n}\n```","severity":"High","rationale":"The code violates interface segregation by tightly coupling conversion logic for both protobuf and Go model HashMap types within the same package and functions (lines 7–28). This approach reduces modularity and makes future changes harder, as any update to one conversion method may inadvertently affect the other. It also hinders testability and reusability, since clients must depend on all conversion logic even if they only need one direction. Separating conversion responsibilities into distinct, fine-grained interfaces would improve maintainability and allow clients to depend only on the functionality they require.","lineStart":1,"lineEnd":23,"status":""},{"done":false,"titleTask":"openClosed","violatingCode":"The code violates openClosed by requiring modification of existing conversion functions whenever a new field is added to the HashMap models.\n\n```go\nreturn &jsonSchema.HashMap{\n\tKeyInstruction:  protoHashMap.KeyInstruction,\n\tFieldDefinition: ConvertProtoToModel(protoHashMap.FieldDefinition),\n}\n```","codeResolution":"The conversion functions are refactored to leverage an abstraction for field conversion, ensuring new conversion strategies can be added without modifying existing code.\n\n```go\n// ConvertProtoToHashMap converts a protobuf HashMap to the Go model HashMap using an Operation abstraction\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\tif protoHashMap == nil {\n\t\treturn nil\n\t}\n\treturn &jsonSchema.HashMap{\n\t\tKeyInstruction:  protoHashMap.KeyInstruction,\n\t\tFieldDefinition: getOperation(\"protoToModel\").Convert(protoHashMap.FieldDefinition),\n\t}\n}\n\n// ConvertModelToProtoHashMap converts a Go model HashMap to a protobuf HashMap using an Operation abstraction\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n\tif modelHashMap == nil {\n\t\treturn nil\n\t}\n\treturn &pb.HashMap{\n\t\tKeyInstruction:  modelHashMap.KeyInstruction,\n\t\tFieldDefinition: getOperation(\"modelToProto\").Convert(modelHashMap.FieldDefinition),\n\t}\n}\n```","severity":"Critical","rationale":"This code violates the Open/Closed Principle because any new mapping logic between protobuf and Go models requires modifying the existing conversion functions (e.g., `ConvertProtoToHashMap`, `ConvertModelToProtoHashMap`). This approach tightly couples conversion logic to specific types, making the code harder to maintain and extend. If new fields or types are added to `HashMap`, every conversion function must be updated, increasing the risk of errors and regressions. A more extensible design would use interfaces or generic mapping strategies, allowing new types or fields to be supported without altering existing code, thus improving maintainability and correctness.","lineStart":13,"lineEnd":22,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"C-","liskovSubstitutionScore":"A+","openClosedScore":"F","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package converison\n\nimport (\n\tpb \"github.com/firechimp-org/go-sdk/grpc\"\n\t\"github.com/firechimp-org/go-sdk/jsonSchema\"\n)\n\n// ConvertProtoToHashMap converts a protobuf HashMap to the Go model HashMap\nfunc ConvertProtoToHashMap(protoHashMap *pb.HashMap) *jsonSchema.HashMap {\n\tif protoHashMap == nil {\n\t\treturn nil\n\t}\n\n\treturn &jsonSchema.HashMap{\n\t\tKeyInstruction:  protoHashMap.KeyInstruction,\n\t\tFieldDefinition: ConvertProtoToModel(protoHashMap.FieldDefinition),\n\t}\n}\n\n// ConvertModelToProtoHashMap converts a Go model HashMap to a protobuf HashMap\nfunc ConvertModelToProtoHashMap(modelHashMap *jsonSchema.HashMap) *pb.HashMap {\n\tif modelHashMap == nil {\n\t\treturn nil\n\t}\n\n\treturn &pb.HashMap{\n\t\tKeyInstruction:  modelHashMap.KeyInstruction,\n\t\tFieldDefinition: ConvertModelToProto(modelHashMap.FieldDefinition),\n\t}\n}\n","reason":"Modified","start":1,"end":31,"grade":"C-"}]},"hash":"1cac7bfb034f8da304ebf63c8d2fa6962b6e71189d99c0932e51e8f402cfdb0d","id":"eJyVk1FvwiAUhf8K4WGxprbvTXzSbDObmYk+8kIpLcyWS4AuWYz/faG2WtRt8Q3u5Rzu+QgHTK3l1kpV7QBqnOHtx/tqiWPMoOALUI4rhzOsKdvTiiMG6osbaUERRZRsNBiHJkQRp3NEcCWdaPOEQZOW0nAmZKNnYKq0gpkt9mllNCPYH///7KcFtWWCN9QrIn9fmqJFN4DbGHCwg1dqxZrqfixnEUXad/K2REPPAXKCoxdADRS8HupEla1i9/0mnclgMNV50q8jNL2MNRTRwQeSJQpU8zlSsj71iDPctUb5it8ffZhz8enWsle98e+Vss60zElQGQpuSMJufJI8S14XS15KJU+aMODaIwjiJVeKKO4nPIbEO+UONuOMI+zXeD3228cIod+xnHQmZ/K3ZKLxc5zJB6oHyF+sfiM+dn6M+DhdEOsv4jjGpaz5hjqBM3z5bamgVjRUJxXg4w8SiGA/"}
{"assessingTool":"Complexity","filePath":"client/model.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:09:45.190Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A","testability":"A"},"issues":{"cyclomaticComplexity":0,"dependenciesModules":1,"functionMethodCounts":0,"linesOfCode":15,"nestingDepth":1}},"hash":"b41b95475a37c6c947307e2bffbac5cb169fa0cdd6fb839a792342e92d005a89","id":"eJxdkU1uAjEMha9ieVnBzKbqgmXhAKg/q6YSJmNmAkmcJh6pCHH3KlCgxbs85/l9iQ9IpXApLvZvIh5nOJeQPH873eMErXQ8l6gcFWeYyO6oZ7DecVQTTXQhSVYw2DsdxnVjJbQbl9kOLqSp5L7tZVq6XbstEl/twIEMVqPuE8MLf41c9Fm6PRTNo1U4mGh0mSUkhVpFs4s93NeqzpsZTKebBlfVtuCNi06dRHi45TV/5Iutu0on67EStS3MM5MyEGQuSWLhX6or7j/1zLogpUoUKH2cYT8p7m9JpGRwBW2rgytQj2Apgg4cYc0QKJeBvOcOXFSpOlBK2UklkfWWrUJNb2rYe+nmUhQ2XkifHu9/Yzy3L2/CCW6c5yXpgDM8L60N0rFvesHjD/8Qs9M="}
{"assessingTool":"SOLID","filePath":"client/gzipRequestSender.go","grade":"C-","username":"HLamb","timestamp":"2025-10-12T17:09:42.583Z","codeReview":{"detailedReview":{"tasks":[{"done":false,"titleTask":"openClosed","violatingCode":"The GZipRequestSender violates openClosed by requiring modification of its implementation to support new compression or serialization strategies.\n\n```go\n// Compress the JSON data using gzip\nvar compressedData bytes.Buffer\ngzipWriter := gzip.NewWriter(&compressedData)\n\n_, err = gzipWriter.Write(jsonData)\n```","codeResolution":"The current SendRequestBody implementation tightly couples gzip compression logic, making it difficult to extend for other compression algorithms. Refactoring to use an abstraction for compression resolves openClosed concerns:\n\n```go\ngo\n// Use the CompressionStrategy abstraction to compress data\ncompressedData, err := grs.compressor.Compress(jsonData)\nif err != nil {\n    return nil, fmt.Errorf(\"compression error: %v\", err)\n}\n\n// Create an HTTP request with the compressed data\nreq, err := http.NewRequest(\"POST\", url, bytes.NewReader(compressedData))\n```","severity":"High","rationale":"The current implementation tightly couples the GZipRequestSender to gzip compression and JSON serialization, violating the Open/Closed Principle. If a new compression algorithm or serialization format is needed, the SendRequestBody method (lines 17–56) must be modified directly, increasing the risk of introducing bugs and making future extensions harder. This approach reduces maintainability, as changes require editing core logic rather than adding new, isolated components. Adhering to openClosed would allow new behaviors to be added via interfaces or composition, improving flexibility and reducing the likelihood of regressions.","lineStart":31,"lineEnd":38,"status":""},{"done":false,"titleTask":"interfaceSegregation","violatingCode":"The GZipRequestSender violates interface segregation by combining request compression, serialization, and HTTP transmission into a single struct, forcing clients to depend on all functionalities even if they only need one.\n\n```go\ntype GZipRequestSender struct{\n\tclient *http.Client\n}\n```","codeResolution":"The GZipRequestSender solution improves interface segregation by delegating compression and serialization to specialized abstractions, reducing class responsibility and enhancing maintainability.\n\n```go\n// Go\nfunc (grs *GZipRequestSender) SendRequestBody(baseURL, token string, requestBody *RequestBody) (*http.Response, error) {\n\turl := baseURL + \"/api/objectGen\"\n\tcompressedData, err := CompressAndSerialize(requestBody) // Uses abstraction\n\tif err != nil { return nil, err }\n\treq, err := http.NewRequest(\"POST\", url, compressedData)\n\tif err != nil { return nil, err }\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Content-Encoding\", \"gzip\")\n\treq.Header.Set(\"Authorization\", \"Bearer \"+token)\n\treturn grs.client.Do(req)\n}\n```","severity":"Critical","rationale":"This implementation violates the Interface Segregation Principle by combining request sending, JSON serialization, and gzip compression into a single GZipRequestSender struct and method (see lines 13–54). This tightly coupled design forces clients to depend on all behaviors, even if they only need one. Such coupling reduces maintainability, as changes to compression or serialization logic require modifying the same component. It also impairs testability, since mocking or substituting individual responsibilities is difficult. Separating concerns into focused interfaces (e.g., Compressor, Serializer, RequestSender) would improve modularity and allow clients to depend only on what they use.","lineStart":15,"lineEnd":44,"status":""},{"done":false,"titleTask":"dependencyInversion","violatingCode":"The GZipRequestSender directly depends on the concrete *http.Client type, violating dependency inversion by not relying on an abstraction.\n\n```go\ntype GZipRequestSender struct{\n\tclient *http.Client\n}\n```","codeResolution":"The revised solution introduces an abstraction for sending requests, allowing GZipRequestSender to depend on a generic RequestSender interface rather than directly on http.Client.\n\n```go\n// Go\ntype GZipRequestSender struct {\n\tsender RequestSender\n}\n\nfunc NewGZipRequestSender(sender RequestSender) *GZipRequestSender {\n\treturn &GZipRequestSender{sender: sender}\n}\n```","severity":"Critical","rationale":"This code violates dependency inversion by tightly coupling `GZipRequestSender` to the concrete `http.Client` type (see lines 8, 13, and 46). This direct dependency makes it difficult to substitute alternative HTTP clients (e.g., for testing or extending functionality), reducing maintainability and flexibility. Without an abstraction (such as an interface for the client), the code is harder to test in isolation and more prone to breaking if the underlying implementation changes. Introducing an interface for the HTTP client would improve testability and adherence to dependency inversion principles.","lineStart":8,"lineEnd":38,"status":""}],"codeReviewTitle":"SOLID Code Review"}},"gradingDetails":{"dependencyInversionScore":"F","interfaceSegregationScore":"D-","liskovSubstitutionScore":"A","openClosedScore":"C-","singleResponsibilityScore":"A+"},"codeDiff":{"changes":[{"newCode":"package client\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// GZipRequestSender is a request sender that compresses the request body using gzip\ntype GZipRequestSender struct{\n\tclient *http.Client\n}\n\n// NewGZipRequestSender initializes a new GZipRequestSender\nfunc NewGZipRequestSender(client *http.Client) *GZipRequestSender {\n\treturn &GZipRequestSender{\n\t\tclient: client,\n\t}\n}\n\n// SendRequestBody sends a gzip-compressed JSON request and returns a response\nfunc (grs *GZipRequestSender) SendRequestBody(baseURL, token string, requestBody *RequestBody) (*http.Response, error) {\n\turl := baseURL + \"/api/objectGen\"\n\n\t// Serialize the request body to JSON\n\tjsonData, err := json.Marshal(requestBody)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error marshalling request body: %v\", err)\n\t}\n\n\t// Compress the JSON data using gzip\n\tvar compressedData bytes.Buffer\n\tgzipWriter := gzip.NewWriter(&compressedData)\n\n\t_, err = gzipWriter.Write(jsonData)\n\tif err != nil {\n\t\tgzipWriter.Close()\n\t\treturn nil, fmt.Errorf(\"error writing to gzip writer: %v\", err)\n\t}\n\n\terr = gzipWriter.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error closing gzip writer: %v\", err)\n\t}\n\n\t// Create an HTTP request with the compressed data\n\treq, err := http.NewRequest(\"POST\", url, &compressedData)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating request: %v\", err)\n\t}\n\n\t// Set headers - including gzip encoding\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Content-Encoding\", \"gzip\")\n\treq.Header.Set(\"Authorization\", \"Bearer \"+token)\n\n\t// Send the request and return the response\n\tresp, err := grs.client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error sending request: %v\", err)\n\t}\n\n\treturn resp, nil\n}\n","reason":"Modified","start":1,"end":67,"grade":"C-"}]},"hash":"762e250541d7a09c2b74699a1b1b687084d296a21acafb5b6506a68bdb82437b","id":"eJydVVFP2zAQ/is3S0MJlPS9Eg+jINjECqKdJk2RJje5tobUDvaFqiD++3S2U9K1sImn1pe7+7777nx+FtI5dE7p+cSYSgzE+Prq65noicKUODSaUJMYiFoW93KOUFQKNeU612pZG0uQ5DqnXEzXhC4X4VCYZW3Ruf78SdWtEXVhSqXn/TtndGucLan9q5H6CyLvnzJAvw8Xv1R9iw8NOhqjLtGCciDBBhO4YKOFJGgx0QEtcOMyNeUaGi4PPBlN6xr35HVkm4KemUooEQ6ZTDaM9b5ERiNc7SGlFSlZqSdkdhpXuwC5njW62Bue7AFM4XAXxrOzSI3VcLDz2X9t2Q9io3psfHmlz64x6pSVYQWZM2tzvJGwhG/j69FGQ6lLCLBBfFcb7TBWlMyt20M2/RsqmUqHP26vekDmHjULrvS814J4Nocd/xSSIMhtxOsBWmtsGmRobAWDE4hJ4Qhy0Ze16pvpHRZ0gWHCdE6+aBu6szsZZHyp7MhjeSZJehzOzYbsu7RuIaukQ5OHk9TMu306Aa0qiNrH3mhV9WC2pOycCc+SXHjmsAy5Kh7GLosBfH7MhcdNY78i82HsiCfue1JKklvznNOjtK/TX3IJ4G9jdtrMZjx5ObHrT6sIfWF8yka4CpbkYDs4Dei/gw7BO3hm/idphXpbh07IsDIOk/S/9FlZRVwYGQ/qz2jfUGeHXAfpI80pKrNR9X1k7otFSQhSw+VkcrNp5krRwreqc5O4YeHePmwmy8/1CFdx3JNc3FyPJwzV2KoHexrysZKYZWfY3q5njAQLlCVaB8egdFE15UaMdnHHKrJL75iNkYnHF+J4sq6Rc+dC1nWlCknK6Ljq03cjz9v0Pjq8GPsjvjS0MFY9+dzB/RSlRQu5OPJbJe1UpMut6/66xKK53WIM5OpNb+bWZWF3ZmeGr/2H5efd+m/1Y5LAQavK72rREzNV4Y2khRiIQMc/pls7Npsb8fIHZSfNAg=="}
{"assessingTool":"Complexity","filePath":"converison/focus.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:09:39.257Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A+","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":2,"functionMethodCounts":2,"linesOfCode":33,"nestingDepth":2}},"hash":"440797a7dd531fffceaaa8585254b9e635243f17da35fabcb35938dfc2c47079","id":"eJyVk8FugzAQRH/F8qFKIhLuSDlFSg9VVaTm6As4i3EDXsteqlZR/r0ypoGkaapygtmZ8fpJHHnhPXivjdohNjzjG2xtAx+aPnnCJe5hg4bAEM+4LeShUMAkmndw2qMRRhjdWnTEZsIIsiUTXGmqu3IlsU0r7UDWurVLdCpVuPT7Q6qclYIH+9/eN4/mVdbQFiExD+elKdv0C1DukHCHW5SdH5Yizwpmg152FYsTQkY1sEdkLe6hiaowVWfkraZZH4/RhS1X/ducLcZVosSO4Qq6YhP/es2MbuJEkAPqnAlK+D6F5c/iw3XdkMkdtpYyFp+xehUHSXRtNTR7f8MVB4PrCcC+OK20KZps6poOkmG30yXb54Bqh/l4twngS5QB8DX0S7w/ymZ9fGB8TWI+Yj8znvj/wfi75ibbsfIe24nrDtuJ6xe2POGVbiAvqOYZH/+gtOpTCvnpC1WPTP0="}
{"assessingTool":"Complexity","filePath":"client/requestSender.go","grade":"A-","username":"HLamb","timestamp":"2025-10-12T17:09:38.798Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"grades":{"maintainabilityIndex":"A+","qualityDesign":"A+","readability":"A+","testability":"A"},"issues":{"cyclomaticComplexity":2,"dependenciesModules":4,"functionMethodCounts":2,"linesOfCode":50,"nestingDepth":2}},"hash":"309678a5d12aba028a71c15171eeceaaa7a261828bf3498ea13ec8d97a3d3b5c","id":"eJydVEtP3DAQ/itTS60SSLP3lTiUpSqqWkDs9uaLN5nsGrzjYE9KF8R/r/wILFVQJW6xZ/w95pFHobxH7zVtVtYaMRcLu+sN/tG8F5VobIsLS4zEYi561dyqDUJjNBJLkqR3vXUMhSTJUqz3jF6KdEBqbKtpM7vxlsbLbsfjJyHPtsx9OJcBazaDM+zUYPga7wb0vERq0YH2oKBNEdBB3A6JFWtLYDt4lSyJ9z1O43h2Q8OPgT0ZgKPAXy+ym6cs4gLvp3WQZq2MfsAgiPB+kkZSN1DzFkgxwVzC0SRfVOqQB0fwaSojJoxm5rkrVbh8enETUvOrU9vuwSO1Qf/35eUFuBQARS0kphBy6HtLHrOVwvlpheW/4MVaefx1/aMCtrdIoeKaNtVIE/mPDvJLKFIhrjNjBeicdWXyPjgD8xPIoHAMUsxUr2d2fYMNf8M0VSQ52nSpN8BbfPa1Doxso9mQGEbxTLGKPAE7XNQ/lfNbZYoDmWEgWXcx7cMJkDaQq50bQtpU0O24/hoEd4UUUTnsEpbRtHmlYg4ff0sRecvcoax84VAxgiI4X62uxkep93fPQmOZLvA+V6+Q4upyuQqIgzMVxM0L8dOh69AVo9Hy3UaaIOvAxdsGlsiwRdWi81l1fR6P9RKD0Pz/+Lza9xgQpFB9b3QTNzj/HcrJl18G3lqnH2JmenqKyqEDKY7jiJUHKqh91fuXmc7X41AHIt8/V9b5Om1OfWbDCLy7YmGz/l+wDJIkkDZxU0UlOm3wSvFWzEWSM3OHu1ZvrHj6Cw/4Dm8="}
{"assessingTool":"SOLID","filePath":"client/client.go","grade":"A","username":"HLamb","timestamp":"2025-10-12T17:09:32.819Z","codeReview":{"review":"Congratulations! Your most recent code changes passed."},"gradingDetails":{"dependencyInversionScore":"A+","interfaceSegregationScore":"A+","liskovSubstitutionScore":"A+","openClosedScore":"A+","singleResponsibilityScore":"A"},"codeDiff":{"changes":[{"newCode":"package client\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/firechimp-org/go-sdk/jsonSchema\"\n)\n\n// Client responsible for holding base configuration and dependencies\ntype Client struct {\n\tPassword          string\n\tBaseURL           string\n\tHttpClient        HttpClient\n\tRequestSender     RequestSender\n\tResponseProcessor ResponseProcessor\n}\n\n// HttpClient interface to abstract HTTP operations\ntype HttpClient interface {\n\tDo(req *http.Request) (*http.Response, error)\n}\n\n// RequestSender interface abstracts request sending behavior\ntype RequestSender interface {\n\tSendRequestBody(url, token string, requestBody *RequestBody) (*http.Response, error)\n}\n\n// NewDefaultClient initializes a new Client instance with default implementations\nfunc NewDefaultClient(password, url string, client *http.Client) *Client {\n\treturn &Client{\n\t\tPassword:          password,\n\t\tBaseURL:           url,\n\t\tHttpClient:        client,\n\t\tRequestSender:     NewDefaultRequestSender(client),\n\t\tResponseProcessor: NewResponseProcessor(),\n\t}\n}\n\n// NewGZipClient initializes a new Client instance with GZip compression for requests\nfunc NewGZipClient(password, url string, client *http.Client) *Client {\n\treturn &Client{\n\t\tPassword:          password,\n\t\tBaseURL:           url,\n\t\tHttpClient:        client,\n\t\tRequestSender:     NewGZipRequestSender(client),\n\t\tResponseProcessor: NewResponseProcessor(),\n\t}\n}\n\n// SendRequest sends the prompt and definition, and returns the parsed response\nfunc (c *Client) SendRequest(prompt string, definition *jsonSchema.Definition) (*Response, error) {\n\trequestBody := &RequestBody{\n\t\tPrompt:     prompt,\n\t\tDefinition: definition,\n\t}\n\n\t// Use the RequestSender to send the request\n\tresp, err := c.RequestSender.SendRequestBody(c.BaseURL, c.Password, requestBody)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Process the response\n\treturn c.ResponseProcessor.ProcessResponse(resp)\n}\n","reason":"Modified","start":1,"end":66,"grade":"A"}]},"hash":"004fc68a471ef7050927108147c9af6c88f958cb032dc64873edebd28ac9afb3","id":"eJzdVclu2zAQ/ZWpDoFsKNLdQC6pgaZA0BpZLoUuDDWS2EgkQ45qpEH+veCiLU6B9tBLdZE1y+ObeTP0S8KsRWuFbO6U6pJdcvv1+vM+yRKuKvyoJKGkZJdoxh9Zg8A7gZJKWUrRa2UI0lKWVCYSqWiJdJk4n7M0gtrhIeeqL2phkLei1+fKNEWjzm31WHy3St7yFnvmcjYurSjgo8cHg1YracVDh1ArA63qKiEbeGAWgStZi2YwjISSwGQFFWqUFUou0JaSnjWOQJbMwAleHKcDs/aoTAXTY8kI2TjfJbN4f3MN7/muiHSEi89scf4bfBrQ0q2jYLx/ZQkhvh48GMXRWmXgxFLK19iDxXlCEpqacQRSwB4sGcYJru7uDqA0hg6MFb+b5gvfq9TgE2ydQHnktoF0/A5EMkBjlNnMPNZ1zZgjDwsmRIBFGeTBlv0QrhbP6HcAnpSzxoBLVT2ng+kyIPWIMrY+G+GdG7aL2D/g/gWPe6zZ0NHUEkGCdeInWmAg8QiTwxKTHOEoqIUqJIHodYc9ShpbXA+Sn6CmOo5UBoPpJt5hSWK/Q+QGtvE8X7xBGoyEs2Dzpnk+d/MQTvghIk7pIsCdG52z/pM/EIn+lRohZK5n5UxD3mZKfDOqO5d4Yk1D/OtKhE/fhP47BVwGcNVr464lJf3+x0lY6DAD/wciuGL+iQKLJfNLaoFaBG1UrynenLXXRcnMf4eexDBmLFbjXYyx9ykfu7hZwqcRdGz/DAzb+arP95PZLfHb/R11mdd+dwFni80fRfJnhfaFc2OjZvjdsrTYFfcqCri36OtbX0+kfIe8JzIIZKz29BwVnq9y8rd3GM/jcGTA88M0louC3P8cidoDfrgAKTqINcVplKLzx60pR4kjuVGPKYnnJ7OQx1+jI3Vp4YJMsqQWHR4YtckuCZNWhFfeqOT1Fxx27Ls="}
